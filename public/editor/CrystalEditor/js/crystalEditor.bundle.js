/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// NAMESPACE OBJECT: ./build/three.module.js
var three_module_namespaceObject = {};
__webpack_require__.r(three_module_namespaceObject);
__webpack_require__.d(three_module_namespaceObject, {
  bGH: () => (AddEquation),
  Mig: () => (AmbientLight),
  m7l: () => (AnimationClip),
  N$j: () => (Bone),
  ZzF: () => (Box3),
  DvJ: () => (BoxGeometry),
  TlE: () => (BufferAttribute),
  u9r: () => (BufferGeometry),
  uWy: () => (ClampToEdgeWrapping),
  SUY: () => (Clock),
  Ilk: () => (Color),
  b_z: () => (ConeGeometry),
  Xaj: () => (CustomBlending),
  m_w: () => (CylinderGeometry),
  fHI: () => (CylinderGeometry),
  IEO: () => (DataTexture),
  yxD: () => (DataTextureLoader),
  A5E: () => (DataUtils),
  $YQ: () => (DepthTexture),
  Ox3: () => (DirectionalLight),
  ehD: () => (DoubleSide),
  fSK: () => (DstAlphaFactor),
  Vdb: () => (DstColorFactor),
  pBf: () => (EventDispatcher),
  hH6: () => (FileLoader),
  a$l: () => (Float32BufferAttribute),
  VzW: () => (FloatType),
  ybr: () => (Fog),
  JfN: () => (FontLoader),
  Wl3: () => (FrontSide),
  ZAu: () => (Group),
  cLu: () => (HalfFloatType),
  vmT: () => (HemisphereLight),
  QRU: () => (ImageBitmapLoader),
  vpT: () => (InterleavedBuffer),
  kB5: () => (InterleavedBufferAttribute),
  _C8: () => (Interpolant),
  Syv: () => (InterpolateDiscrete),
  NMF: () => (InterpolateLinear),
  x12: () => (Line),
  Zzh: () => (Line3),
  nls: () => (LineBasicMaterial),
  blk: () => (LineLoop),
  ejS: () => (LineSegments),
  rnI: () => (LinearEncoding),
  wem: () => (LinearFilter),
  D1R: () => (LinearMipmapLinearFilter),
  qyh: () => (LinearMipmapNearestFilter),
  aNw: () => (Loader),
  Zp0: () => (LoaderUtils),
  RsA: () => (three_module_MOUSE),
  F5T: () => (Material),
  M8C: () => (MathUtils),
  Vkp: () => (Matrix3),
  yGw: () => (Matrix4),
  Kj0: () => (three_module_Mesh),
  vBJ: () => (MeshBasicMaterial),
  lRF: () => (MeshDepthMaterial),
  YBo: () => (MeshLambertMaterial),
  RSm: () => (MeshNormalMaterial),
  xoR: () => (MeshPhongMaterial),
  EJi: () => (MeshPhysicalMaterial),
  Wid: () => (MeshStandardMaterial),
  OoA: () => (MirroredRepeatWrapping),
  TyD: () => (NearestFilter),
  aH4: () => (NearestMipmapLinearFilter),
  YLQ: () => (NearestMipmapNearestFilter),
  jFi: () => (NoBlending),
  dUE: () => (NumberKeyframeTrack),
  Tme: () => (Object3D),
  iKG: () => (OrthographicCamera),
  anP: () => (PMREMGenerator),
  cPb: () => (PerspectiveCamera),
  JOQ: () => (Plane),
  BKK: () => (PlaneGeometry),
  _12: () => (PlaneGeometry),
  cek: () => (PointLight),
  woe: () => (Points),
  UY4: () => (PointsMaterial),
  iUV: () => (PropertyBinding),
  _fP: () => (Quaternion),
  iLg: () => (QuaternionKeyframeTrack),
  mSO: () => (RGBADepthPacking),
  wk1: () => (RGBAFormat),
  KC9: () => (RGBEEncoding),
  aoB: () => (RGBEFormat),
  UCm: () => (RGBFormat),
  FIo: () => (RawShaderMaterial),
  iMs: () => (Raycaster),
  rpg: () => (RepeatWrapping),
  xsS: () => (Scene),
  jyz: () => (ShaderMaterial),
  oa8: () => (ShapeGeometry),
  OdW: () => (Skeleton),
  TUv: () => (SkinnedMesh),
  aLr: () => (Sphere),
  Aip: () => (SphereGeometry),
  xo$: () => (SphereGeometry),
  $V: () => (Spherical),
  PMe: () => (SpotLight),
  QmN: () => (three_module_TOUCH),
  IOt: () => (TangentSpaceNormalMap),
  MP$: () => (TextGeometry),
  xEZ: () => (Texture),
  dpR: () => (TextureLoader),
  CJI: () => (Triangle),
  z$h: () => (TriangleFanDrawMode),
  UlW: () => (TriangleStripDrawMode),
  WwZ: () => (TrianglesDrawMode),
  qlB: () => (Uint16BufferAttribute),
  rBU: () => (UniformsLib),
  rDY: () => (UniformsUtils),
  ywz: () => (UnsignedByteType),
  LsT: () => (UnsignedShortType),
  FM8: () => (Vector2),
  Pa4: () => (three_module_Vector3),
  Ltg: () => (Vector4),
  yC1: () => (VectorKeyframeTrack),
  dd2: () => (WebGLRenderTarget),
  CP7: () => (WebGLRenderer),
  Uk6: () => (WireframeGeometry),
  c8b: () => (ZeroFactor),
  knz: () => (sRGBEncoding)
});

;// CONCATENATED MODULE: ./Renderer/log.js
var log_mode = 3;

// type : 0 -> error
// type : 1 -> warning
// type : 2 -> 기타

/**
 * 로그 메시지를 출력한다.
 * @param {Number} type 로그 타입
 * @param {String} message 로그 메시지
 */
function rayLog(type, message) {
  if (type >= log_mode) return;
  console.log(message);
}

/**
 * 로드 모드를 설정한다.
 * @param {Number} mode 로그 모드
 */
function rayLogSetMode(mode) {
  log_mode = mode;
}
;// CONCATENATED MODULE: ./CoreCrystal/AtomDef.js
/**
 * @file 원소의 정보를 정의한 클래스
 * @version 0.1
 */
var AtomDef = {};
AtomDef._atomDefList = [];
AtomDef._atomNumList = [];

/**
 * index에 해당하는 원자 정보를 반환한다
 * @param {Number} index 원자 인덱스
 * @returns {CAtomDef} 원자 인덱스에 해당하는 정의
 */
AtomDef.GetDefWithNumber = function (index) {
  return AtomDef._atomNumList[index];
};

/**
 * id에 해당하는 원자 정보를 반환한다
 * @param {String} id 원자 아이디
 * @returns {CAtomDef} 원자 아이디에 해당하는 정의
 */
AtomDef.GetDefWithID = function (id) {
  return AtomDef._atomDefList[id.toUpperCase()];
};

/**
 * 한 원소의 특성을 정의한 클래스다. 이름, 반지름, 질량 등이 정의된다.
 * */
class CAtomDef {
  /**
   * 원소를 정의한다
   * @param {Number} number 원소 번호
   * @param {String} atom 원소 기호
   * @param {String} kname 원소 이름 (한글)
   * @param {String} name 원소 이름 (영문)
   * @param {Number} r 컬러 R
   * @param {Number} g 컬러 G
   * @param {Number} b 컬러 B
   * @param {Number} radius 반지름
   * @param {Number} metal 메탈
   * @param {Number} group 그룹
   * @param {Number} period 주기율
   */
  constructor(number, atom, kname, name, r, g, b, radius, metal, group, period) {
    /// AtomDef의 ID이다. string
    this._id = atom.toUpperCase();

    /// 원소의 이름. string
    this._atom_id = atom;

    /// 원소의 반지름. 
    this._radius = (radius + 100) / 500 * 1.;
    this._empirical_radius = radius;

    /// 원소의 이름. 영문
    this._name = name;

    /// 원소의 이름. 한글
    this._korean_name = kname;

    /// 원소의 컬러
    this._color = [0, 0, 0];

    /// 원소의 디퓨즈 컬러
    this._diffuseColor = [0, 0, 0];

    /// 원소의 emissive 컬러
    this._emissiveColor = [0, 0, 0];

    /// 원소의 specular 컬러
    this._specularColor = [1, 1, 1];
    this.setColor(r / 255, g / 255, b / 255);
    this.setDefaultColor(r / 255, g / 255, b / 255);

    /// 원소의 Ambient 컬러
    this._ambientColor = [0.0, 0.0, 0.0];

    /// 원소의 specular power
    this._specularPower = 15;

    /// 원소의 원자수
    this._atom_number = number;

    /// 메탈
    this._metal = metal;

    /// 원소의 주기
    this._period = period;

    /// 원소의 그룹
    this._group = group;

    /// 가질 수 있는 본드의 수
    this._vsepr_type = 0;

    /// lone pair 의 수
    this._vsepr_lpair = 0;

    /// 원소 결합시 각도
    this._vsepr_angle = 0;

    /// 원소 크기
    this._atom_vis_size = 1;

    /// 원소 가시화 여부
    this._visible = true;
  }

  /**
   * 색상을 정의한다
   * @param {Number} r red
   * @param {Number} g green
   * @param {Number} b blue
   */
  setColor(r, g, b) {
    this._color = [r, g, b];
    this._diffuseColor = [r, g, b];
    this._emissiveColor = [r * 0.1, g * 0.1, b * 0.1];
    this._specularColor = [1, 1, 1];
  }
  /**
   * 기본 컬러를 정의한다
   * @param {Number} r red
   * @param {Number} g green
   * @param {Number} b blue
   */
  setDefaultColor(r, g, b) {
    this._defColor = [r, g, b];
  }
  /**
   * 기본 원소 문자 크기를 정의한다
   * @param {Number} size 크기
   */
  setNameSize(size) {
    this._atom_vis_size = size;
  }
}
;

/**
 * 원소의 VSEPR 값을 정의
 * @param {String} atom 원소 기호
 * @param {String} type 타입
 * @param {Function} lone_pair long pair
 * @param {Function} angle 각도
 */
function setAtomVSEPR(atom, type, lone_pair, angle) {
  var atom_def = AtomDef._atomDefList[atom.toUpperCase()];
  if (!atom_def) return;
  atom_def._vsepr_type = type;
  atom_def._vsepr_lpair = lone_pair;
  atom_def._vsepr_angle = angle;
}

/**
 * 원소의 메탈 값을 정의
 * @param {String} atom 원소
 * @param {Number} metal 메탈 값
 */
function setAtomMetal(atom, metal) {
  var atom_def = AtomDef._atomDefList[atom.toUpperCase()];
  if (!atom_def) return;
  atom_def._metal = metal;
}

/**
* 원소의 Isotope 값을 설정
* @param {String} isotope 원소의 isotope
* @param {String} atom
*/
function addIsotope(isotope, atom) {}

/**
 * 원소의 정보를 정의한다
 * @param {Number} number
 * @param {String} atom
 * @param {String} kname
 * @param {String} name
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} radius
 * @param {Number} metal
 * @param {String} group
 * @param {Number} period
 */
function setAtomData(number, atom, kname, name, r, g, b, radius, metal, group, period) {
  var atom_def = new CAtomDef(number, atom, kname, name, r, g, b, radius, metal, group, period);
  AtomDef._atomDefList[atom.toUpperCase()] = atom_def;
  AtomDef._atomNumList[number] = atom_def;
}

///////////////////
// setAtomData
///////////////////

setAtomData(1, "H", "수소", "Hydrogen", 180, 180, 180, 25, 0, 1, 1);
setAtomData(2, "He", "헬륨", "Helium", 217, 235, 235, 120, 0, 18, 1);
setAtomData(3, "Li", "리튬", "Lithium", 204, 128, 255, 145, 0, 1, 2);
setAtomData(4, "Be", "베릴륨", "Beryllium", 194, 255, 0, 105, 0, 2, 2);
setAtomData(5, "B", "붕소", "Boron", 255, 181, 181, 85, 0, 13, 2);
setAtomData(6, "C", "탄소", "Carbon", 94, 94, 94, 70, 0, 14, 2);
setAtomData(7, "N", "질소", "Nitrogen", 48, 80, 248, 65, 0, 15, 2);
setAtomData(8, "O", "산소", "Oxygen", 255, 13, 13, 60, 0, 16, 2);
setAtomData(9, "F", "플루오린", "Fluorine", 144, 224, 80, 50, 0, 17, 2);
setAtomData(10, "Ne", "네온", "Neon", 179, 227, 245, 160, 0, 18, 2);
setAtomData(11, "Na", "나트륨", "Sodium", 171, 92, 242, 180, 0, 1, 3);
setAtomData(12, "Mg", "마그네슘", "Magnesium", 138, 255, 0, 150, 0, 2, 3);
setAtomData(13, "Al", "알루미늄", "Aluminium", 191, 166, 166, 125, 0, 13, 3);
setAtomData(14, "Si", "규소", "Silicon", 240, 200, 160, 110, 0, 14, 3);
setAtomData(15, "P", "인", "Phosphorus", 255, 128, 0, 100, 0, 15, 3);
setAtomData(16, "S", "황", "Sulfur", 255, 255, 48, 100, 0, 16, 3);
setAtomData(17, "Cl", "염소", "Chlorine", 31, 240, 31, 100, 0, 17, 3);
setAtomData(18, "Ar", "아르곤", "Argon", 128, 209, 227, 71, 0, 18, 3);
setAtomData(19, "K", "칼륨", "Potassium", 143, 64, 212, 220, 0, 1, 4);
setAtomData(20, "Ca", "칼슘", "Calcium", 61, 255, 0, 180, 0, 2, 4);
setAtomData(21, "Sc", "스칸듐", "Scandium", 170, 170, 170, 160, 0, 3, 4);
setAtomData(22, "Ti", "티타늄", "Titanium", 191, 194, 199, 140, 0, 4, 4);
setAtomData(23, "V", "바나듐", "Vanadium", 166, 166, 171, 135, 0, 5, 4);
setAtomData(24, "Cr", "크롬", "Chromium", 138, 153, 199, 140, 0, 6, 4);
setAtomData(25, "Mn", "망가니즈", "Manganese", 156, 122, 199, 140, 0, 7, 4);
setAtomData(26, "Fe", "철", "Iron", 224, 102, 51, 140, 0, 8, 4);
setAtomData(27, "Co", "코발트", "Cobalt", 240, 144, 160, 135, 0, 9, 4);
setAtomData(28, "Ni", "니켈", "Nickel", 80, 208, 80, 135, 0, 10, 4);
setAtomData(29, "Cu", "구리", "Copper", 200, 128, 51, 135, 0, 11, 4);
setAtomData(30, "Zn", "아연", "Zinc", 125, 128, 176, 135, 0, 12, 4);
setAtomData(31, "Ga", "갈륨", "Gallium", 194, 143, 143, 130, 0, 13, 4);
setAtomData(32, "Ge", "게르마늄", "Germanium", 102, 143, 143, 125, 0, 14, 4);
setAtomData(33, "As", "비소", "Arsenic", 189, 128, 227, 115, 0, 15, 4);
setAtomData(34, "Se", "셀레늄", "Selenium", 255, 161, 0, 115, 0, 16, 4);
setAtomData(35, "Br", "브로민", "Bromine", 166, 41, 41, 115, 0, 17, 4);
setAtomData(36, "Kr", "크립톤", "Krypton", 92, 184, 209, 115, 0, 18, 4);
setAtomData(37, "Rb", "루비듐", "Rubidium", 112, 46, 176, 235, 0, 1, 5);
setAtomData(38, "Sr", "스트론튬", "Strontium", 0, 255, 0, 200, 0, 2, 5);
setAtomData(39, "Y", "이트륨", "Yttrium", 148, 255, 255, 180, 0, 3, 5);
setAtomData(40, "Zr", "지르코늄", "Zirconium", 148, 224, 224, 155, 0, 4, 5);
setAtomData(41, "Nb", "나이오븀", "Niobium", 115, 194, 201, 145, 0, 5, 5);
setAtomData(42, "Mo", "몰리브데넘", "Molybdenum", 84, 181, 181, 145, 0, 6, 5);
setAtomData(43, "Tc", "테크네튬", "Technetium", 59, 158, 158, 135, 0, 7, 5);
setAtomData(44, "Ru", "루테늄", "Ruthenium", 36, 143, 143, 130, 0, 8, 5);
setAtomData(45, "Rh", "로듐", "Rhodium", 10, 125, 140, 135, 0, 9, 5);
setAtomData(46, "Pd", "팔라듐", "Palladium", 0, 105, 133, 140, 0, 10, 5);
setAtomData(47, "Ag", "은", "Silver", 192, 192, 192, 160, 0, 11, 5);
setAtomData(48, "Cd", "카드뮴", "Cadmium", 255, 217, 143, 155, 0, 12, 5);
setAtomData(49, "In", "인듐", "Indium", 166, 117, 115, 155, 0, 13, 5);
setAtomData(50, "Sn", "주석", "Tin", 102, 128, 128, 145, 0, 14, 5);
setAtomData(51, "Sb", "안티모니", "Antimony", 158, 99, 181, 145, 0, 15, 5);
setAtomData(52, "Te", "텔루륨", "Tellurium", 212, 122, 0, 140, 0, 16, 5);
setAtomData(53, "I", "아이오딘", "Iodine", 148, 0, 148, 140, 0, 17, 5);
setAtomData(54, "Xe", "제논", "Xenon", 66, 158, 176, 140, 0, 18, 5);
setAtomData(55, "Cs", "세슘", "Caesium", 87, 23, 143, 260, 0, 1, 6);
setAtomData(56, "Ba", "바륨", "Barium", 0, 201, 0, 215, 0, 2, 6);

// Lantan Group - Period/Group Modified for Table.
setAtomData(57, "La", "란타넘", "Lanthanum", 112, 212, 255, 195, 0, 3, 8);
setAtomData(58, "Ce", "세륨", "Cerium", 255, 255, 199, 185, 0, 4, 8);
setAtomData(59, "Pr", "프라세오디뮴", "Praseodymium", 217, 255, 199, 185, 0, 5, 8);
setAtomData(60, "Nd", "네오디뮴", "Neodymium", 199, 255, 199, 185, 0, 6, 8);
setAtomData(61, "Pm", "프로메튬", "Promethium", 163, 255, 199, 185, 0, 7, 8);
setAtomData(62, "Sm", "사마륨", "Samarium", 143, 255, 199, 185, 0, 8, 8);
setAtomData(63, "Eu", "유로퓸", "Europium", 97, 255, 199, 185, 0, 9, 8);
setAtomData(64, "Gd", "가돌리늄", "Gadolinium", 69, 255, 199, 180, 0, 10, 8);
setAtomData(65, "Tb", "터븀", "Terbium", 48, 255, 199, 175, 0, 11, 8);
setAtomData(66, "Dy", "디스프로슘", "Dysprosium", 31, 255, 199, 175, 0, 12, 8);
setAtomData(67, "Ho", "홀뮴", "Holmium", 0, 255, 156, 175, 0, 13, 8);
setAtomData(68, "Er", "어븀", "Erbium", 0, 230, 117, 175, 0, 14, 8);
setAtomData(69, "Tm", "툴륨", "Thulium", 0, 212, 82, 175, 0, 15, 8);
setAtomData(70, "Yb", "이터븀", "Ytterbium", 0, 191, 56, 175, 0, 16, 8);
setAtomData(71, "Lu", "루테튬", "Lutetium", 0, 171, 36, 175, 0, 17, 8);
// end of Lantan Group

setAtomData(72, "Hf", "하프늄", "Hafnium", 77, 194, 255, 155, 0, 4, 6);
setAtomData(73, "Ta", "탄탈럼", "Tantalum", 77, 166, 255, 145, 0, 5, 6);
setAtomData(74, "W", "텅스텐", "Tungsten", 33, 148, 214, 135, 0, 6, 6);
setAtomData(75, "Re", "레늄", "Rhenium", 38, 125, 171, 135, 0, 7, 6);
setAtomData(76, "Os", "오스뮴", "Osmium", 38, 102, 150, 130, 0, 8, 6);
setAtomData(77, "Ir", "이리듐", "Iridium", 23, 84, 135, 135, 0, 9, 6);
setAtomData(78, "Pt", "백금", "Platinum", 208, 208, 224, 135, 0, 10, 6);
setAtomData(79, "Au", "금", "Gold", 255, 209, 35, 135, 0, 11, 6);
setAtomData(80, "Hg", "수은", "Mercury", 184, 184, 208, 150, 0, 12, 6);
setAtomData(81, "Tl", "탈륨", "Thallium", 166, 84, 77, 190, 0, 13, 6);
setAtomData(82, "Pb", "납", "Lead", 87, 89, 97, 180, 0, 14, 6);
setAtomData(83, "Bi", "비스무트", "Bismuth", 158, 79, 181, 160, 0, 15, 6);
setAtomData(84, "Po", "폴로늄", "Polonium", 171, 92, 0, 190, 0, 16, 6);
setAtomData(85, "At", "아스타틴", "Astatine", 117, 79, 69, 190, 0, 17, 6);
setAtomData(86, "Rn", "라돈", "Radon", 66, 130, 150, 190, 0, 18, 6);
setAtomData(87, "Fr", "프랑슘", "Francium", 66, 0, 102, 190, 0, 1, 7);
setAtomData(88, "Ra", "라듐", "Radium", 0, 125, 0, 215, 0, 2, 7);

// Actin Group - Period/Group Modified for Table.
setAtomData(89, "Ac", "악티늄", "Actinium", 112, 171, 250, 195, 0, 3, 9);
setAtomData(90, "Th", "토륨", "Thorium", 0, 186, 255, 180, 0, 4, 9);
setAtomData(91, "Pa", "프로트악티늄", "Protactinium", 0, 161, 255, 180, 0, 5, 9);
setAtomData(92, "U", "우라늄", "Uranium", 0, 143, 255, 175, 0, 6, 9);
setAtomData(93, "Np", "넵투늄", "Neptunium", 0, 128, 255, 175, 0, 7, 9);
setAtomData(94, "Pu", "플루토늄", "Plutonium", 0, 107, 255, 175, 0, 8, 9);
setAtomData(95, "Am", "아메리슘", "Americium", 84, 92, 242, 175, 0, 9, 9);
setAtomData(96, "Cm", "퀴륨", "Curium", 120, 92, 227, 175, 0, 10, 9);
setAtomData(97, "Bk", "버클륨", "Berkelium", 138, 79, 227, 175, 0, 11, 9);
setAtomData(98, "Cf", "캘리포늄", "Californium", 161, 54, 212, 175, 0, 12, 9);
setAtomData(99, "Es", "아인슈타이늄", "Einsteinium", 179, 31, 212, 175, 0, 13, 9);
setAtomData(100, "Fm", "페르뮴", "Fermium", 179, 31, 186, 175, 0, 14, 9);
setAtomData(101, "Md", "멘델레븀", "Mendelevium", 179, 13, 166, 175, 0, 15, 9);
setAtomData(102, "No", "노벨륨", "Nobelium", 189, 13, 135, 175, 0, 16, 9);
setAtomData(103, "Lr", "로렌슘", "Lawrencium", 199, 0, 102, 175, 0, 17, 9);
// end of Actin Group

setAtomData(104, "Rf", "러더포듐", "Rutherfordium", 204, 0, 89, 175, 0, 4, 7);
setAtomData(105, "Db", "더브늄", "Dubnium", 209, 0, 79, 175, 0, 5, 7);
setAtomData(106, "Sg", "시보귬", "Seaborgium", 217, 0, 69, 175, 0, 6, 7);
setAtomData(107, "Bh", "보륨", "Bohrium", 224, 0, 56, 175, 0, 7, 7);
setAtomData(108, "Hs", "하슘", "Hassium", 230, 0, 46, 175, 0, 8, 7);
setAtomData(109, "Mt", "마이트너륨", "Meitnerium", 235, 0, 38, 175, 0, 9, 7);
setAtomData(110, "Ds", "다름슈타튬", "Darmstadtium", 128, 128, 128, 175, 0, 10, 7);
setAtomData(111, "Rg", "뢴트게늄", "Roentgenium", 128, 128, 128, 175, 0, 11, 7);
setAtomData(112, "Cn", "코페르니슘", "Copernicium", 128, 128, 128, 175, 0, 12, 7);
setAtomData(113, "Nh", "니호늄", "Nihonium", 128, 128, 128, 175, 0, 13, 7);
setAtomData(114, "Fl", "플레로븀", "Flerovium", 128, 128, 128, 175, 0, 14, 7);
setAtomData(115, "Mc", "모스코븀", "Moscovium", 128, 128, 128, 175, 0, 15, 7);
setAtomData(116, "Lv", "리버모륨", "Livermorium", 128, 128, 128, 175, 0, 16, 7);
setAtomData(117, "Ts", "테네신", "Tennessine", 128, 128, 128, 175, 0, 17, 7);
setAtomData(118, "Og", "오가네손", "Oganesson", 128, 128, 128, 175, 0, 18, 7);
setAtomData(199, "?", "미정", "?", 28, 28, 28, 100, 0, 0, 0);
setAtomData(200, "@", "@Anchor", "Anchor", 256, 0, 0, 10, 0, 0, 0);
setAtomData(201, "#", "#Upvector", "Upvector", 0, 0, 255, 10, 0, 0, 0);
setAtomData(211, "+1", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(212, "+2", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(213, "+3", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(214, "+4", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(215, "+5", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(216, "+6", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(217, "+7", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(218, "+8", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(219, "+9", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(221, "-1", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(222, "-2", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(223, "-3", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(224, "-4", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(225, "-5", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(226, "-6", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(227, "-7", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(228, "-8", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
setAtomData(229, "-9", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);

// 0 : 비금속
// 1 : 알카리 금속
// 2 : 알카리 포금속
// 3 : 전이 금속
// 4 : 전이 후 금속
// 5 : 준금속
// 6 : 비활성 기체

setAtomMetal("He", 6);
setAtomMetal("Ne", 6);
setAtomMetal("Ar", 6);
setAtomMetal("Kr", 6);
setAtomMetal("Xe", 6);
setAtomMetal("Rn", 6);
setAtomMetal("B", 5);
setAtomMetal("Si", 5);
setAtomMetal("Ge", 5);
setAtomMetal("As", 5);
setAtomMetal("Sb", 5);
setAtomMetal("Te", 5);
setAtomMetal("At", 5);
setAtomMetal("Li", 1);
setAtomMetal("Na", 1);
setAtomMetal("K", 1);
setAtomMetal("Rb", 1);
setAtomMetal("Cs", 1);
setAtomMetal("Fr", 1);
setAtomMetal("Uue", 1);
setAtomMetal("Be", 2);
setAtomMetal("Mg", 2);
setAtomMetal("Ca", 2);
setAtomMetal("Sr", 2);
setAtomMetal("Ba", 2);
setAtomMetal("Ra", 2);
setAtomMetal("Sc", 3);
setAtomMetal("Ti", 3);
setAtomMetal("V", 3);
setAtomMetal("Cr", 3);
setAtomMetal("Mn", 3);
setAtomMetal("Fe", 3);
setAtomMetal("Co", 3);
setAtomMetal("Ni", 3);
setAtomMetal("Cu", 3);
setAtomMetal("Zn", 3);
setAtomMetal("Y", 3);
setAtomMetal("Zr", 3);
setAtomMetal("Nb", 3);
setAtomMetal("Mo", 3);
setAtomMetal("Tc", 3);
setAtomMetal("Ru", 3);
setAtomMetal("Rh", 3);
setAtomMetal("Pd", 3);
setAtomMetal("Ag", 3);
setAtomMetal("Cd", 3);
setAtomMetal("Rf", 3);
setAtomMetal("Db", 3);
setAtomMetal("Sg", 3);
setAtomMetal("Bh", 3);
setAtomMetal("Hs", 3);
setAtomMetal("Cn", 3);
setAtomMetal("Hf", 3);
setAtomMetal("Ta", 3);
setAtomMetal("W", 3);
setAtomMetal("Re", 3);
setAtomMetal("Os", 3);
setAtomMetal("Ir", 3);
setAtomMetal("Pt", 3);
setAtomMetal("Au", 3);
setAtomMetal("Hg", 3);
setAtomMetal("Al", 4);
setAtomMetal("Ga", 4);
setAtomMetal("In", 4);
setAtomMetal("Sn", 4);
setAtomMetal("Tl", 4);
setAtomMetal("Pb", 4);
setAtomMetal("Bi", 4);
setAtomMetal("Po", 4);
setAtomVSEPR("C", 4, 0, 109.5);
setAtomVSEPR("Ge", 4, 0, 109.5);
setAtomVSEPR("N", 4, 1, 109.5);
setAtomVSEPR("P", 4, 1, 109.5);
setAtomVSEPR("O", 4, 2, 109.5);
setAtomVSEPR("S", 4, 2, 109.5);
setAtomVSEPR("Se", 4, 2, 109.5);
setAtomVSEPR("Te", 4, 2, 109.5);
setAtomVSEPR("Po", 4, 2, 109.5);
setAtomVSEPR("B", 3, 0, 120);
setAtomVSEPR("Al", 3, 0, 120);
setAtomVSEPR("Ga", 3, 0, 120);
setAtomVSEPR("As", 1, 0, 0);
setAtomVSEPR("F", 1, 0, 0);
setAtomVSEPR("Cl", 1, 0, 0);
setAtomVSEPR("Br", 1, 0, 0);
setAtomVSEPR("I", 1, 0, 0);
setAtomVSEPR("At", 1, 0, 0);
setAtomVSEPR("Li", 1, 0, 0);
setAtomVSEPR("Na", 1, 0, 0);
setAtomVSEPR("K", 1, 0, 0);
setAtomVSEPR("Rb", 1, 0, 0);
setAtomVSEPR("Cs", 1, 0, 0);
setAtomVSEPR("Fr", 1, 0, 0);
setAtomVSEPR("Be", 2, 0, 180);
setAtomVSEPR("Mg", 2, 0, 180);
setAtomVSEPR("Ca", 2, 0, 180);
setAtomVSEPR("Sr", 2, 0, 180);
setAtomVSEPR("Ba", 2, 0, 180);
setAtomVSEPR("Ra", 2, 0, 180);
;// CONCATENATED MODULE: ./build/three.module.js
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION='131';const three_module_MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};const three_module_TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};const CullFaceNone=0;const CullFaceBack=1;const CullFaceFront=2;const CullFaceFrontBack=3;const BasicShadowMap=0;const PCFShadowMap=1;const PCFSoftShadowMap=2;const VSMShadowMap=3;const FrontSide=0;const BackSide=1;const DoubleSide=2;const FlatShading=1;const SmoothShading=2;const NoBlending=0;const NormalBlending=1;const AdditiveBlending=2;const SubtractiveBlending=3;const MultiplyBlending=4;const CustomBlending=5;const AddEquation=100;const SubtractEquation=101;const ReverseSubtractEquation=102;const MinEquation=103;const MaxEquation=104;const ZeroFactor=200;const OneFactor=201;const SrcColorFactor=202;const OneMinusSrcColorFactor=203;const SrcAlphaFactor=204;const OneMinusSrcAlphaFactor=205;const DstAlphaFactor=206;const OneMinusDstAlphaFactor=207;const DstColorFactor=208;const OneMinusDstColorFactor=209;const SrcAlphaSaturateFactor=210;const NeverDepth=0;const AlwaysDepth=1;const LessDepth=2;const LessEqualDepth=3;const EqualDepth=4;const GreaterEqualDepth=5;const GreaterDepth=6;const NotEqualDepth=7;const MultiplyOperation=0;const MixOperation=1;const AddOperation=2;const NoToneMapping=0;const LinearToneMapping=1;const ReinhardToneMapping=2;const CineonToneMapping=3;const ACESFilmicToneMapping=4;const CustomToneMapping=5;const UVMapping=300;const CubeReflectionMapping=301;const CubeRefractionMapping=302;const EquirectangularReflectionMapping=303;const EquirectangularRefractionMapping=304;const CubeUVReflectionMapping=306;const CubeUVRefractionMapping=307;const RepeatWrapping=1000;const ClampToEdgeWrapping=1001;const MirroredRepeatWrapping=1002;const NearestFilter=1003;const NearestMipmapNearestFilter=1004;const NearestMipMapNearestFilter=1004;const NearestMipmapLinearFilter=1005;const NearestMipMapLinearFilter=1005;const LinearFilter=1006;const LinearMipmapNearestFilter=1007;const LinearMipMapNearestFilter=1007;const LinearMipmapLinearFilter=1008;const LinearMipMapLinearFilter=1008;const UnsignedByteType=1009;const ByteType=1010;const ShortType=1011;const UnsignedShortType=1012;const IntType=1013;const UnsignedIntType=1014;const FloatType=1015;const HalfFloatType=1016;const UnsignedShort4444Type=1017;const UnsignedShort5551Type=1018;const UnsignedShort565Type=1019;const UnsignedInt248Type=1020;const AlphaFormat=1021;const RGBFormat=1022;const RGBAFormat=1023;const LuminanceFormat=1024;const LuminanceAlphaFormat=1025;const RGBEFormat=RGBAFormat;const DepthFormat=1026;const DepthStencilFormat=1027;const RedFormat=1028;const RedIntegerFormat=1029;const RGFormat=1030;const RGIntegerFormat=1031;const RGBIntegerFormat=1032;const RGBAIntegerFormat=1033;const RGB_S3TC_DXT1_Format=33776;const RGBA_S3TC_DXT1_Format=33777;const RGBA_S3TC_DXT3_Format=33778;const RGBA_S3TC_DXT5_Format=33779;const RGB_PVRTC_4BPPV1_Format=35840;const RGB_PVRTC_2BPPV1_Format=35841;const RGBA_PVRTC_4BPPV1_Format=35842;const RGBA_PVRTC_2BPPV1_Format=35843;const RGB_ETC1_Format=36196;const RGB_ETC2_Format=37492;const RGBA_ETC2_EAC_Format=37496;const RGBA_ASTC_4x4_Format=37808;const RGBA_ASTC_5x4_Format=37809;const RGBA_ASTC_5x5_Format=37810;const RGBA_ASTC_6x5_Format=37811;const RGBA_ASTC_6x6_Format=37812;const RGBA_ASTC_8x5_Format=37813;const RGBA_ASTC_8x6_Format=37814;const RGBA_ASTC_8x8_Format=37815;const RGBA_ASTC_10x5_Format=37816;const RGBA_ASTC_10x6_Format=37817;const RGBA_ASTC_10x8_Format=37818;const RGBA_ASTC_10x10_Format=37819;const RGBA_ASTC_12x10_Format=37820;const RGBA_ASTC_12x12_Format=37821;const RGBA_BPTC_Format=36492;const SRGB8_ALPHA8_ASTC_4x4_Format=37840;const SRGB8_ALPHA8_ASTC_5x4_Format=37841;const SRGB8_ALPHA8_ASTC_5x5_Format=37842;const SRGB8_ALPHA8_ASTC_6x5_Format=37843;const SRGB8_ALPHA8_ASTC_6x6_Format=37844;const SRGB8_ALPHA8_ASTC_8x5_Format=37845;const SRGB8_ALPHA8_ASTC_8x6_Format=37846;const SRGB8_ALPHA8_ASTC_8x8_Format=37847;const SRGB8_ALPHA8_ASTC_10x5_Format=37848;const SRGB8_ALPHA8_ASTC_10x6_Format=37849;const SRGB8_ALPHA8_ASTC_10x8_Format=37850;const SRGB8_ALPHA8_ASTC_10x10_Format=37851;const SRGB8_ALPHA8_ASTC_12x10_Format=37852;const SRGB8_ALPHA8_ASTC_12x12_Format=37853;const LoopOnce=2200;const LoopRepeat=2201;const LoopPingPong=2202;const InterpolateDiscrete=2300;const InterpolateLinear=2301;const InterpolateSmooth=2302;const ZeroCurvatureEnding=2400;const ZeroSlopeEnding=2401;const WrapAroundEnding=2402;const NormalAnimationBlendMode=2500;const AdditiveAnimationBlendMode=2501;const TrianglesDrawMode=0;const TriangleStripDrawMode=1;const TriangleFanDrawMode=2;const LinearEncoding=3000;const sRGBEncoding=3001;const GammaEncoding=3007;const RGBEEncoding=3002;const LogLuvEncoding=3003;const RGBM7Encoding=3004;const RGBM16Encoding=3005;const RGBDEncoding=3006;const BasicDepthPacking=3200;const RGBADepthPacking=3201;const TangentSpaceNormalMap=0;const ObjectSpaceNormalMap=1;const ZeroStencilOp=0;const KeepStencilOp=7680;const ReplaceStencilOp=7681;const IncrementStencilOp=7682;const DecrementStencilOp=7683;const IncrementWrapStencilOp=34055;const DecrementWrapStencilOp=34056;const InvertStencilOp=5386;const NeverStencilFunc=512;const LessStencilFunc=513;const EqualStencilFunc=514;const LessEqualStencilFunc=515;const GreaterStencilFunc=516;const NotEqualStencilFunc=517;const GreaterEqualStencilFunc=518;const AlwaysStencilFunc=519;const StaticDrawUsage=35044;const DynamicDrawUsage=35048;const StreamDrawUsage=35040;const StaticReadUsage=35045;const DynamicReadUsage=35049;const StreamReadUsage=35041;const StaticCopyUsage=35046;const DynamicCopyUsage=35050;const StreamCopyUsage=35042;const GLSL1='100';const GLSL3='300 es';/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */class EventDispatcher{addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};const listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}hasEventListener(type,listener){if(this._listeners===undefined)return false;const listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}removeEventListener(type,listener){if(this._listeners===undefined)return;const listeners=this._listeners;const listenerArray=listeners[type];if(listenerArray!==undefined){const index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}dispatchEvent(event){if(this._listeners===undefined)return;const listeners=this._listeners;const listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}}const _lut=[];for(let i=0;i<256;i++){_lut[i]=(i<16?'0':'')+i.toString(16);}let _seed=1234567;const DEG2RAD=Math.PI/180;const RAD2DEG=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID(){const d0=Math.random()*0xffffffff|0;const d1=Math.random()*0xffffffff|0;const d2=Math.random()*0xffffffff|0;const d3=Math.random()*0xffffffff|0;const uuid=_lut[d0&0xff]+_lut[d0>>8&0xff]+_lut[d0>>16&0xff]+_lut[d0>>24&0xff]+'-'+_lut[d1&0xff]+_lut[d1>>8&0xff]+'-'+_lut[d1>>16&0x0f|0x40]+_lut[d1>>24&0xff]+'-'+_lut[d2&0x3f|0x80]+_lut[d2>>8&0xff]+'-'+_lut[d2>>16&0xff]+_lut[d2>>24&0xff]+_lut[d3&0xff]+_lut[d3>>8&0xff]+_lut[d3>>16&0xff]+_lut[d3>>24&0xff];// .toUpperCase() here flattens concatenated strings to save heap memory space.
return uuid.toUpperCase();}function clamp(value,min,max){return Math.max(min,Math.min(max,value));}// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n,m){return(n%m+m)%m;}// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);}// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp(x,y,value){if(x!==y){return(value-x)/(y-x);}else{return 0;}}// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x,y,t){return(1-t)*x+t*y;}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp(x,y,lambda,dt){return lerp(x,y,1-Math.exp(-lambda*dt));}// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong(x,length=1){return length-Math.abs(euclideanModulo(x,length*2)-length);}// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);}function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);}// Random integer from <low, high> interval
function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));}// Random float from <low, high> interval
function randFloat(low,high){return low+Math.random()*(high-low);}// Random float from <-range/2, range/2> interval
function randFloatSpread(range){return range*(0.5-Math.random());}// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom(s){if(s!==undefined)_seed=s%2147483647;// Park-Miller algorithm
_seed=_seed*16807%2147483647;return(_seed-1)/2147483646;}function degToRad(degrees){return degrees*DEG2RAD;}function radToDeg(radians){return radians*RAD2DEG;}function isPowerOfTwo(value){return(value&value-1)===0&&value!==0;}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}function setQuaternionFromProperEuler(q,a,b,c,order){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
// rotations are applied to the axes in the order specified by 'order'
// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
// angles are in radians
const cos=Math.cos;const sin=Math.sin;const c2=cos(b/2);const s2=sin(b/2);const c13=cos((a+c)/2);const s13=sin((a+c)/2);const c1_3=cos((a-c)/2);const s1_3=sin((a-c)/2);const c3_1=cos((c-a)/2);const s3_1=sin((c-a)/2);switch(order){case'XYX':q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);break;case'YZY':q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);break;case'ZXZ':q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);break;case'XZX':q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);break;case'YXY':q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);break;case'ZYZ':q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);break;default:console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: '+order);}}var MathUtils=/*#__PURE__*/Object.freeze({__proto__:null,DEG2RAD:DEG2RAD,RAD2DEG:RAD2DEG,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad,radToDeg:radToDeg,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler});class Vector2{constructor(x=0,y=0){this.x=x;this.y=y;}get width(){return this.x;}set width(value){this.x=value;}get height(){return this.y;}set height(value){this.y=value;}set(x,y){this.x=x;this.y=y;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y);}copy(v){this.x=v.x;this.y=v.y;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;}addScalar(s){this.x+=s;this.y+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;}subScalar(s){this.x-=s;this.y-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}multiply(v){this.x*=v.x;this.y*=v.y;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}divide(v){this.x/=v.x;this.y/=v.y;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}applyMatrix3(m){const x=this.x,y=this.y;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;}negate(){this.x=-this.x;this.y=-this.y;return this;}dot(v){return this.x*v.x+this.y*v.y;}cross(v){return this.x*v.y-this.y*v.x;}lengthSq(){return this.x*this.x+this.y*this.y;}length(){return Math.sqrt(this.x*this.x+this.y*this.y);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}normalize(){return this.divideScalar(this.length()||1);}angle(){// computes the angle in radians with respect to the positive x-axis
const angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}rotateAround(center,angle){const c=Math.cos(angle),s=Math.sin(angle);const x=this.x-center.x;const y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}random(){this.x=Math.random();this.y=Math.random();return this;}}Vector2.prototype.isVector2=true;class Matrix3{constructor(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}setFromMatrix4(m){const me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}multiply(m){return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[3],a13=ae[6];const a21=ae[1],a22=ae[4],a23=ae[7];const a31=ae[2],a32=ae[5],a33=ae[8];const b11=be[0],b12=be[3],b13=be[6];const b21=be[1],b22=be[4],b23=be[7];const b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}multiplyScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}determinant(){const te=this.elements;const a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}transpose(){let tmp;const m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}transposeIntoArray(r){const m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c=Math.cos(rotation);const s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}scale(sx,sy){const te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;}rotate(theta){const c=Math.cos(theta);const s=Math.sin(theta);const te=this.elements;const a11=te[0],a12=te[3],a13=te[6];const a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;}translate(tx,ty){const te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;}equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;}fromArray(array,offset=0){for(let i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;}toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}clone(){return new this.constructor().fromArray(this.elements);}}Matrix3.prototype.isMatrix3=true;let _canvas;class ImageUtils{static getDataURL(image){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement=='undefined'){return image.src;}let canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else{if(_canvas===undefined)_canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');_canvas.width=image.width;_canvas.height=image.height;const context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else{context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',image);return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}}let textureId=0;class Texture extends EventDispatcher{constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=ClampToEdgeWrapping,wrapT=ClampToEdgeWrapping,magFilter=LinearFilter,minFilter=LinearMipmapLinearFilter,format=RGBAFormat,type=UnsignedByteType,anisotropy=1,encoding=LinearEncoding){super();Object.defineProperty(this,'id',{value:textureId++});this.uuid=generateUUID();this.name='';this.image=image;this.mipmaps=[];this.mapping=mapping;this.wrapS=wrapS;this.wrapT=wrapT;this.magFilter=magFilter;this.minFilter=minFilter;this.anisotropy=anisotropy;this.format=format;this.internalFormat=null;this.type=type;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding;this.version=0;this.onUpdate=null;this.isRenderTargetTexture=false;}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;}toJSON(meta){const isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}const output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==undefined){// TODO: Move to THREE.Image
const image=this.image;if(image.uuid===undefined){image.uuid=generateUUID();// UGH
}if(!isRootObject&&meta.images[image.uuid]===undefined){let url;if(Array.isArray(image)){// process array of images e.g. CubeTexture
url=[];for(let i=0,l=image.length;i<l;i++){// check cube texture with data textures
if(image[i].isDataTexture){url.push(serializeImage(image[i].image));}else{url.push(serializeImage(image[i]));}}}else{// process single image
url=serializeImage(image);}meta.images[image.uuid]={uuid:image.uuid,url:url};}output.image=image.uuid;}if(!isRootObject){meta.textures[this.uuid]=output;}return output;}dispose(){this.dispatchEvent({type:'dispose'});}transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}set needsUpdate(value){if(value===true)this.version++;}}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype.isTexture=true;function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
return ImageUtils.getDataURL(image);}else{if(image.data){// images of DataTexture
return{data:Array.prototype.slice.call(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else{console.warn('THREE.Texture: Unable to serialize Texture.');return{};}}}class Vector4{constructor(x=0,y=0,z=0,w=1){this.x=x;this.y=y;this.z=z;this.w=w;}get width(){return this.z;}set width(value){this.z=value;}get height(){return this.w;}set height(value){this.w=value;}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setW(w){this.w=w;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z,this.w);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}applyMatrix4(m){const x=this.x,y=this.y,z=this.z,w=this.w;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(q.w);const s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let angle,x,y,z;// variables for result
const epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
this.set(1,0,0,0);return this;// zero angle, arbitrary axis
}// otherwise this singularity is angle = 180
angle=Math.PI;const xx=(m11+1)/2;const yy=(m22+1)/2;const zz=(m33+1)/2;const xy=(m12+m21)/4;const xz=(m13+m31)/4;const yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
let s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}}Vector4.prototype.isVector4=true;/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/class WebGLRenderTarget extends EventDispatcher{constructor(width,height,options={}){super();this.width=width;this.height=height;this.depth=1;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);this.texture=new Texture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=true;this.texture.image={width:width,height:height,depth:1};this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:false;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}setTexture(texture){texture.image={width:this.width,height:this.height,depth:this.depth};this.texture=texture;}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;this.texture.image.width=width;this.texture.image.height=height;this.texture.image.depth=depth;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}clone(){return new this.constructor().copy(this);}copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.texture.image={...this.texture.image};// See #20328.
this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;}dispose(){this.dispatchEvent({type:'dispose'});}}WebGLRenderTarget.prototype.isWebGLRenderTarget=true;class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(width,height,count){super(width,height);const texture=this.texture;this.texture=[];for(let i=0;i<count;i++){this.texture[i]=texture.clone();}}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;for(let i=0,il=this.texture.length;i<il;i++){this.texture[i].image.width=width;this.texture[i].image.height=height;this.texture[i].image.depth=depth;}this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);return this;}copy(source){this.dispose();this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.set(0,0,this.width,this.height);this.scissor.set(0,0,this.width,this.height);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;this.texture.length=0;for(let i=0,il=source.texture.length;i<il;i++){this.texture[i]=source.texture[i].clone();}return this;}}WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets=true;class WebGLMultisampleRenderTarget extends WebGLRenderTarget{constructor(width,height,options){super(width,height,options);this.samples=4;}copy(source){super.copy.call(this,source);this.samples=source.samples;return this;}}WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget=true;class Quaternion{constructor(x=0,y=0,z=0,w=1){this._x=x;this._y=y;this._z=z;this._w=w;}static slerp(qa,qb,qm,t){console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');return qm.slerpQuaternions(qa,qb,t);}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];const x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t===0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t===1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){let s=1-t;const cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>Number.EPSILON){const sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}const tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
if(s===1-t){const f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0];const y0=src0[srcOffset0+1];const z0=src0[srcOffset0+2];const w0=src0[srcOffset0+3];const x1=src1[srcOffset1];const y1=src1[srcOffset1+1];const z1=src1[srcOffset1+2];const w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get w(){return this._w;}set w(value){this._w=value;this._onChangeCallback();}set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._w);}copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}setFromEuler(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}const x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
const cos=Math.cos;const sin=Math.sin;const c1=cos(x/2);const c2=cos(y/2);const c3=cos(z/2);const s1=sin(x/2);const s2=sin(y/2);const s3=sin(z/2);switch(order){case'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update!==false)this._onChangeCallback();return this;}setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
const halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){const s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){const s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{const s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this._onChangeCallback();return this;}setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
let r=vFrom.dot(vTo)+1;if(r<Number.EPSILON){// vFrom and vTo point in opposite directions
r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else{this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else{// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)));}rotateTowards(q,step){const angle=this.angleTo(q);if(angle===0)return this;const t=Math.min(1,step/angle);this.slerp(q,t);return this;}identity(){return this.set(0,0,0,1);}invert(){// quaternion is assumed to have unit length
return this.conjugate();}conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}normalize(){let l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);}premultiply(q){return this.multiplyQuaternions(q,this);}multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
const qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;const qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);const x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
let cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}const sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){const s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();this._onChangeCallback();return this;}const sinHalfTheta=Math.sqrt(sqrSinHalfTheta);const halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);const ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;}slerpQuaternions(qa,qb,t){this.copy(qa).slerp(qb,t);}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}fromArray(array,offset=0){this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this;}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}}Quaternion.prototype.isQuaternion=true;class three_module_Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z;}set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
this.x=x;this.y=y;this.z=z;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}applyMatrix3(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}applyMatrix4(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}applyQuaternion(q){const x=this.x,y=this.y,z=this.z;const qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
const ix=qw*x+qy*z-qz*y;const iy=qw*y+qz*x-qx*z;const iz=qw*z+qx*y-qy*x;const iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}transformDirection(m){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
const x=this.x,y=this.y,z=this.z;const e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this;}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}return this.crossVectors(this,v);}crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z;const bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}projectOnVector(v){const denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);const scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}reflect(normal){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v)/denominator;// clamp, to handle numerical problems
return Math.acos(clamp(theta,-1,1));}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}setFromMatrixPosition(m){const e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}setFromMatrixScale(m){const sx=this.setFromMatrixColumn(m,0).length();const sy=this.setFromMatrixColumn(m,1).length();const sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}}three_module_Vector3.prototype.isVector3=true;const _vector$c=/*@__PURE__*/new three_module_Vector3();const _quaternion$4=/*@__PURE__*/new Quaternion();class Box3{constructor(min=new three_module_Vector3(+Infinity,+Infinity,+Infinity),max=new three_module_Vector3(-Infinity,-Infinity,-Infinity)){this.min=min;this.max=max;}set(min,max){this.min.copy(min);this.max.copy(max);return this;}setFromArray(array){let minX=+Infinity;let minY=+Infinity;let minZ=+Infinity;let maxX=-Infinity;let maxY=-Infinity;let maxZ=-Infinity;for(let i=0,l=array.length;i<l;i+=3){const x=array[i];const y=array[i+1];const z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}setFromBufferAttribute(attribute){let minX=+Infinity;let minY=+Infinity;let minZ=+Infinity;let maxX=-Infinity;let maxY=-Infinity;let maxZ=-Infinity;for(let i=0,l=attribute.count;i<l;i++){const x=attribute.getX(i);const y=attribute.getY(i);const z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;}setFromCenterAndSize(center,size){const halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}setFromObject(object){this.makeEmpty();return this.expandByObject(object);}clone(){return new this.constructor().copy(this);}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}expandByPoint(point){this.min.min(point);this.max.max(point);return this;}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}expandByObject(object){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
object.updateWorldMatrix(false,false);const geometry=object.geometry;if(geometry!==undefined){if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$3.copy(geometry.boundingBox);_box$3.applyMatrix4(object.matrixWorld);this.union(_box$3);}const children=object.children;for(let i=0,l=children.length;i<l;i++){this.expandByObject(children[i]);}return this;}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}getParameter(point,target){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}intersectsBox(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;}intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
let min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
this.getCenter(_center);_extents.subVectors(this.max,_center);// translate triangle to aabb origin
_v0$2.subVectors(triangle.a,_center);_v1$7.subVectors(triangle.b,_center);_v2$3.subVectors(triangle.c,_center);// compute edge vectors for triangle
_f0.subVectors(_v1$7,_v0$2);_f1.subVectors(_v2$3,_v1$7);_f2.subVectors(_v0$2,_v2$3);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
let axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// test 3 face normals from the aabb
axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
_triangleNormal.crossVectors(_f0,_f1);axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents);}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}distanceToPoint(point){const clampedPoint=_vector$b.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}getBoundingSphere(target){this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;return target;}intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();return this;}union(box){this.min.min(box.min);this.max.max(box.max);return this;}applyMatrix4(matrix){// transform of empty box is an empty box.
if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
this.setFromPoints(_points);return this;}translate(offset){this.min.add(offset);this.max.add(offset);return this;}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}Box3.prototype.isBox3=true;const _points=[/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3(),/*@__PURE__*/new three_module_Vector3()];const _vector$b=/*@__PURE__*/new three_module_Vector3();const _box$3=/*@__PURE__*/new Box3();// triangle centered vertices
const _v0$2=/*@__PURE__*/new three_module_Vector3();const _v1$7=/*@__PURE__*/new three_module_Vector3();const _v2$3=/*@__PURE__*/new three_module_Vector3();// triangle edge vectors
const _f0=/*@__PURE__*/new three_module_Vector3();const _f1=/*@__PURE__*/new three_module_Vector3();const _f2=/*@__PURE__*/new three_module_Vector3();const _center=/*@__PURE__*/new three_module_Vector3();const _extents=/*@__PURE__*/new three_module_Vector3();const _triangleNormal=/*@__PURE__*/new three_module_Vector3();const _testAxis=/*@__PURE__*/new three_module_Vector3();function satForAxes(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);// project the aabb onto the seperating axis
const r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z);// project all 3 vertices of the triangle onto the seperating axis
const p0=v0.dot(_testAxis);const p1=v1.dot(_testAxis);const p2=v2.dot(_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
// the axis is seperating and we can exit
return false;}}return true;}const _box$2=/*@__PURE__*/new Box3();const _v1$6=/*@__PURE__*/new three_module_Vector3();const _toFarthestPoint=/*@__PURE__*/new three_module_Vector3();const _toPoint=/*@__PURE__*/new three_module_Vector3();class Sphere{constructor(center=new three_module_Vector3(),radius=-1){this.center=center;this.radius=radius;}set(center,radius){this.center.copy(center);this.radius=radius;return this;}setFromPoints(points,optionalCenter){const center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{_box$2.setFromPoints(points).getCenter(center);}let maxRadiusSq=0;for(let i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}isEmpty(){return this.radius<0;}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}intersectsBox(box){return box.intersectsSphere(this);}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}translate(offset){this.center.add(offset);return this;}expandByPoint(point){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
_toPoint.subVectors(point,this.center);const lengthSq=_toPoint.lengthSq();if(lengthSq>this.radius*this.radius){const length=Math.sqrt(lengthSq);const missingRadiusHalf=(length-this.radius)*0.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
// and the other half to position. This gives a tighter enclosure, instead of if
// the whole missing distance were just added to radius.
this.center.add(_toPoint.multiplyScalar(missingRadiusHalf/length));this.radius+=missingRadiusHalf;}return this;}union(sphere){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
// To enclose another sphere into this sphere, we only need to enclose two points:
// 1) Enclose the farthest point on the other sphere into this sphere.
// 2) Enclose the opposite point of the farthest point into this sphere.
_toFarthestPoint.subVectors(sphere.center,this.center).normalize().multiplyScalar(sphere.radius);this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));return this;}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}clone(){return new this.constructor().copy(this);}}const _vector$a=/*@__PURE__*/new three_module_Vector3();const _segCenter=/*@__PURE__*/new three_module_Vector3();const _segDir=/*@__PURE__*/new three_module_Vector3();const _diff=/*@__PURE__*/new three_module_Vector3();const _edge1=/*@__PURE__*/new three_module_Vector3();const _edge2=/*@__PURE__*/new three_module_Vector3();const _normal$1=/*@__PURE__*/new three_module_Vector3();class Ray{constructor(origin=new three_module_Vector3(),direction=new three_module_Vector3(0,0,-1)){this.origin=origin;this.direction=direction;}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin);}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}recast(t){this.origin.copy(this.at(t,_vector$a));return this;}closestPointToPoint(point,target){target.subVectors(point,this.origin);const directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}distanceSqToPoint(point){const directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$a.distanceToSquared(point);}distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
_segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);const segExtent=v0.distanceTo(v1)*0.5;const a01=-this.direction.dot(_segDir);const b0=_diff.dot(this.direction);const b1=-_diff.dot(_segDir);const c=_diff.lengthSq();const det=Math.abs(1-a01*a01);let s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
// Minimum at interior points of ray and segment.
const invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);}return sqrDist;}intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);const tca=_vector$a.dot(this.direction);const d2=_vector$a.dot(_vector$a)-tca*tca;const radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
const t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
const t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,target);}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
return null;}const t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
return t>=0?t:null;}intersectPlane(plane,target){const t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}intersectsPlane(plane){// check if the ray lies on the plane first
const distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}const denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
return false;}intersectBox(box,target){let tmin,tmax,tymin,tymax,tzmin,tzmax;const invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;const origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN
if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
let DdN=this.direction.dot(_normal$1);let sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}_diff.subVectors(this.origin,a);const DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
if(DdQxE2<0){return null;}const DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
const QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
if(QdN<0){return null;}// Ray intersects triangle.
return this.at(QdN/DdN,target);}applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}clone(){return new this.constructor().copy(this);}}class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}clone(){return new Matrix4().fromArray(this.elements);}copy(m){const te=this.elements;const me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}copyPosition(m){const te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}setFromMatrix3(m){const me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}extractRotation(m){// this method does not support reflection matrices
const te=this.elements;const me=m.elements;const scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();const scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();const scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}const te=this.elements;const x=euler.x,y=euler.y,z=euler.z;const a=Math.cos(x),b=Math.sin(x);const c=Math.cos(y),d=Math.sin(y);const e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// bottom row
te[3]=0;te[7]=0;te[11]=0;// last column
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromQuaternion(q){return this.compose(_zero,q,_one);}lookAt(eye,target,up){const te=this.elements;_z.subVectors(eye,target);if(_z.lengthSq()===0){// eye and target are in the same position
_z.z=1;}_z.normalize();_x.crossVectors(up,_z);if(_x.lengthSq()===0){// up and z are parallel
if(Math.abs(up.z)===1){_z.x+=0.0001;}else{_z.z+=0.0001;}_z.normalize();_x.crossVectors(up,_z);}_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this;}multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const te=this.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}multiplyScalar(s){const te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}determinant(){const te=this.elements;const n11=te[0],n12=te[4],n13=te[8],n14=te[12];const n21=te[1],n22=te[5],n23=te[9],n24=te[13];const n31=te[2],n32=te[6],n33=te[10],n34=te[14];const n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}transpose(){const te=this.elements;let tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}setPosition(x,y,z){const te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else{te[12]=x;te[13]=y;te[14]=z;}return this;}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}scale(v){const te=this.elements;const x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}getMaxScaleOnAxis(){const te=this.elements;const scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];const scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];const scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;}makeRotationX(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}makeRotationY(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}makeRotationZ(theta){const c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
const c=Math.cos(angle);const s=Math.sin(angle);const t=1-c;const x=axis.x,y=axis.y,z=axis.z;const tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}compose(position,quaternion,scale){const te=this.elements;const x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;const sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}decompose(position,quaternion,scale){const te=this.elements;let sx=_v1$5.set(te[0],te[1],te[2]).length();const sy=_v1$5.set(te[4],te[5],te[6]).length();const sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
const det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
_m1$2.copy(this);const invSX=1/sx;const invSY=1/sy;const invSZ=1/sz;_m1$2.elements[0]*=invSX;_m1$2.elements[1]*=invSX;_m1$2.elements[2]*=invSX;_m1$2.elements[4]*=invSY;_m1$2.elements[5]*=invSY;_m1$2.elements[6]*=invSY;_m1$2.elements[8]*=invSZ;_m1$2.elements[9]*=invSZ;_m1$2.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2);scale.x=sx;scale.y=sy;scale.z=sz;return this;}makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}const te=this.elements;const x=2*near/(right-left);const y=2*near/(top-bottom);const a=(right+left)/(right-left);const b=(top+bottom)/(top-bottom);const c=-(far+near)/(far-near);const d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}makeOrthographic(left,right,top,bottom,near,far){const te=this.elements;const w=1.0/(right-left);const h=1.0/(top-bottom);const p=1.0/(far-near);const x=(right+left)*w;const y=(top+bottom)*h;const z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}equals(matrix){const te=this.elements;const me=matrix.elements;for(let i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;}fromArray(array,offset=0){for(let i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;}toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}}Matrix4.prototype.isMatrix4=true;const _v1$5=/*@__PURE__*/new three_module_Vector3();const _m1$2=/*@__PURE__*/new Matrix4();const _zero=/*@__PURE__*/new three_module_Vector3(0,0,0);const _one=/*@__PURE__*/new three_module_Vector3(1,1,1);const _x=/*@__PURE__*/new three_module_Vector3();const _y=/*@__PURE__*/new three_module_Vector3();const _z=/*@__PURE__*/new three_module_Vector3();const _matrix$1=/*@__PURE__*/new Matrix4();const _quaternion$3=/*@__PURE__*/new Quaternion();class Euler{constructor(x=0,y=0,z=0,order=Euler.DefaultOrder){this._x=x;this._y=y;this._z=z;this._order=order;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get order(){return this._order;}set order(value){this._order=value;this._onChangeCallback();}set(x,y,z,order=this._order){this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._order);}copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}setFromRotationMatrix(m,order=this._order,update=true){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
const te=m.elements;const m11=te[0],m12=te[4],m13=te[8];const m21=te[1],m22=te[5],m23=te[9];const m31=te[2],m32=te[6],m33=te[10];switch(order){case'XYZ':this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}break;case'YXZ':this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}break;case'ZXY':this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}break;case'ZYX':this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}break;case'YZX':this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}break;case'XZY':this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}break;default:console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}setFromQuaternion(q,order,update){_matrix$1.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$1,order,update);}setFromVector3(v,order=this._order){return this.set(v.x,v.y,v.z,order);}reorder(newOrder){// WARNING: this discards revolution information -bhouston
_quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new three_module_Vector3(this._x,this._y,this._z);}}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}}Euler.prototype.isEuler=true;Euler.DefaultOrder='XYZ';Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];class Layers{constructor(){this.mask=1|0;}set(channel){this.mask=1<<channel|0;}enable(channel){this.mask|=1<<channel|0;}enableAll(){this.mask=0xffffffff|0;}toggle(channel){this.mask^=1<<channel|0;}disable(channel){this.mask&=~(1<<channel|0);}disableAll(){this.mask=0;}test(layers){return(this.mask&layers.mask)!==0;}}let _object3DId=0;const _v1$4=/*@__PURE__*/new three_module_Vector3();const _q1=/*@__PURE__*/new Quaternion();const _m1$1=/*@__PURE__*/new Matrix4();const _target=/*@__PURE__*/new three_module_Vector3();const _position$3=/*@__PURE__*/new three_module_Vector3();const _scale$2=/*@__PURE__*/new three_module_Vector3();const _quaternion$2=/*@__PURE__*/new Quaternion();const _xAxis=/*@__PURE__*/new three_module_Vector3(1,0,0);const _yAxis=/*@__PURE__*/new three_module_Vector3(0,1,0);const _zAxis=/*@__PURE__*/new three_module_Vector3(0,0,1);const _addedEvent={type:'added'};const _removedEvent={type:'removed'};class Object3D extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:_object3DId++});this.uuid=generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();const position=new three_module_Vector3();const rotation=new Euler();const quaternion=new Quaternion();const scale=new three_module_Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(this,{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.animations=[];this.userData={};}onBeforeRender(){}onAfterRender(){}applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}applyQuaternion(q){this.quaternion.premultiply(q);return this;}setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
this.quaternion.setFromAxisAngle(axis,angle);}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(m);}setRotationFromQuaternion(q){// assumes q is normalized
this.quaternion.copy(q);}rotateOnAxis(axis,angle){// rotate object on axis in object space
// axis is assumed to be normalized
_q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this;}rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
_q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this;}rotateX(angle){return this.rotateOnAxis(_xAxis,angle);}rotateY(angle){return this.rotateOnAxis(_yAxis,angle);}rotateZ(angle){return this.rotateOnAxis(_zAxis,angle);}translateOnAxis(axis,distance){// translate object by distance along axis in object space
// axis is assumed to be normalized
_v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}translateX(distance){return this.translateOnAxis(_xAxis,distance);}translateY(distance){return this.translateOnAxis(_yAxis,distance);}translateZ(distance){return this.translateOnAxis(_zAxis,distance);}localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);}worldToLocal(vector){return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());}lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
if(x.isVector3){_target.copy(x);}else{_target.set(x,y,z);}const parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1.lookAt(_position$3,_target,this.up);}else{_m1$1.lookAt(_target,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1);if(parent){_m1$1.extractRotation(parent.matrixWorld);_q1.setFromRotationMatrix(_m1$1);this.quaternion.premultiply(_q1.invert());}}add(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent);}else{console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}remove(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}const index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent);}return this;}removeFromParent(){const parent=this.parent;if(parent!==null){parent.remove(this);}return this;}clear(){for(let i=0;i<this.children.length;i++){const object=this.children[i];object.parent=null;object.dispatchEvent(_removedEvent);}this.children.length=0;return this;}attach(object){// adds object as a child of this, while maintaining the object's world transform
this.updateWorldMatrix(true,false);_m1$1.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1);this.add(object);object.updateWorldMatrix(false,true);return this;}getObjectById(id){return this.getObjectByProperty('id',id);}getObjectByName(name){return this.getObjectByProperty('name',name);}getObjectByProperty(name,value){if(this[name]===value)return this;for(let i=0,l=this.children.length;i<l;i++){const child=this.children[i];const object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2,target);return target;}getWorldDirection(target){this.updateWorldMatrix(true,false);const e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}raycast(){}traverse(callback){callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverse(callback);}}traverseVisible(callback){if(this.visible===false)return;callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}}traverseAncestors(callback){const parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}}updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}// update children
if(updateChildren===true){const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].updateWorldMatrix(false,true);}}}toJSON(meta){// meta is a string when called from JSON.stringify
const isRootObject=meta===undefined||typeof meta==='string';const output={};// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){// initialize meta obj
meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
const object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}//
function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);const parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){const shapes=parameters.shapes;if(Array.isArray(shapes)){for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];serialize(meta.shapes,shape);}}else{serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){const uuids=[];for(let i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
if(this.children.length>0){object.children=[];for(let i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}//
if(this.animations.length>0){object.animations=[];for(let i=0;i<this.animations.length;i++){const animation=this.animations[i];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){const geometries=extractFromCache(meta.geometries);const materials=extractFromCache(meta.materials);const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);const shapes=extractFromCache(meta.shapes);const skeletons=extractFromCache(meta.skeletons);const animations=extractFromCache(meta.animations);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(shapes.length>0)output.shapes=shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;}output.object=object;return output;// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}}clone(recursive){return new this.constructor().copy(this,recursive);}copy(source,recursive=true){this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(let i=0;i<source.children.length;i++){const child=source.children[i];this.add(child.clone());}}return this;}}Object3D.DefaultUp=new three_module_Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype.isObject3D=true;const _v0$1=/*@__PURE__*/new three_module_Vector3();const _v1$3=/*@__PURE__*/new three_module_Vector3();const _v2$2=/*@__PURE__*/new three_module_Vector3();const _v3$1=/*@__PURE__*/new three_module_Vector3();const _vab=/*@__PURE__*/new three_module_Vector3();const _vac=/*@__PURE__*/new three_module_Vector3();const _vbc=/*@__PURE__*/new three_module_Vector3();const _vap=/*@__PURE__*/new three_module_Vector3();const _vbp=/*@__PURE__*/new three_module_Vector3();const _vcp=/*@__PURE__*/new three_module_Vector3();class Triangle{constructor(a=new three_module_Vector3(),b=new three_module_Vector3(),c=new three_module_Vector3()){this.a=a;this.b=b;this.c=c;}static getNormal(a,b,c,target){target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);const targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
static getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$2.subVectors(point,a);const dot00=_v0$1.dot(_v0$1);const dot01=_v0$1.dot(_v1$3);const dot02=_v0$1.dot(_v2$2);const dot11=_v1$3.dot(_v1$3);const dot12=_v1$3.dot(_v2$2);const denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
if(denom===0){// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return target.set(-2,-1,-1);}const invDenom=1/denom;const u=(dot11*dot02-dot01*dot12)*invDenom;const v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
return target.set(1-u-v,v,u);}static containsPoint(point,a,b,c){this.getBarycoord(point,a,b,c,_v3$1);return _v3$1.x>=0&&_v3$1.y>=0&&_v3$1.x+_v3$1.y<=1;}static getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3$1);target.set(0,0);target.addScaledVector(uv1,_v3$1.x);target.addScaledVector(uv2,_v3$1.y);target.addScaledVector(uv3,_v3$1.z);return target;}static isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);// strictly front facing
return _v0$1.cross(_v1$3).dot(direction)<0?true:false;}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}clone(){return new this.constructor().copy(this);}copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}getArea(){_v0$1.subVectors(this.c,this.b);_v1$3.subVectors(this.a,this.b);return _v0$1.cross(_v1$3).length()*0.5;}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}intersectsBox(box){return box.intersectsTriangle(this);}closestPointToPoint(p,target){const a=this.a,b=this.b,c=this.c;let v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.
_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);const d1=_vab.dot(_vap);const d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
return target.copy(a);}_vbp.subVectors(p,b);const d3=_vab.dot(_vbp);const d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
return target.copy(b);}const vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);const d5=_vab.dot(_vcp);const d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
return target.copy(c);}const vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
return target.copy(a).addScaledVector(_vac,w);}const va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
}// face region
const denom=1/(va+vb+vc);// u = va * denom
v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}let materialId=0;class Material extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:materialId++});this.uuid=generateUUID();this.name='';this.type='Material';this.fog=true;this.blending=NormalBlending;this.side=FrontSide;this.vertexColors=false;this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.stencilWriteMask=0xff;this.stencilFunc=AlwaysStencilFunc;this.stencilRef=0;this.stencilFuncMask=0xff;this.stencilFail=KeepStencilOp;this.stencilZFail=KeepStencilOp;this.stencilZPass=KeepStencilOp;this.stencilWrite=false;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.alphaToCoverage=false;this.premultipliedAlpha=false;this.visible=true;this.toneMapped=true;this.userData={};this.version=0;}onBuild(/* shaderobject, renderer */){}onBeforeCompile(/* shaderobject, renderer */){}customProgramCacheKey(){return this.onBeforeCompile.toString();}setValues(values){if(values===undefined)return;for(const key in values){const newValue=values[key];if(newValue===undefined){console.warn('THREE.Material: \''+key+'\' parameter is undefined.');continue;}// for backward compatability if shading is set in the constructor
if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}const currentValue=this[key];if(currentValue===undefined){console.warn('THREE.'+this.type+': \''+key+'\' is not a property of this material.');continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else{this[key]=newValue;}}}toJSON(meta){const isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}const data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen&&this.sheen.isColor)data.sheen=this.sheen.getHex();if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularTint&&this.specularTint.isColor)data.specularTint=this.specularTint.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularTintMap&&this.specularTintMap.isTexture)data.specularTintMap=this.specularTintMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined)data.attenuationDistance=this.attenuationDistance;if(this.attenuationTint!==undefined)data.attenuationTint=this.attenuationTint.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;data.colorWrite=this.colorWrite;data.stencilWrite=this.stencilWrite;data.stencilWriteMask=this.stencilWriteMask;data.stencilFunc=this.stencilFunc;data.stencilRef=this.stencilRef;data.stencilFuncMask=this.stencilFuncMask;data.stencilFail=this.stencilFail;data.stencilZFail=this.stencilZFail;data.stencilZPass=this.stencilZPass;// rotation (SpriteMaterial)
if(this.rotation&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaToCoverage===true)data.alphaToCoverage=this.alphaToCoverage;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){const textures=extractFromCache(meta.textures);const images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.fog=source.fog;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(srcPlanes!==null){const n=srcPlanes.length;dstPlanes=new Array(n);for(let i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}dispose(){this.dispatchEvent({type:'dispose'});}set needsUpdate(value){if(value===true)this.version++;}}Material.prototype.isMaterial=true;const _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};const _hslA={h:0,s:0,l:0};const _hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}class Color{constructor(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
return this.set(r);}return this.setRGB(r,g,b);}set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;}setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;}setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;}setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
h=euclideanModulo(h,1);s=clamp(s,0,1);l=clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{const p=l<=0.5?l*(1+s):l+s-l*s;const q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;}setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}let m;if(m=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)){// rgb / hsl
let color;const name=m[1];const components=m[2];switch(name){case'rgb':case'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[4]);return this;}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[4]);return this;}break;case'hsl':case'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
const h=parseFloat(color[1])/360;const s=parseInt(color[2],10)/100;const l=parseInt(color[3],10)/100;handleAlpha(color[4]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
const hex=m[1];const size=hex.length;if(size===3){// #ff0
this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){return this.setColorName(style);}return this;}setColorName(style){// color keywords
const hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
this.setHex(hex);}else{// unknown color
console.warn('THREE.Color: Unknown color '+style);}return this;}clone(){return new this.constructor(this.r,this.g,this.b);}copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}copyGammaToLinear(color,gammaFactor=2.0){this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;}copyLinearToGamma(color,gammaFactor=2.0){const safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;}convertGammaToLinear(gammaFactor){this.copyGammaToLinear(this,gammaFactor);return this;}convertLinearToGamma(gammaFactor){this.copyLinearToGamma(this,gammaFactor);return this;}copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;}getHexString(){return('000000'+this.getHex().toString(16)).slice(-6);}getHSL(target){// h,s,l ranges are in 0.0 - 1.0
const r=this.r,g=this.g,b=this.b;const max=Math.max(r,g,b);const min=Math.min(r,g,b);let hue,saturation;const lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{const delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}getStyle(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';}offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this;}add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);const h=lerp(_hslA.h,_hslB.h,alpha);const s=lerp(_hslA.s,_hslB.s,alpha);const l=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}fromArray(array,offset=0){this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}toArray(array=[],offset=0){array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);if(attribute.normalized===true){// assuming Uint8Array
this.r/=255;this.g/=255;this.b/=255;}return this;}toJSON(){return this.getHex();}}Color.NAMES=_colorKeywords;Color.prototype.isColor=true;Color.prototype.r=1;Color.prototype.g=1;Color.prototype.b=1;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 * }
 */class MeshBasicMaterial extends Material{constructor(parameters){super();this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshBasicMaterial.prototype.isMeshBasicMaterial=true;const _vector$9=/*@__PURE__*/new three_module_Vector3();const _vector2$1=/*@__PURE__*/new Vector2();class BufferAttribute{constructor(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}onUploadCallback(){}set needsUpdate(value){if(value===true)this.version++;}setUsage(value){this.usage=value;return this;}copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this;}copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(let i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;}copyArray(array){this.array.set(array);return this;}copyColorsArray(colors){const array=this.array;let offset=0;for(let i=0,l=colors.length;i<l;i++){let color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;}copyVector2sArray(vectors){const array=this.array;let offset=0;for(let i=0,l=vectors.length;i<l;i++){let vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;}copyVector3sArray(vectors){const array=this.array;let offset=0;for(let i=0,l=vectors.length;i<l;i++){let vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new three_module_Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;}copyVector4sArray(vectors){const array=this.array;let offset=0;for(let i=0,l=vectors.length;i<l;i++){let vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;}applyMatrix3(m){if(this.itemSize===2){for(let i=0,l=this.count;i<l;i++){_vector2$1.fromBufferAttribute(this,i);_vector2$1.applyMatrix3(m);this.setXY(i,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(let i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix3(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}applyMatrix4(m){for(let i=0,l=this.count;i<l;i++){_vector$9.x=this.getX(i);_vector$9.y=this.getY(i);_vector$9.z=this.getZ(i);_vector$9.applyMatrix4(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++){_vector$9.x=this.getX(i);_vector$9.y=this.getY(i);_vector$9.z=this.getZ(i);_vector$9.applyNormalMatrix(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}transformDirection(m){for(let i=0,l=this.count;i<l;i++){_vector$9.x=this.getX(i);_vector$9.y=this.getY(i);_vector$9.z=this.getZ(i);_vector$9.transformDirection(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}set(value,offset=0){this.array.set(value,offset);return this;}getX(index){return this.array[index*this.itemSize];}setX(index,x){this.array[index*this.itemSize]=x;return this;}getY(index){return this.array[index*this.itemSize+1];}setY(index,y){this.array[index*this.itemSize+1]=y;return this;}getZ(index){return this.array[index*this.itemSize+2];}setZ(index,z){this.array[index*this.itemSize+2]=z;return this;}getW(index){return this.array[index*this.itemSize+3];}setW(index,w){this.array[index*this.itemSize+3]=w;return this;}setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;}setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}onUpload(callback){this.onUploadCallback=callback;return this;}clone(){return new this.constructor(this.array,this.itemSize).copy(this);}toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage)data.usage=this.usage;if(this.updateRange.offset!==0||this.updateRange.count!==-1)data.updateRange=this.updateRange;return data;}}BufferAttribute.prototype.isBufferAttribute=true;//
class Int8BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Int8Array(array),itemSize,normalized);}}class Uint8BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Uint8Array(array),itemSize,normalized);}}class Uint8ClampedBufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Uint8ClampedArray(array),itemSize,normalized);}}class Int16BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Int16Array(array),itemSize,normalized);}}class Uint16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}}class Int32BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Int32Array(array),itemSize,normalized);}}class Uint32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized);}}class Float16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}}Float16BufferAttribute.prototype.isFloat16BufferAttribute=true;class Float32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized);}}class Float64BufferAttribute extends (/* unused pure expression or super */ null && (BufferAttribute)){constructor(array,itemSize,normalized){super(new Float64Array(array),itemSize,normalized);}}function arrayMax(array){if(array.length===0)return-Infinity;let max=array[0];for(let i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}const TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function getTypedArray(type,buffer){return new TYPED_ARRAYS[type](buffer);}let _id=0;const _m1=/*@__PURE__*/new Matrix4();const _obj=/*@__PURE__*/new Object3D();const _offset=/*@__PURE__*/new three_module_Vector3();const _box$1=/*@__PURE__*/new Box3();const _boxMorphTargets=/*@__PURE__*/new Box3();const _vector$8=/*@__PURE__*/new three_module_Vector3();class BufferGeometry extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:_id++});this.uuid=generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=false;this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};this.userData={};}getIndex(){return this.index;}setIndex(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}return this;}getAttribute(name){return this.attributes[name];}setAttribute(name,attribute){this.attributes[name]=attribute;return this;}deleteAttribute(name){delete this.attributes[name];return this;}hasAttribute(name){return this.attributes[name]!==undefined;}addGroup(start,count,materialIndex=0){this.groups.push({start:start,count:count,materialIndex:materialIndex});}clearGroups(){this.groups=[];}setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}applyMatrix4(matrix){const position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}const normal=this.attributes.normal;if(normal!==undefined){const normalMatrix=new Matrix3().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}const tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}applyQuaternion(q){_m1.makeRotationFromQuaternion(q);this.applyMatrix4(_m1);return this;}rotateX(angle){// rotate geometry around world x-axis
_m1.makeRotationX(angle);this.applyMatrix4(_m1);return this;}rotateY(angle){// rotate geometry around world y-axis
_m1.makeRotationY(angle);this.applyMatrix4(_m1);return this;}rotateZ(angle){// rotate geometry around world z-axis
_m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this;}translate(x,y,z){// translate geometry
_m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this;}scale(x,y,z){// scale geometry
_m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this;}lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this;}center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this;}setFromPoints(points){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute(position,3));return this;}computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingBox.set(new three_module_Vector3(-Infinity,-Infinity,-Infinity),new three_module_Vector3(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_box$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$1.max);this.boundingBox.expandByPoint(_vector$8);}else{this.boundingBox.expandByPoint(_box$1.min);this.boundingBox.expandByPoint(_box$1.max);}}}}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}const position=this.attributes.position;const morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingSphere.set(new three_module_Vector3(),Infinity);return;}if(position){// first, find the center of the bounding sphere
const center=this.boundingSphere.center;_box$1.setFromBufferAttribute(position);// process morph attributes if present
if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_boxMorphTargets.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$1.min,_boxMorphTargets.min);_box$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$1.max,_boxMorphTargets.max);_box$1.expandByPoint(_vector$8);}else{_box$1.expandByPoint(_boxMorphTargets.min);_box$1.expandByPoint(_boxMorphTargets.max);}}}_box$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
let maxRadiusSq=0;for(let i=0,il=position.count;i<il;i++){_vector$8.fromBufferAttribute(position,i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
if(morphAttributesPosition){for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];const morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(morphAttribute,j);if(morphTargetsRelative){_offset.fromBufferAttribute(position,j);_vector$8.add(_offset);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}computeFaceNormals(){// backwards compatibility
}computeTangents(){const index=this.index;const attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
// (per vertex tangents)
if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}const indices=index.array;const positions=attributes.position.array;const normals=attributes.normal.array;const uvs=attributes.uv.array;const nVertices=positions.length/3;if(attributes.tangent===undefined){this.setAttribute('tangent',new BufferAttribute(new Float32Array(4*nVertices),4));}const tangents=attributes.tangent.array;const tan1=[],tan2=[];for(let i=0;i<nVertices;i++){tan1[i]=new three_module_Vector3();tan2[i]=new three_module_Vector3();}const vA=new three_module_Vector3(),vB=new three_module_Vector3(),vC=new three_module_Vector3(),uvA=new Vector2(),uvB=new Vector2(),uvC=new Vector2(),sdir=new three_module_Vector3(),tdir=new three_module_Vector3();function handleTriangle(a,b,c){vA.fromArray(positions,a*3);vB.fromArray(positions,b*3);vC.fromArray(positions,c*3);uvA.fromArray(uvs,a*2);uvB.fromArray(uvs,b*2);uvC.fromArray(uvs,c*2);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);const r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}let groups=this.groups;if(groups.length===0){groups=[{start:0,count:indices.length}];}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleTriangle(indices[j+0],indices[j+1],indices[j+2]);}}const tmp=new three_module_Vector3(),tmp2=new three_module_Vector3();const n=new three_module_Vector3(),n2=new three_module_Vector3();function handleVertex(v){n.fromArray(normals,v*3);n2.copy(n);const t=tan1[v];// Gram-Schmidt orthogonalize
tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
tmp2.crossVectors(n2,t);const test=tmp2.dot(tan2[v]);const w=test<0.0?-1.0:1.0;tangents[v*4]=tmp.x;tangents[v*4+1]=tmp.y;tangents[v*4+2]=tmp.z;tangents[v*4+3]=w;}for(let i=0,il=groups.length;i<il;++i){const group=groups[i];const start=group.start;const count=group.count;for(let j=start,jl=start+count;j<jl;j+=3){handleVertex(indices[j+0]);handleVertex(indices[j+1]);handleVertex(indices[j+2]);}}}computeVertexNormals(){const index=this.index;const positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){let normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else{// reset existing normals to zero
for(let i=0,il=normalAttribute.count;i<il;i++){normalAttribute.setXYZ(i,0,0,0);}}const pA=new three_module_Vector3(),pB=new three_module_Vector3(),pC=new three_module_Vector3();const nA=new three_module_Vector3(),nB=new three_module_Vector3(),nC=new three_module_Vector3();const cb=new three_module_Vector3(),ab=new three_module_Vector3();// indexed elements
if(index){for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+0);const vB=index.getX(i+1);const vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else{// non-indexed elements (unconnected triangle soup)
for(let i=0,il=positionAttribute.count;i<il;i+=3){pA.fromBufferAttribute(positionAttribute,i+0);pB.fromBufferAttribute(positionAttribute,i+1);pC.fromBufferAttribute(positionAttribute,i+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}merge(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined){offset=0;console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');}const attributes=this.attributes;for(const key in attributes){if(geometry.attributes[key]===undefined)continue;const attribute1=attributes[key];const attributeArray1=attribute1.array;const attribute2=geometry.attributes[key];const attributeArray2=attribute2.array;const attributeOffset=attribute2.itemSize*offset;const length=Math.min(attributeArray2.length,attributeArray1.length-attributeOffset);for(let i=0,j=attributeOffset;i<length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;}normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++){_vector$8.fromBufferAttribute(normals,i);_vector$8.normalize();normals.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);}}toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array;const itemSize=attribute.itemSize;const normalized=attribute.normalized;const array2=new array.constructor(indices.length*itemSize);let index=0,index2=0;for(let i=0,l=indices.length;i<l;i++){if(attribute.isInterleavedBufferAttribute){index=indices[i]*attribute.data.stride+attribute.offset;}else{index=indices[i]*itemSize;}for(let j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute(array2,itemSize,normalized);}//
if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}const geometry2=new BufferGeometry();const indices=this.index.array;const attributes=this.attributes;// attributes
for(const name in attributes){const attribute=attributes[name];const newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
const morphAttributes=this.morphAttributes;for(const name in morphAttributes){const morphArray=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(let i=0,il=morphAttribute.length;i<il;i++){const attribute=morphAttribute[i];const newAttribute=convertBufferAttribute(attribute,indices);morphArray.push(newAttribute);}geometry2.morphAttributes[name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
const groups=this.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}toJSON(){const data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){const parameters=this.parameters;for(const key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
data.data={attributes:{}};const index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}const attributes=this.attributes;for(const key in attributes){const attribute=attributes[key];data.data.attributes[key]=attribute.toJSON(data.data);}const morphAttributes={};let hasMorphAttributes=false;for(const key in this.morphAttributes){const attributeArray=this.morphAttributes[key];const array=[];for(let i=0,il=attributeArray.length;i<il;i++){const attribute=attributeArray[i];array.push(attribute.toJSON(data.data));}if(array.length>0){morphAttributes[key]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}const groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}const boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;}clone(){/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new BufferGeometry().copy(this);}copy(source){// reset
this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
const data={};// name
this.name=source.name;// index
const index=source.index;if(index!==null){this.setIndex(index.clone(data));}// attributes
const attributes=source.attributes;for(const name in attributes){const attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
const morphAttributes=source.morphAttributes;for(const name in morphAttributes){const array=[];const morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(let i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone(data));}this.morphAttributes[name]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
const groups=source.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
const boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
const boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
this.userData=source.userData;return this;}dispose(){this.dispatchEvent({type:'dispose'});}}BufferGeometry.prototype.isBufferGeometry=true;const _inverseMatrix$2=/*@__PURE__*/new Matrix4();const _ray$2=/*@__PURE__*/new Ray();const _sphere$3=/*@__PURE__*/new Sphere();const _vA$1=/*@__PURE__*/new three_module_Vector3();const _vB$1=/*@__PURE__*/new three_module_Vector3();const _vC$1=/*@__PURE__*/new three_module_Vector3();const _tempA=/*@__PURE__*/new three_module_Vector3();const _tempB=/*@__PURE__*/new three_module_Vector3();const _tempC=/*@__PURE__*/new three_module_Vector3();const _morphA=/*@__PURE__*/new three_module_Vector3();const _morphB=/*@__PURE__*/new three_module_Vector3();const _morphC=/*@__PURE__*/new three_module_Vector3();const _uvA$1=/*@__PURE__*/new Vector2();const _uvB$1=/*@__PURE__*/new Vector2();const _uvC$1=/*@__PURE__*/new Vector2();const _intersectionPoint=/*@__PURE__*/new three_module_Vector3();const _intersectionPointWorld=/*@__PURE__*/new three_module_Vector3();class three_module_Mesh extends Object3D{constructor(geometry=new BufferGeometry(),material=new MeshBasicMaterial()){super();this.type='Mesh';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=source.material;this.geometry=source.geometry;return this;}updateMorphTargets(){const geometry=this.geometry;if(geometry.isBufferGeometry){const morphAttributes=geometry.morphAttributes;const keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{const morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}raycast(raycaster,intersects){const geometry=this.geometry;const material=this.material;const matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere);_sphere$3.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(_sphere$3)===false)return;//
_inverseMatrix$2.copy(matrixWorld).invert();_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);// Check boundingBox before continuing
if(geometry.boundingBox!==null){if(_ray$2.intersectsBox(geometry.boundingBox)===false)return;}let intersection;if(geometry.isBufferGeometry){const index=geometry.index;const position=geometry.attributes.position;const morphPosition=geometry.morphAttributes.position;const morphTargetsRelative=geometry.morphTargetsRelative;const uv=geometry.attributes.uv;const uv2=geometry.attributes.uv2;const groups=geometry.groups;const drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(let j=start,jl=end;j<jl;j+=3){const a=index.getX(j);const b=index.getX(j+1);const c=index.getX(j+2);intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else{const start=Math.max(0,drawRange.start);const end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=index.getX(i);const b=index.getX(i+1);const c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indexed buffer semantics
intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
if(Array.isArray(material)){for(let i=0,il=groups.length;i<il;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];const start=Math.max(group.start,drawRange.start);const end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(let j=start,jl=end;j<jl;j+=3){const a=j;const b=j+1;const c=j+2;intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in non-indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else{const start=Math.max(0,drawRange.start);const end=Math.min(position.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i+=3){const a=i;const b=i+1;const c=i+2;intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in non-indexed buffer semantics
intersects.push(intersection);}}}}}else if(geometry.isGeometry){console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}three_module_Mesh.prototype.isMesh=true;function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){let intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA$1.fromBufferAttribute(position,a);_vB$1.fromBufferAttribute(position,b);_vC$1.fromBufferAttribute(position,c);const morphInfluences=object.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){const influence=morphInfluences[i];const morphAttribute=morphPosition[i];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,a);_tempB.fromBufferAttribute(morphAttribute,b);_tempC.fromBufferAttribute(morphAttribute,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence);}else{_morphA.addScaledVector(_tempA.sub(_vA$1),influence);_morphB.addScaledVector(_tempB.sub(_vB$1),influence);_morphC.addScaledVector(_tempC.sub(_vC$1),influence);}}_vA$1.add(_morphA);_vB$1.add(_morphB);_vC$1.add(_morphC);}if(object.isSkinnedMesh){object.boneTransform(a,_vA$1);object.boneTransform(b,_vB$1);object.boneTransform(c,_vC$1);}const intersection=checkIntersection(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){if(uv){_uvA$1.fromBufferAttribute(uv,a);_uvB$1.fromBufferAttribute(uv,b);_uvC$1.fromBufferAttribute(uv,c);intersection.uv=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}if(uv2){_uvA$1.fromBufferAttribute(uv2,a);_uvB$1.fromBufferAttribute(uv2,b);_uvC$1.fromBufferAttribute(uv2,c);intersection.uv2=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}const face={a:a,b:b,c:c,normal:new three_module_Vector3(),materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;}return intersection;}class BoxGeometry extends BufferGeometry{constructor(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){super();this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};const scope=this;// segments
widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
let numberOfVertices=0;let groupStart=0;// build each side of the box geometry
buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){const segmentWidth=width/gridX;const segmentHeight=height/gridY;const widthHalf=width/2;const heightHalf=height/2;const depthHalf=depth/2;const gridX1=gridX+1;const gridY1=gridY+1;let vertexCounter=0;let groupCount=0;const vector=new three_module_Vector3();// generate vertices, normals and uvs
for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;// set values to correct vector component
vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
normals.push(vector.x,vector.y,vector.z);// uvs
uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
vertexCounter+=1;}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=numberOfVertices+ix+gridX1*iy;const b=numberOfVertices+ix+gridX1*(iy+1);const c=numberOfVertices+(ix+1)+gridX1*(iy+1);const d=numberOfVertices+(ix+1)+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);// increase counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
groupStart+=groupCount;// update total number of vertices
numberOfVertices+=vertexCounter;}}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}}/**
 * Uniform Utilities
 */function cloneUniforms(src){const dst={};for(const u in src){dst[u]={};for(const p in src[u]){const property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){dst[u][p]=property.clone();}else if(Array.isArray(property)){dst[u][p]=property.slice();}else{dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){const merged={};for(let u=0;u<uniforms.length;u++){const tmp=cloneUniforms(uniforms[u]);for(const p in tmp){merged[p]=tmp[p];}}return merged;}// Legacy
const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>
 * }
 */class ShaderMaterial extends Material{constructor(parameters){super();this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader=default_vertex;this.fragmentShader=default_fragment;this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes
this.extensions={derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;this.uniformsNeedUpdate=false;this.glslVersion=null;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}copy(source){super.copy(source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}toJSON(meta){const data=super.toJSON(meta);data.glslVersion=this.glslVersion;data.uniforms={};for(const name in this.uniforms){const uniform=this.uniforms[name];const value=uniform.value;if(value&&value.isTexture){data.uniforms[name]={type:'t',value:value.toJSON(meta).uuid};}else if(value&&value.isColor){data.uniforms[name]={type:'c',value:value.getHex()};}else if(value&&value.isVector2){data.uniforms[name]={type:'v2',value:value.toArray()};}else if(value&&value.isVector3){data.uniforms[name]={type:'v3',value:value.toArray()};}else if(value&&value.isVector4){data.uniforms[name]={type:'v4',value:value.toArray()};}else if(value&&value.isMatrix3){data.uniforms[name]={type:'m3',value:value.toArray()};}else if(value&&value.isMatrix4){data.uniforms[name]={type:'m4',value:value.toArray()};}else{data.uniforms[name]={value:value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
}}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;const extensions={};for(const key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}ShaderMaterial.prototype.isShaderMaterial=true;class Camera extends Object3D{constructor(){super();this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();this.projectionMatrixInverse=new Matrix4();}copy(source,recursive){super.copy(source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this;}getWorldDirection(target){this.updateWorldMatrix(true,false);const e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize();}updateMatrixWorld(force){super.updateMatrixWorld(force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}clone(){return new this.constructor().copy(this);}}Camera.prototype.isCamera=true;class PerspectiveCamera extends Camera{constructor(fov=50,aspect=1,near=0.1,far=2000){super();this.type='PerspectiveCamera';this.fov=fov;this.zoom=1;this.near=near;this.far=far;this.focus=10;this.aspect=aspect;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)
this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */const vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength(){const vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);}/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;let height=2*top;let width=this.aspect*height;let left=-0.5*width;const view=this.view;if(this.view!==null&&this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}const skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}PerspectiveCamera.prototype.isPerspectiveCamera=true;const fov=90,aspect=1;class CubeCamera extends Object3D{constructor(near,far,renderTarget){super();this.type='CubeCamera';if(renderTarget.isWebGLCubeRenderTarget!==true){console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');return;}this.renderTarget=renderTarget;const cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=this.layers;cameraPX.up.set(0,-1,0);cameraPX.lookAt(new three_module_Vector3(1,0,0));this.add(cameraPX);const cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=this.layers;cameraNX.up.set(0,-1,0);cameraNX.lookAt(new three_module_Vector3(-1,0,0));this.add(cameraNX);const cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=this.layers;cameraPY.up.set(0,0,1);cameraPY.lookAt(new three_module_Vector3(0,1,0));this.add(cameraPY);const cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=this.layers;cameraNY.up.set(0,0,-1);cameraNY.lookAt(new three_module_Vector3(0,-1,0));this.add(cameraNY);const cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=this.layers;cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new three_module_Vector3(0,0,1));this.add(cameraPZ);const cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=this.layers;cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new three_module_Vector3(0,0,-1));this.add(cameraNZ);}update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();const renderTarget=this.renderTarget;const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children;const currentXrEnabled=renderer.xr.enabled;const currentRenderTarget=renderer.getRenderTarget();renderer.xr.enabled=false;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);renderer.xr.enabled=currentXrEnabled;}}class CubeTexture extends Texture{constructor(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;format=format!==undefined?format:RGBFormat;super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}get images(){return this.image;}set images(value){this.image=value;}}CubeTexture.prototype.isCubeTexture=true;class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(size,options,dummy){if(Number.isInteger(options)){console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');options=dummy;}super(size,size,options);options=options||{};// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
this.texture=new CubeTexture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=true;this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;this.texture._needsFlipEnvMap=false;}fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.format=RGBAFormat;// see #18859
this.texture.encoding=texture.encoding;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;const shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`};const geometry=new BoxGeometry(5,5,5);const material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;const mesh=new three_module_Mesh(geometry,material);const currentMinFilter=texture.minFilter;// Avoid blurred poles
if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;const camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}clear(renderer,color,depth,stencil){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;i<6;i++){renderer.setRenderTarget(this,i);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=true;const _vector1=/*@__PURE__*/new three_module_Vector3();const _vector2=/*@__PURE__*/new three_module_Vector3();const _normalMatrix=/*@__PURE__*/new Matrix3();class Plane{constructor(normal=new three_module_Vector3(1,0,0),constant=0){// normal is assumed to be normalized
this.normal=normal;this.constant=constant;}set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}setFromCoplanarPoints(a,b,c){const normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(normal,a);return this;}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
const inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}negate(){this.constant*=-1;this.normal.negate();return this;}distanceToPoint(point){return this.normal.dot(point)+this.constant;}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);}intersectLine(line,target){const direction=line.delta(_vector1);const denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
return null;}const t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(direction).multiplyScalar(t).add(line.start);}intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
const startSign=this.distanceToPoint(line.start);const endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}intersectsBox(box){return box.intersectsPlane(this);}intersectsSphere(sphere){return sphere.intersectsPlane(this);}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}applyMatrix4(matrix,optionalNormalMatrix){const normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);const referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);const normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}translate(offset){this.constant-=offset.dot(this.normal);return this;}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}clone(){return new this.constructor().copy(this);}}Plane.prototype.isPlane=true;const _sphere$2=/*@__PURE__*/new Sphere();const _vector$7=/*@__PURE__*/new three_module_Vector3();class Frustum{constructor(p0=new Plane(),p1=new Plane(),p2=new Plane(),p3=new Plane(),p4=new Plane(),p5=new Plane()){this.planes=[p0,p1,p2,p3,p4,p5];}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}copy(frustum){const planes=this.planes;for(let i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;}setFromProjectionMatrix(m){const planes=this.planes;const me=m.elements;const me0=me[0],me1=me[1],me2=me[2],me3=me[3];const me4=me[4],me5=me[5],me6=me[6],me7=me[7];const me8=me[8],me9=me[9],me10=me[10],me11=me[11];const me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;}intersectsObject(object){const geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere$2);}intersectsSprite(sprite){_sphere$2.center.set(0,0,0);_sphere$2.radius=0.7071067811865476;_sphere$2.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$2);}intersectsSphere(sphere){const planes=this.planes;const center=sphere.center;const negRadius=-sphere.radius;for(let i=0;i<6;i++){const distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}intersectsBox(box){const planes=this.planes;for(let i=0;i<6;i++){const plane=planes[i];// corner at max distance
_vector$7.x=plane.normal.x>0?box.max.x:box.min.x;_vector$7.y=plane.normal.y>0?box.max.y:box.min.y;_vector$7.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$7)<0){return false;}}return true;}containsPoint(point){const planes=this.planes;for(let i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}clone(){return new this.constructor().copy(this);}}function WebGLAnimation(){let context=null;let isAnimating=false;let animationLoop=null;let requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return{start:function(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function(callback){animationLoop=callback;},setContext:function(value){context=value;}};}function WebGLAttributes(gl,capabilities){const isWebGL2=capabilities.isWebGL2;const buffers=new WeakMap();function createBuffer(attribute,bufferType){const array=attribute.array;const usage=attribute.usage;const buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();let type=5126;if(array instanceof Float32Array){type=5126;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){if(isWebGL2){type=5131;}else{console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');}}else{type=5123;}}else if(array instanceof Int16Array){type=5122;}else if(array instanceof Uint32Array){type=5125;}else if(array instanceof Int32Array){type=5124;}else if(array instanceof Int8Array){type=5120;}else if(array instanceof Uint8Array){type=5121;}else if(array instanceof Uint8ClampedArray){type=5121;}return{buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){const array=attribute.array;const updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(updateRange.count===-1){// Not using update ranges
gl.bufferSubData(bufferType,0,array);}else{if(isWebGL2){gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count);}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));}updateRange.count=-1;// reset range
}}//
function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;const data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isGLBufferAttribute){const cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;const data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return{get:get,remove:remove,update:update};}class PlaneGeometry extends BufferGeometry{constructor(width=1,height=1,widthSegments=1,heightSegments=1){super();this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};const width_half=width/2;const height_half=height/2;const gridX=Math.floor(widthSegments);const gridY=Math.floor(heightSegments);const gridX1=gridX+1;const gridY1=gridY+1;const segment_width=width/gridX;const segment_height=height/gridY;//
const indices=[];const vertices=[];const normals=[];const uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++){const x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(let iy=0;iy<gridY;iy++){for(let ix=0;ix<gridX;ix++){const a=ix+gridX1*iy;const b=ix+gridX1*(iy+1);const c=ix+1+gridX1*(iy+1);const d=ix+1+gridX1*iy;indices.push(a,b,d);indices.push(b,c,d);}}this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="vec3 transformed = vec3( position );";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var normal_fragment_maps="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";var uv_pars_fragment="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var uv_vertex="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";var background_frag="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var background_vert="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";var cube_frag="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var cube_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";var distanceRGBA_frag="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";var distanceRGBA_vert="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";var equirect_frag="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var equirect_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshmatcap_frag="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshmatcap_vert="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";var meshtoon_frag="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshtoon_vert="#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshphysical_frag="#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshphysical_vert="#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";var shadow_frag="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var shadow_vert="#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var sprite_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var sprite_vert="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,background_frag:background_frag,background_vert:background_vert,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshmatcap_frag:meshmatcap_frag,meshmatcap_vert:meshmatcap_vert,meshtoon_frag:meshtoon_frag,meshtoon_vert:meshtoon_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert,sprite_frag:sprite_frag,sprite_vert:sprite_vert};/**
 * Uniforms library for shared webgl shaders
 */const UniformsLib={common:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()},uv2Transform:{value:new Matrix3()},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3()}},sprite:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},center:{value:new Vector2(0.5,0.5)},rotation:{value:0.0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3()}}};const ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}// temporary
}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3()},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */cube:{uniforms:mergeUniforms([UniformsLib.envmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new three_module_Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Color(0x000000)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Color(0x000000)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Color(1,1,1)},specularTintMap:{value:null}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};function WebGLBackground(renderer,cubemaps,state,objects,premultipliedAlpha){const clearColor=new Color(0x000000);let clearAlpha=0;let planeMesh;let boxMesh;let currentBackground=null;let currentBackgroundVersion=0;let currentTonemapping=null;function render(renderList,scene){let forceClear=false;let background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){background=cubemaps.get(background);}// Ignore background in AR
// TODO: Reconsider this.
const xr=renderer.xr;const session=xr.getSession&&xr.getSession();if(session&&session.environmentBlendMode==='additive'){background=null;}if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new three_module_Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.cube.uniforms),vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// enable code injection for non-built-in material
Object.defineProperty(boxMesh.material,'envMap',{get:function(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new three_module_Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// enable code injection for non-built-in material
Object.defineProperty(planeMesh.material,'map',{get:function(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return{getClearColor:function(){return clearColor;},setClearColor:function(color,alpha=1){clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function(){return clearAlpha;},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}function WebGLBindingStates(gl,extensions,attributes,capabilities){const maxVertexAttributes=gl.getParameter(34921);const extension=capabilities.isWebGL2?null:extensions.get('OES_vertex_array_object');const vaoAvailable=capabilities.isWebGL2||extension!==null;const bindingStates={};const defaultState=createBindingState(null);let currentState=defaultState;function setup(object,material,program,geometry,index){let updateBuffers=false;if(vaoAvailable){const state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(geometry,index);if(updateBuffers)saveCache(geometry,index);}else{const wireframe=material.wireframe===true;if(currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==wireframe){currentState.geometry=geometry.id;currentState.program=program.id;currentState.wireframe=wireframe;updateBuffers=true;}}if(object.isInstancedMesh===true){updateBuffers=true;}if(index!==null){attributes.update(index,34963);}if(updateBuffers){setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(34963,attributes.get(index).buffer);}}}function createVertexArrayObject(){if(capabilities.isWebGL2)return gl.createVertexArray();return extension.createVertexArrayOES();}function bindVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.bindVertexArray(vao);return extension.bindVertexArrayOES(vao);}function deleteVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.deleteVertexArray(vao);return extension.deleteVertexArrayOES(vao);}function getBindingState(geometry,program,material){const wireframe=material.wireframe===true;let programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}let stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}let state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){const newAttributes=[];const enabledAttributes=[];const attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++){newAttributes[i]=0;enabledAttributes[i]=0;attributeDivisors[i]=0;}return{// for backward compatibility on non-VAO support browser
geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(geometry,index){const cachedAttributes=currentState.attributes;const geometryAttributes=geometry.attributes;let attributesNum=0;for(const key in geometryAttributes){const cachedAttribute=cachedAttributes[key];const geometryAttribute=geometryAttributes[key];if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(geometry,index){const cache={};const attributes=geometry.attributes;let attributesNum=0;for(const key in attributes){const attribute=attributes[key];const data={};data.attribute=attribute;if(attribute.data){data.data=attribute.data;}cache[key]=data;attributesNum++;}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++){newAttributes[i]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;const attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){const extension=capabilities.isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');extension[capabilities.isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes;const enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset){if(capabilities.isWebGL2===true&&(type===5124||type===5125)){gl.vertexAttribIPointer(index,size,type,stride,offset);}else{gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){if(capabilities.isWebGL2===false&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)){if(extensions.get('ANGLE_instanced_arrays')===null)return;}initAttributes();const geometryAttributes=geometry.attributes;const programAttributes=program.getAttributes();const materialDefaultAttributeValues=material.defaultAttributeValues;for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute>=0){const geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){const normalized=geometryAttribute.normalized;const size=geometryAttribute.itemSize;const attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;const buffer=attribute.buffer;const type=attribute.type;const bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){const data=geometryAttribute.data;const stride=data.stride;const offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else{enableAttribute(programAttribute);}gl.bindBuffer(34962,buffer);vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,offset*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{enableAttribute(programAttribute);}gl.bindBuffer(34962,buffer);vertexAttribPointer(programAttribute,size,type,normalized,0,0);}}else if(name==='instanceMatrix'){const attribute=attributes.get(object.instanceMatrix);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;const buffer=attribute.buffer;const type=attribute.type;enableAttributeAndDivisor(programAttribute+0,1);enableAttributeAndDivisor(programAttribute+1,1);enableAttributeAndDivisor(programAttribute+2,1);enableAttributeAndDivisor(programAttribute+3,1);gl.bindBuffer(34962,buffer);gl.vertexAttribPointer(programAttribute+0,4,type,false,64,0);gl.vertexAttribPointer(programAttribute+1,4,type,false,64,16);gl.vertexAttribPointer(programAttribute+2,4,type,false,64,32);gl.vertexAttribPointer(programAttribute+3,4,type,false,64,48);}else if(name==='instanceColor'){const attribute=attributes.get(object.instanceColor);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;const buffer=attribute.buffer;const type=attribute.type;enableAttributeAndDivisor(programAttribute,1);gl.bindBuffer(34962,buffer);gl.vertexAttribPointer(programAttribute,3,type,false,12,0);}else if(materialDefaultAttributeValues!==undefined){const value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:gl.vertexAttrib2fv(programAttribute,value);break;case 3:gl.vertexAttrib3fv(programAttribute,value);break;case 4:gl.vertexAttrib4fv(programAttribute,value);break;default:gl.vertexAttrib1fv(programAttribute,value);}}}}}disableUnusedAttributes();}function dispose(){reset();for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;const programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;const stateMap=programMap[program.id];for(const wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatilibity
function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return{setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;let extension,methodName;if(isWebGL2){extension=gl;methodName='drawArraysInstanced';}else{extension=extensions.get('ANGLE_instanced_arrays');methodName='drawArraysInstancedANGLE';if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount);}//
this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}function WebGLCapabilities(gl,extensions,parameters){let maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){const extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&gl.getShaderPrecisionFormat(35632,36338).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&gl.getShaderPrecisionFormat(35632,36337).precision>0){return'mediump';}}return'lowp';}/* eslint-disable no-undef */const isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!=='undefined'&&gl instanceof WebGL2ComputeRenderingContext;/* eslint-enable no-undef */let precision=parameters.precision!==undefined?parameters.precision:'highp';const maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}const drawBuffers=isWebGL2||extensions.has('WEBGL_draw_buffers');const logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;const maxTextures=gl.getParameter(34930);const maxVertexTextures=gl.getParameter(35660);const maxTextureSize=gl.getParameter(3379);const maxCubemapSize=gl.getParameter(34076);const maxAttributes=gl.getParameter(34921);const maxVertexUniforms=gl.getParameter(36347);const maxVaryings=gl.getParameter(36348);const maxFragmentUniforms=gl.getParameter(36349);const vertexTextures=maxVertexTextures>0;const floatFragmentTextures=isWebGL2||extensions.has('OES_texture_float');const floatVertexTextures=vertexTextures&&floatFragmentTextures;const maxSamples=isWebGL2?gl.getParameter(36183):0;return{isWebGL2:isWebGL2,drawBuffers:drawBuffers,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){const scope=this;let globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;const plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){const enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(material,camera,useCache){const planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;const materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
if(renderingShadows){// there's no global clipping
projectPlanes(null);}else{resetGlobalState();}}else{const nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;let dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(let i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){const nPlanes=planes!==null?planes.length:0;let dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){const flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(let i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){let cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){const mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){const cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else{const image=texture.image;if(image&&image.height>0){const currentRenderTarget=renderer.getRenderTarget();const renderTarget=new WebGLCubeRenderTarget(image.height/2);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else{// image not yet ready. try the conversion next frame
return null;}}}}return texture;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps.delete(texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return{get:get,dispose:dispose};}class OrthographicCamera extends Camera{constructor(left=-1,right=1,top=1,bottom=-1,near=0.1,far=2000){super();this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near;this.far=far;this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){const dx=(this.right-this.left)/(2*this.zoom);const dy=(this.top-this.bottom)/(2*this.zoom);const cx=(this.right+this.left)/2;const cy=(this.top+this.bottom)/2;let left=cx-dx;let right=cx+dx;let top=cy+dy;let bottom=cy-dy;if(this.view!==null&&this.view.enabled){const scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;const scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){const data=super.toJSON(meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}OrthographicCamera.prototype.isOrthographicCamera=true;class RawShaderMaterial extends ShaderMaterial{constructor(parameters){super(parameters);this.type='RawShaderMaterial';}}RawShaderMaterial.prototype.isRawShaderMaterial=true;const LOD_MIN=4;const LOD_MAX=8;const SIZE_MAX=Math.pow(2,LOD_MAX);// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];const TOTAL_LODS=LOD_MAX-LOD_MIN+1+EXTRA_LOD_SIGMA.length;// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES=20;const ENCODINGS={[LinearEncoding]:0,[sRGBEncoding]:1,[RGBEEncoding]:2,[RGBM7Encoding]:3,[RGBM16Encoding]:4,[RGBDEncoding]:5,[GammaEncoding]:6};const backgroundMaterial=new MeshBasicMaterial({side:BackSide,depthWrite:false,depthTest:false});const backgroundBox=new three_module_Mesh(new BoxGeometry(),backgroundMaterial);const _flatCamera=/*@__PURE__*/new OrthographicCamera();const{_lodPlanes,_sizeLods,_sigmas}=/*@__PURE__*/_createPlanes();const _clearColor=/*@__PURE__*/new Color();let _oldTarget=null;// Golden Ratio
const PHI=(1+Math.sqrt(5))/2;const INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections=[/*@__PURE__*/new three_module_Vector3(1,1,1),/*@__PURE__*/new three_module_Vector3(-1,1,1),/*@__PURE__*/new three_module_Vector3(1,1,-1),/*@__PURE__*/new three_module_Vector3(-1,1,-1),/*@__PURE__*/new three_module_Vector3(0,PHI,INV_PHI),/*@__PURE__*/new three_module_Vector3(0,PHI,-INV_PHI),/*@__PURE__*/new three_module_Vector3(INV_PHI,0,PHI),/*@__PURE__*/new three_module_Vector3(-INV_PHI,0,PHI),/*@__PURE__*/new three_module_Vector3(PHI,INV_PHI,0),/*@__PURE__*/new three_module_Vector3(-PHI,INV_PHI,0)];/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/function convertLinearToRGBE(color){const maxComponent=Math.max(color.r,color.g,color.b);const fExp=Math.min(Math.max(Math.ceil(Math.log2(maxComponent)),-128.0),127.0);color.multiplyScalar(Math.pow(2.0,-fExp));const alpha=(fExp+128.0)/255.0;return alpha;}class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._blurMaterial=_getBlurShader(MAX_SAMPLES);this._equirectShader=null;this._cubemapShader=null;this._compileMaterial(this._blurMaterial);}/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */fromScene(scene,sigma=0,near=0.1,far=100){_oldTarget=this._renderer.getRenderTarget();const cubeUVRenderTarget=this._allocateTargets();this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromEquirectangular(equirectangular){return this._fromTexture(equirectangular);}/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromCubemap(cubemap){return this._fromTexture(cubemap);}/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileCubemapShader(){if(this._cubemapShader===null){this._cubemapShader=_getCubemapShader();this._compileMaterial(this._cubemapShader);}}/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileEquirectangularShader(){if(this._equirectShader===null){this._equirectShader=_getEquirectShader();this._compileMaterial(this._equirectShader);}}/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */dispose(){this._blurMaterial.dispose();if(this._cubemapShader!==null)this._cubemapShader.dispose();if(this._equirectShader!==null)this._equirectShader.dispose();for(let i=0;i<_lodPlanes.length;i++){_lodPlanes[i].dispose();}}// private interface
_cleanup(outputTarget){this._pingPongRenderTarget.dispose();this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}_fromTexture(texture){_oldTarget=this._renderer.getRenderTarget();const cubeUVRenderTarget=this._allocateTargets(texture);this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}_allocateTargets(texture){// warning: null texture is valid
const params={magFilter:NearestFilter,minFilter:NearestFilter,generateMipmaps:false,type:UnsignedByteType,format:RGBEFormat,encoding:_isLDR(texture)?texture.encoding:RGBEEncoding,depthBuffer:false};const cubeUVRenderTarget=_createRenderTarget(params);cubeUVRenderTarget.depthBuffer=texture?false:true;this._pingPongRenderTarget=_createRenderTarget(params);return cubeUVRenderTarget;}_compileMaterial(material){const tmpMesh=new three_module_Mesh(_lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera);}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){const fov=90;const aspect=1;const cubeCamera=new PerspectiveCamera(fov,aspect,near,far);const upSign=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1];const renderer=this._renderer;const originalAutoClear=renderer.autoClear;const outputEncoding=renderer.outputEncoding;const toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.outputEncoding=LinearEncoding;renderer.autoClear=false;let useSolidColor=false;const background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background).convertSRGBToLinear();scene.background=null;const alpha=convertLinearToRGBE(backgroundMaterial.color);backgroundMaterial.opacity=alpha;useSolidColor=true;}}else{backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();const alpha=convertLinearToRGBE(backgroundMaterial.color);backgroundMaterial.opacity=alpha;useSolidColor=true;}for(let i=0;i<6;i++){const col=i%3;if(col==0){cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(forwardSign[i],0,0);}else if(col==1){cubeCamera.up.set(0,0,upSign[i]);cubeCamera.lookAt(0,forwardSign[i],0);}else{cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(0,0,forwardSign[i]);}_setViewport(cubeUVRenderTarget,col*SIZE_MAX,i>2?SIZE_MAX:0,SIZE_MAX,SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}renderer.toneMapping=toneMapping;renderer.outputEncoding=outputEncoding;renderer.autoClear=originalAutoClear;}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer;if(texture.isCubeTexture){if(this._cubemapShader==null){this._cubemapShader=_getCubemapShader();}}else{if(this._equirectShader==null){this._equirectShader=_getEquirectShader();}}const material=texture.isCubeTexture?this._cubemapShader:this._equirectShader;const mesh=new three_module_Mesh(_lodPlanes[0],material);const uniforms=material.uniforms;uniforms['envMap'].value=texture;if(!texture.isCubeTexture){uniforms['texelSize'].value.set(1.0/texture.image.width,1.0/texture.image.height);}uniforms['inputEncoding'].value=ENCODINGS[texture.encoding];uniforms['outputEncoding'].value=ENCODINGS[cubeUVRenderTarget.texture.encoding];_setViewport(cubeUVRenderTarget,0,0,3*SIZE_MAX,2*SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer;const autoClear=renderer.autoClear;renderer.autoClear=false;for(let i=1;i<TOTAL_LODS;i++){const sigma=Math.sqrt(_sigmas[i]*_sigmas[i]-_sigmas[i-1]*_sigmas[i-1]);const poleAxis=_axisDirections[(i-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,i-1,i,sigma,poleAxis);}renderer.autoClear=autoClear;}/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;const blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
const STANDARD_DEVIATIONS=3;const blurMesh=new three_module_Mesh(_lodPlanes[lodOut],blurMaterial);const blurUniforms=blurMaterial.uniforms;const pixels=_sizeLods[lodIn]-1;const radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);const sigmaPixels=sigmaRadians/radiansPerPixel;const samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);}const weights=[];let sum=0;for(let i=0;i<MAX_SAMPLES;++i){const x=i/sigmaPixels;const weight=Math.exp(-x*x/2);weights.push(weight);if(i==0){sum+=weight;}else if(i<samples){sum+=2*weight;}}for(let i=0;i<weights.length;i++){weights[i]=weights[i]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=LOD_MAX-lodIn;blurUniforms['inputEncoding'].value=ENCODINGS[targetIn.texture.encoding];blurUniforms['outputEncoding'].value=ENCODINGS[targetIn.texture.encoding];const outputSize=_sizeLods[lodOut];const x=3*Math.max(0,SIZE_MAX-2*outputSize);const y=(lodOut===0?0:2*SIZE_MAX)+2*outputSize*(lodOut>LOD_MAX-LOD_MIN?lodOut-LOD_MAX+LOD_MIN:0);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}function _isLDR(texture){if(texture===undefined||texture.type!==UnsignedByteType)return false;return texture.encoding===LinearEncoding||texture.encoding===sRGBEncoding||texture.encoding===GammaEncoding;}function _createPlanes(){const _lodPlanes=[];const _sizeLods=[];const _sigmas=[];let lod=LOD_MAX;for(let i=0;i<TOTAL_LODS;i++){const sizeLod=Math.pow(2,lod);_sizeLods.push(sizeLod);let sigma=1.0/sizeLod;if(i>LOD_MAX-LOD_MIN){sigma=EXTRA_LOD_SIGMA[i-LOD_MAX+LOD_MIN-1];}else if(i==0){sigma=0;}_sigmas.push(sigma);const texelSize=1.0/(sizeLod-1);const min=-texelSize/2;const max=1+texelSize/2;const uv1=[min,min,max,min,max,max,min,min,max,max,min,max];const cubeFaces=6;const vertices=6;const positionSize=3;const uvSize=2;const faceIndexSize=1;const position=new Float32Array(positionSize*vertices*cubeFaces);const uv=new Float32Array(uvSize*vertices*cubeFaces);const faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(let face=0;face<cubeFaces;face++){const x=face%3*2/3-1;const y=face>2?0:-1;const coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);const fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}const planes=new BufferGeometry();planes.setAttribute('position',new BufferAttribute(position,positionSize));planes.setAttribute('uv',new BufferAttribute(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute(faceIndex,faceIndexSize));_lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return{_lodPlanes,_sizeLods,_sigmas};}function _createRenderTarget(params){const cubeUVRenderTarget=new WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getBlurShader(maxSamples){const weights=new Float32Array(maxSamples);const poleAxis=new three_module_Vector3(0,1,0);const shaderMaterial=new RawShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':maxSamples},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectShader(){const texelSize=new Vector2(1,1);const shaderMaterial=new RawShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null},'texelSize':{value:texelSize},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCubemapShader(){const shaderMaterial=new RawShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCommonVertexShader(){return(/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`);}function _getEncodings(){return(/* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`);}function WebGLCubeUVMaps(renderer){let cubeUVmaps=new WeakMap();let pmremGenerator=null;function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){const mapping=texture.mapping;const isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;const isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;if(isEquirectMap||isCubeMap){// equirect/cube map to cubeUV conversion
if(cubeUVmaps.has(texture)){return cubeUVmaps.get(texture).texture;}else{const image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){const currentRenderTarget=renderer.getRenderTarget();if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);const renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);cubeUVmaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return renderTarget.texture;}else{// image not yet ready. try the conversion next frame
return null;}}}}return texture;}function isCubeTextureComplete(image){let count=0;const length=6;for(let i=0;i<length;i++){if(image[i]!==undefined)count++;}return count===length;}function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);const cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubemapUV.delete(texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return{get:get,dispose:dispose};}function WebGLExtensions(gl){const extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}let extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}extensions[name]=extension;return extension;}return{has:function(name){return getExtension(name)!==null;},init:function(capabilities){if(capabilities.isWebGL2){getExtension('EXT_color_buffer_float');}else{getExtension('WEBGL_depth_texture');getExtension('OES_texture_float');getExtension('OES_texture_half_float');getExtension('OES_texture_half_float_linear');getExtension('OES_standard_derivatives');getExtension('OES_element_index_uint');getExtension('OES_vertex_array_object');getExtension('ANGLE_instanced_arrays');}getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');},get:function(name){const extension=getExtension(name);if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){const geometries={};const wireframeAttributes=new WeakMap();function onGeometryDispose(event){const geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(const name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];const attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes.delete(geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){const geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
for(const name in geometryAttributes){attributes.update(geometryAttributes[name],34962);}// morph targets
const morphAttributes=geometry.morphAttributes;for(const name in morphAttributes){const array=morphAttributes[name];for(let i=0,l=array.length;i<l;i++){attributes.update(array[i],34962);}}}function updateWireframeAttribute(geometry){const indices=[];const geometryIndex=geometry.index;const geometryPosition=geometry.attributes.position;let version=0;if(geometryIndex!==null){const array=geometryIndex.array;version=geometryIndex.version;for(let i=0,l=array.length;i<l;i+=3){const a=array[i+0];const b=array[i+1];const c=array[i+2];indices.push(a,b,b,c,c,a);}}else{const array=geometryPosition.array;version=geometryPosition.version;for(let i=0,l=array.length/3-1;i<l;i+=3){const a=i+0;const b=i+1;const c=i+2;indices.push(a,b,b,c,c,a);}}const attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
//
const previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){const currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){const geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else{updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode;function setMode(value){mode=value;}let type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;let extension,methodName;if(isWebGL2){extension=gl;methodName='drawElementsInstanced';}else{extension=extensions.get('ANGLE_instanced_arrays');methodName='drawElementsInstancedANGLE';if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}//
this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}function WebGLInfo(gl){const memory={geometries:0,textures:0};const render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case 4:render.triangles+=instanceCount*(count/3);break;case 1:render.lines+=instanceCount*(count/2);break;case 3:render.lines+=instanceCount*(count-1);break;case 2:render.lines+=instanceCount*count;break;case 0:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return{memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}function numericalSort(a,b){return a[0]-b[0];}function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function WebGLMorphtargets(gl){const influencesList={};const morphInfluences=new Float32Array(8);const workInfluences=[];for(let i=0;i<8;i++){workInfluences[i]=[i,0];}function update(object,geometry,material,program){const objectInfluences=object.morphTargetInfluences;// When object doesn't have morph target influences defined, we treat it as a 0-length array
// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
const length=objectInfluences===undefined?0:objectInfluences.length;let influences=influencesList[geometry.id];if(influences===undefined||influences.length!==length){// initialise list
influences=[];for(let i=0;i<length;i++){influences[i]=[i,0];}influencesList[geometry.id]=influences;}// Collect influences
for(let i=0;i<length;i++){const influence=influences[i];influence[0]=i;influence[1]=objectInfluences[i];}influences.sort(absNumericalSort);for(let i=0;i<8;i++){if(i<length&&influences[i][1]){workInfluences[i][0]=influences[i][0];workInfluences[i][1]=influences[i][1];}else{workInfluences[i][0]=Number.MAX_SAFE_INTEGER;workInfluences[i][1]=0;}}workInfluences.sort(numericalSort);const morphTargets=geometry.morphAttributes.position;const morphNormals=geometry.morphAttributes.normal;let morphInfluencesSum=0;for(let i=0;i<8;i++){const influence=workInfluences[i];const index=influence[0];const value=influence[1];if(index!==Number.MAX_SAFE_INTEGER&&value){if(morphTargets&&geometry.getAttribute('morphTarget'+i)!==morphTargets[index]){geometry.setAttribute('morphTarget'+i,morphTargets[index]);}if(morphNormals&&geometry.getAttribute('morphNormal'+i)!==morphNormals[index]){geometry.setAttribute('morphNormal'+i,morphNormals[index]);}morphInfluences[i]=value;morphInfluencesSum+=value;}else{if(morphTargets&&geometry.hasAttribute('morphTarget'+i)===true){geometry.deleteAttribute('morphTarget'+i);}if(morphNormals&&geometry.hasAttribute('morphNormal'+i)===true){geometry.deleteAttribute('morphNormal'+i);}morphInfluences[i]=0;}}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
// This allows us to switch between absolute morphs and relative morphs without changing shader code
// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
const morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}return{update:update};}function WebGLObjects(gl,geometries,attributes,info){let updateMap=new WeakMap();function update(object){const frame=info.render.frame;const geometry=object.geometry;const buffergeometry=geometries.get(object,geometry);// Update once per frame
if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}attributes.update(object.instanceMatrix,34962);if(object.instanceColor!==null){attributes.update(object.instanceColor,34962);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){const instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return{update:update,dispose:dispose};}class DataTexture2DArray extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null);this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture2DArray.prototype.isDataTexture2DArray=true;class DataTexture3D extends Texture{constructor(data=null,width=1,height=1,depth=1){// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	const texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839
super(null);this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture3D.prototype.isDataTexture3D=true;/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */const emptyTexture=new Texture();const emptyTexture2dArray=new DataTexture2DArray();const emptyTexture3d=new DataTexture3D();const emptyCubeTexture=new CubeTexture();// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const arrayCacheF32=[];const arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
const mat4array=new Float32Array(16);const mat3array=new Float32Array(9);const mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
function flatten(array,nBlocks,blockSize){const firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
const n=nBlocks*blockSize;let r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(let i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(let i=0,l=a.length;i<l;i++){if(a[i]!==b[i])return false;}return true;}function copyArray(a,b){for(let i=0,l=b.length;i<l;i++){a[i]=b[i];}}// Texture unit allocation
function allocTexUnits(textures,n){let r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(let i=0;i!==n;++i){r[i]=textures.allocateTextureUnit();}return r;}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else{if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else{if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){const cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else{if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
function setValueM2(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){const cache=this.cache;const elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
function setValueV1i(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array)
function setValueV2i(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}function setValueV3i(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}function setValueV4i(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}// Single unsigned integer
function setValueV1ui(gl,v){const cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array)
function setValueV2ui(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}function setValueV3ui(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}function setValueV4ui(gl,v){const cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}// Single texture (2D / Cube)
function setValueT1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTexture2D(v||emptyTexture,unit);}function setValueT3D1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||emptyTexture3d,unit);}function setValueT6(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){const cache=this.cache;const unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyTexture2dArray,unit);}// Helper to pick the right setter for the singular case
function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
case 0x8b50:return setValueV2f;// _VEC2
case 0x8b51:return setValueV3f;// _VEC3
case 0x8b52:return setValueV4f;// _VEC4
case 0x8b5a:return setValueM2;// _MAT2
case 0x8b5b:return setValueM3;// _MAT3
case 0x8b5c:return setValueM4;// _MAT4
case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
case 0x1405:return setValueV1ui;// UINT
case 0x8dc6:return setValueV2ui;// _VEC2
case 0x8dc7:return setValueV3ui;// _VEC3
case 0x8dc8:return setValueV4ui;// _VEC4
case 0x8b5e:// SAMPLER_2D
case 0x8d66:// SAMPLER_EXTERNAL_OES
case 0x8dca:// INT_SAMPLER_2D
case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
case 0x8b62:// SAMPLER_2D_SHADOW
return setValueT1;case 0x8b5f:// SAMPLER_3D
case 0x8dcb:// INT_SAMPLER_3D
case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
case 0x8dcc:// INT_SAMPLER_CUBE
case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
case 0x8dc5:// SAMPLER_CUBE_SHADOW
return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
case 0x8dcf:// INT_SAMPLER_2D_ARRAY
case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
return setValueT2DArray1;}}// Array of scalars
function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
function setValueV2fArray(gl,v){const data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){const data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){const data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
function setValueM2Array(gl,v){const data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){const data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){const data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / Cube)
function setValueT1Array(gl,v,textures){const n=v.length;const units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(let i=0;i!==n;++i){textures.safeSetTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6Array(gl,v,textures){const n=v.length;const units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(let i=0;i!==n;++i){textures.safeSetTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
case 0x8b50:return setValueV2fArray;// _VEC2
case 0x8b51:return setValueV3fArray;// _VEC3
case 0x8b52:return setValueV4fArray;// _VEC4
case 0x8b5a:return setValueM2Array;// _MAT2
case 0x8b5b:return setValueM3Array;// _MAT3
case 0x8b5c:return setValueM4Array;// _MAT4
case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
case 0x1405:return setValueV1uiArray;// UINT
case 0x8dc6:return setValueV2uiArray;// _VEC2
case 0x8dc7:return setValueV3uiArray;// _VEC3
case 0x8dc8:return setValueV4uiArray;// _VEC4
case 0x8b5e:// SAMPLER_2D
case 0x8d66:// SAMPLER_EXTERNAL_OES
case 0x8dca:// INT_SAMPLER_2D
case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
case 0x8b62:// SAMPLER_2D_SHADOW
return setValueT1Array;case 0x8b60:// SAMPLER_CUBE
case 0x8dcc:// INT_SAMPLER_CUBE
case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
case 0x8dc5:// SAMPLER_CUBE_SHADOW
return setValueT6Array;}}// --- Uniform Classes ---
function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}PureArrayUniform.prototype.updateCache=function(data){const cache=this.cache;if(data instanceof Float32Array&&cache.length!==data.length){this.cache=new Float32Array(data.length);}copyArray(cache,data);};function StructuredUniform(id){this.id=id;this.seq=[];this.map={};}StructuredUniform.prototype.setValue=function(gl,value,textures){const seq=this.seq;for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];u.setValue(gl,value[u.id],textures);}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
const RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){const path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;while(true){const match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;let id=match[1];const idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
const map=container.map;let next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
function WebGLUniforms(gl,program){this.seq=[];this.map={};const n=gl.getProgramParameter(program,35718);for(let i=0;i<n;++i){const info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value,textures){const u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);};WebGLUniforms.prototype.setOptional=function(gl,object,name){const v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
WebGLUniforms.upload=function(gl,seq,values,textures){for(let i=0,n=seq.length;i!==n;++i){const u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,textures);}}};WebGLUniforms.seqWithValue=function(seq,values){const r=[];for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];if(u.id in values)r.push(u);}return r;};function WebGLShader(gl,type,string){const shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}let programIdCount=0;function addLineNumbers(string){const lines=string.split('\n');for(let i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];case LogLuvEncoding:return['LogLuv','( value )'];default:console.warn('THREE.WebGLProgram: Unsupported encoding:',encoding);return['Linear','( value )'];}}function getShaderErrors(gl,shader,type){const status=gl.getShaderParameter(shader,35713);const log=gl.getShaderInfoLog(shader).trim();if(status&&log==='')return'';// --enable-privileged-webgl-extension
// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
const source=gl.getShaderSource(shader);return'THREE.WebGLShader: gl.getShaderInfoLog() '+type+'\n'+log+addLineNumbers(source);}function getTexelDecodingFunction(functionName,encoding){const components=getEncodingComponents(encoding);return'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';}function getTexelEncodingFunction(functionName,encoding){const components=getEncodingComponents(encoding);return'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){let toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case CustomToneMapping:toneMappingName='Custom';break;default:console.warn('THREE.WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(parameters){const chunks=[parameters.extensionDerivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==='physical'?'#extension GL_OES_standard_derivatives : enable':'',(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?'#extension GL_EXT_frag_depth : enable':'',parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?'#extension GL_EXT_draw_buffers : require':'',(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission>0.0)&&parameters.rendererExtensionShaderTextureLod?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){const chunks=[];for(const name in defines){const value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){const attributes={};const n=gl.getProgramParameter(program,35721);for(let i=0;i<n;i++){const info=gl.getActiveAttrib(program,i);const name=info.name;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}function includeReplacer(match,include){const string=ShaderChunk[include];if(string===undefined){throw new Error('Can not resolve #include <'+include+'>');}return resolveIncludes(string);}// Unroll Loops
const deprecatedUnrollLoopPattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer).replace(deprecatedUnrollLoopPattern,deprecatedLoopReplacer);}function deprecatedLoopReplacer(match,start,end,snippet){console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');return loopReplacer(match,start,end,snippet);}function loopReplacer(match,start,end,snippet){let string='';for(let i=parseInt(start);i<parseInt(end);i++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+i+' ]').replace(/UNROLLED_LOOP_INDEX/g,i);}return string;}//
function generatePrecision(parameters){let precisionstring='precision '+parameters.precision+' float;\nprecision '+parameters.precision+' int;';if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){let shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){let envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){let envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:case CubeUVRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){let envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){const gl=renderer.getContext();const defines=parameters.defines;let vertexShader=parameters.vertexShader;let fragmentShader=parameters.fragmentShader;const shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);const envMapTypeDefine=generateEnvMapTypeDefine(parameters);const envMapModeDefine=generateEnvMapModeDefine(parameters);const envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);const gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;const customExtensions=parameters.isWebGL2?'':generateExtensions(parameters);const customDefines=generateDefines(defines);const program=gl.createProgram();let prefixVertex,prefixFragment;let versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else{prefixVertex=[generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularTintMap?'#define USE_SPECULARTINTMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest+(parameters.alphaTest%1?'':'.0'):'',// add '.0' if integer
'#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularTintMap?'#define USE_SPECULARTINTMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.sheen?'#define USE_SHEEN':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'',(parameters.extensionShaderTextureLOD||parameters.envMap)&&parameters.rendererExtensionShaderTextureLod?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',ShaderChunk['encodings_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
parameters.map?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.matcap?getTexelDecodingFunction('matcapTexelToLinear',parameters.matcapEncoding):'',parameters.envMap?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMap?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.specularTintMap?getTexelDecodingFunction('specularTintMapTexelToLinear',parameters.specularTintMapEncoding):'',parameters.lightMap?getTexelDecodingFunction('lightMapTexelToLinear',parameters.lightMapEncoding):'',getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding),parameters.depthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isWebGL2&&parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
versionString='#version 300 es\n';prefixVertex=['#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}const vertexGlsl=versionString+prefixVertex+vertexShader;const fragmentGlsl=versionString+prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );
const glVertexShader=WebGLShader(gl,35633,vertexGlsl);const glFragmentShader=WebGLShader(gl,35632,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);// check for link errors
if(renderer.debug.checkShaderErrors){const programLog=gl.getProgramInfoLog(program).trim();const vertexLog=gl.getShaderInfoLog(glVertexShader).trim();const fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();let runnable=true;let haveDiagnostics=true;if(gl.getProgramParameter(program,35714)===false){runnable=false;const vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');const fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'35715',gl.getProgramParameter(program,35715),'gl.getProgramInfoLog',programLog,vertexErrors,fragmentErrors);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
// Crashes in iOS9 and iOS10. #18402
// gl.detachShader( program, glVertexShader );
// gl.detachShader( program, glFragmentShader );
gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
let cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program);}return cachedUniforms;};// set up caching for attribute locations
let cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){const programs=[];const isWebGL2=capabilities.isWebGL2;const logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;const floatVertexTextures=capabilities.floatVertexTextures;const maxVertexUniforms=capabilities.maxVertexUniforms;const vertexTextures=capabilities.vertexTextures;let precision=capabilities.precision;const shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};const parameterNames=['precision','isWebGL2','supportsVertexTextures','outputEncoding','instancing','instancingColor','map','mapEncoding','matcap','matcapEncoding','envMap','envMapMode','envMapEncoding','envMapCubeUV','lightMap','lightMapEncoding','aoMap','emissiveMap','emissiveMapEncoding','bumpMap','normalMap','objectSpaceNormalMap','tangentSpaceNormalMap','clearcoatMap','clearcoatRoughnessMap','clearcoatNormalMap','displacementMap','specularMap','specularIntensityMap','specularTintMap','specularTintMapEncoding','roughnessMap','metalnessMap','gradientMap','alphaMap','combine','vertexColors','vertexAlphas','vertexTangents','vertexUvs','uvsVertexOnly','fog','useFog','fogExp2','flatShading','sizeAttenuation','logarithmicDepthBuffer','skinning','maxBones','useVertexTexture','morphTargets','morphNormals','premultipliedAlpha','numDirLights','numPointLights','numSpotLights','numHemiLights','numRectAreaLights','numDirLightShadows','numPointLightShadows','numSpotLightShadows','shadowMapEnabled','shadowMapType','toneMapping','physicallyCorrectLights','alphaTest','doubleSided','flipSided','numClippingPlanes','numClipIntersection','depthPacking','dithering','sheen','transmission','transmissionMap','thicknessMap'];function getMaxBones(object){const skeleton=object.skeleton;const bones=skeleton.bones;if(floatVertexTextures){return 1024;}else{// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)
const nVertexUniforms=maxVertexUniforms;const nVertexMatrices=Math.floor((nVertexUniforms-20)/4);const maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map){let encoding;if(map&&map.isTexture){encoding=map.encoding;}else if(map&&map.isWebGLRenderTarget){console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');encoding=map.texture.encoding;}else{encoding=LinearEncoding;}return encoding;}function getParameters(material,lights,shadows,scene,object){const fog=scene.fog;const environment=material.isMeshStandardMaterial?scene.environment:null;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)
const maxBones=object.isSkinnedMesh?getMaxBones(object):0;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}let vertexShader,fragmentShader;if(shaderID){const shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else{vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;}const currentRenderTarget=renderer.getRenderTarget();const parameters={isWebGL2:isWebGL2,shaderID:shaderID,shaderName:material.type,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,instancing:object.isInstancedMesh===true,instancingColor:object.isInstancedMesh===true&&object.instanceColor!==null,supportsVertexTextures:vertexTextures,outputEncoding:currentRenderTarget!==null?getTextureEncodingFromMap(currentRenderTarget.texture):renderer.outputEncoding,map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map),matcap:!!material.matcap,matcapEncoding:getTextureEncodingFromMap(material.matcap),envMap:!!envMap,envMapMode:envMap&&envMap.mapping,envMapEncoding:getTextureEncodingFromMap(envMap),envMapCubeUV:!!envMap&&(envMap.mapping===CubeUVReflectionMapping||envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,lightMapEncoding:getTextureEncodingFromMap(material.lightMap),aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,tangentSpaceNormalMap:material.normalMapType===TangentSpaceNormalMap,clearcoatMap:!!material.clearcoatMap,clearcoatRoughnessMap:!!material.clearcoatRoughnessMap,clearcoatNormalMap:!!material.clearcoatNormalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,specularIntensityMap:!!material.specularIntensityMap,specularTintMap:!!material.specularTintMap,specularTintMapEncoding:getTextureEncodingFromMap(material.specularTintMap),alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,sheen:!!material.sheen,transmission:!!material.transmission,transmissionMap:!!material.transmissionMap,thicknessMap:!!material.thicknessMap,combine:material.combine,vertexTangents:!!material.normalMap&&!!object.geometry&&!!object.geometry.attributes.tangent,vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!object.geometry&&!!object.geometry.attributes.color&&object.geometry.attributes.color.itemSize===4,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.displacementMap||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularTintMap,uvsVertexOnly:!(!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatNormalMap||!!material.transmission||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularTintMap)&&!!material.displacementMap,fog:!!fog,useFog:material.fog,fogExp2:fog&&fog.isFogExp2,flatShading:!!material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:logarithmicDepthBuffer,skinning:object.isSkinnedMesh===true&&maxBones>0,maxBones:maxBones,useVertexTexture:floatVertexTextures,morphTargets:!!object.geometry&&!!object.geometry.morphAttributes.position,morphNormals:!!object.geometry&&!!object.geometry.morphAttributes.normal,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:NoToneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||extensions.has('EXT_frag_depth'),rendererExtensionDrawBuffers:isWebGL2||extensions.has('WEBGL_draw_buffers'),rendererExtensionShaderTextureLod:isWebGL2||extensions.has('EXT_shader_texture_lod'),customProgramCacheKey:material.customProgramCacheKey()};return parameters;}function getProgramCacheKey(parameters){const array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(parameters.fragmentShader);array.push(parameters.vertexShader);}if(parameters.defines!==undefined){for(const name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){for(let i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}array.push(renderer.outputEncoding);array.push(renderer.gammaFactor);}array.push(parameters.customProgramCacheKey);return array.join();}function getUniforms(material){const shaderID=shaderIDs[material.type];let uniforms;if(shaderID){const shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else{uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){let program;// Check if code has been already compiled
for(let p=0,pl=programs.length;p<pl;p++){const preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
const i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
program.destroy();}}return{getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,// Exposed for resource monitoring & error feedback via renderer.info:
programs:programs};}function WebGLProperties(){let properties=new WeakMap();function get(object){let map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return{get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(properties){const renderItems=[];let renderItemsIndex=0;const opaque=[];const transmissive=[];const transparent=[];const defaultProgram={id:-1};function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){let renderItem=renderItems[renderItemsIndex];const materialProperties=properties.get(material);if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:materialProperties.program||defaultProgram,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else{renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=materialProperties.program||defaultProgram;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else{opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else{opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
for(let i=renderItemsIndex,il=renderItems.length;i<il;i++){const renderItem=renderItems[i];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.program=null;renderItem.group=null;}}return{opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(properties){let lists=new WeakMap();function get(scene,renderCallDepth){let list;if(lists.has(scene)===false){list=new WebGLRenderList(properties);lists.set(scene,[list]);}else{if(renderCallDepth>=lists.get(scene).length){list=new WebGLRenderList(properties);lists.get(scene).push(list);}else{list=lists.get(scene)[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return{get:get,dispose:dispose};}function UniformsCache(){const lights={};return{get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new three_module_Vector3(),color:new Color()};break;case'SpotLight':uniforms={position:new three_module_Vector3(),direction:new three_module_Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new three_module_Vector3(),color:new Color(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new three_module_Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new three_module_Vector3(),halfWidth:new three_module_Vector3(),halfHeight:new three_module_Vector3()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){const lights={};return{get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}let uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
}lights[light.id]=uniforms;return uniforms;}};}let nextVersion=0;function shadowCastingLightsFirst(lightA,lightB){return(lightB.castShadow?1:0)-(lightA.castShadow?1:0);}function WebGLLights(extensions,capabilities){const cache=new UniformsCache();const shadowCache=ShadowUniformsCache();const state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let i=0;i<9;i++)state.probe.push(new three_module_Vector3());const vector3=new three_module_Vector3();const matrix4=new Matrix4();const matrix42=new Matrix4();function setup(lights){let r=0,g=0,b=0;for(let i=0;i<9;i++)state.probe[i].set(0,0,0);let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;let numDirectionalShadows=0;let numPointShadows=0;let numSpotShadows=0;lights.sort(shadowCastingLightsFirst);for(let i=0,l=lights.length;i<l;i++){const light=lights[i];const color=light.color;const intensity=light.intensity;const distance=light.distance;const shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isLightProbe){for(let j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}}else if(light.isDirectionalLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){const uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.spotShadow[spotLength]=shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;numSpotShadows++;}state.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){const uniforms=cache.get(light);// (a) intensity is the total visible light emitted
//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
// (b) intensity is the brightness of the light
uniforms.color.copy(color).multiplyScalar(intensity);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){const uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.decay;if(light.castShadow){const shadow=light.shadow;const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;shadowUniforms.shadowCameraNear=shadow.camera.near;shadowUniforms.shadowCameraFar=shadow.camera.far;state.pointShadow[pointLength]=shadowUniforms;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){const uniforms=cache.get(light);uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}if(rectAreaLength>0){if(capabilities.isWebGL2){// WebGL 2
state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else{// WebGL 1
if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else if(extensions.has('OES_texture_half_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}else{console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');}}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;const hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotShadowMatrix.length=numSpotShadows;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;state.version=nextVersion++;}}function setupView(lights,camera){let directionalLength=0;let pointLength=0;let spotLength=0;let rectAreaLength=0;let hemiLength=0;const viewMatrix=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){const uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){const uniforms=state.spot[spotLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){const uniforms=state.rectArea[rectAreaLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){const uniforms=state.point[pointLength];uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){const uniforms=state.hemi[hemiLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();hemiLength++;}}}return{setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions,capabilities){const lights=new WebGLLights(extensions,capabilities);const lightsArray=[];const shadowsArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(){lights.setup(lightsArray);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}const state={lightsArray:lightsArray,shadowsArray:shadowsArray,lights:lights};return{init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions,capabilities){let renderStates=new WeakMap();function get(scene,renderCallDepth=0){let renderState;if(renderStates.has(scene)===false){renderState=new WebGLRenderState(extensions,capabilities);renderStates.set(scene,[renderState]);}else{if(renderCallDepth>=renderStates.get(scene).length){renderState=new WebGLRenderState(extensions,capabilities);renderStates.get(scene).push(renderState);}else{renderState=renderStates.get(scene)[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return{get:get,dispose:dispose};}/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */class MeshDepthMaterial extends Material{constructor(parameters){super();this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.setValues(parameters);}copy(source){super.copy(source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}MeshDepthMaterial.prototype.isMeshDepthMaterial=true;/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */class MeshDistanceMaterial extends Material{constructor(parameters){super();this.type='MeshDistanceMaterial';this.referencePosition=new three_module_Vector3();this.nearDistance=1;this.farDistance=1000;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.setValues(parameters);}copy(source){super.copy(source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;var vsm_frag="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";var vsm_vert="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";function WebGLShadowMap(_renderer,_objects,_capabilities){let _frustum=new Frustum();const _shadowMapSize=new Vector2(),_viewportSize=new Vector2(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=_capabilities.maxTextureSize;const shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};const shadowMaterialVertical=new ShaderMaterial({defines:{SAMPLE_RATE:2.0/8.0,HALF_SAMPLE_RATE:1.0/8.0},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2()},radius:{value:4.0}},vertexShader:vsm_vert,fragmentShader:vsm_frag});const shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;const fullScreenTri=new BufferGeometry();fullScreenTri.setAttribute('position',new BufferAttribute(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));const fullScreenMesh=new three_module_Mesh(fullScreenTri,shadowMaterialVertical);const scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;const currentRenderTarget=_renderer.getRenderTarget();const activeCubeFace=_renderer.getActiveCubeFace();const activeMipmapLevel=_renderer.getActiveMipmapLevel();const _state=_renderer.state;// Set GL state for depth map.
_state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
for(let i=0,il=lights.length;i<il;i++){const light=lights[i];const shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);const shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null&&!shadow.isPointLightShadow&&this.type===VSMShadowMap){const pars={minFilter:LinearFilter,magFilter:LinearFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.camera.updateProjectionMatrix();}if(shadow.map===null){const pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}_renderer.setRenderTarget(shadow.map);_renderer.clear();const viewportCount=shadow.getViewportCount();for(let vp=0;vp<viewportCount;vp++){const viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
if(!shadow.isPointLightShadow&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}scope.needsUpdate=false;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){const geometry=_objects.update(fullScreenMesh);// vertical pass
shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.mapPass);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.map);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,geometry,material,light,shadowCameraNear,shadowCameraFar,type){let result=null;const customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else{result=light.isPointLight===true?_distanceMaterial:_depthMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
// appropriate state
const keyA=result.uuid,keyB=material.uuid;let materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}let cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else{result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){result.referencePosition.setFromMatrixPosition(light.matrixWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);const geometry=_objects.update(object);const material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k=0,kl=groups.length;k<kl;k++){const group=groups[k];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){const depthMaterial=getDepthMaterial(object,geometry,groupMaterial,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){const depthMaterial=getDepthMaterial(object,geometry,material,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,light,type);}}}function WebGLState(gl,extensions,capabilities){const isWebGL2=capabilities.isWebGL2;function ColorBuffer(){let locked=false;const color=new Vector4();let currentColorMask=null;const currentColorClear=new Vector4(0,0,0,0);return{setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
}};}function DepthBuffer(){let locked=false;let currentDepthMask=null;let currentDepthFunc=null;let currentDepthClear=null;return{setTest:function(depthTest){if(depthTest){enable(2929);}else{disable(2929);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(512);break;case AlwaysDepth:gl.depthFunc(519);break;case LessDepth:gl.depthFunc(513);break;case LessEqualDepth:gl.depthFunc(515);break;case EqualDepth:gl.depthFunc(514);break;case GreaterEqualDepth:gl.depthFunc(518);break;case GreaterDepth:gl.depthFunc(516);break;case NotEqualDepth:gl.depthFunc(517);break;default:gl.depthFunc(515);}}else{gl.depthFunc(515);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){let locked=false;let currentStencilMask=null;let currentStencilFunc=null;let currentStencilRef=null;let currentStencilFuncMask=null;let currentStencilFail=null;let currentStencilZFail=null;let currentStencilZPass=null;let currentStencilClear=null;return{setTest:function(stencilTest){if(!locked){if(stencilTest){enable(2960);}else{disable(2960);}}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
const colorBuffer=new ColorBuffer();const depthBuffer=new DepthBuffer();const stencilBuffer=new StencilBuffer();let enabledCapabilities={};let xrFramebuffer=null;let currentBoundFramebuffers={};let currentProgram=null;let currentBlendingEnabled=false;let currentBlending=null;let currentBlendEquation=null;let currentBlendSrc=null;let currentBlendDst=null;let currentBlendEquationAlpha=null;let currentBlendSrcAlpha=null;let currentBlendDstAlpha=null;let currentPremultipledAlpha=false;let currentFlipSided=null;let currentCullFace=null;let currentLineWidth=null;let currentPolygonOffsetFactor=null;let currentPolygonOffsetUnits=null;const maxTextures=gl.getParameter(35661);let lineWidthAvailable=false;let version=0;const glVersion=gl.getParameter(7938);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}let currentTextureSlot=null;let currentBoundTextures={};const scissorParam=gl.getParameter(3088);const viewportParam=gl.getParameter(2978);const currentScissor=new Vector4().fromArray(scissorParam);const currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count){const data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
const texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,10241,9728);gl.texParameteri(type,10240,9728);for(let i=0;i<count;i++){gl.texImage2D(target+i,0,6408,1,1,0,6408,5121,data);}return texture;}const emptyTextures={};emptyTextures[3553]=createTexture(3553,3553,1);emptyTextures[34067]=createTexture(34067,34069,6);// init
colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(2929);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(2884);setBlending(NoBlending);//
function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindXRFramebuffer(framebuffer){if(framebuffer!==xrFramebuffer){gl.bindFramebuffer(36160,framebuffer);xrFramebuffer=framebuffer;}}function bindFramebuffer(target,framebuffer){if(framebuffer===null&&xrFramebuffer!==null)framebuffer=xrFramebuffer;// use active XR framebuffer if available
if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;if(isWebGL2){// 36009 is equivalent to 36160
if(target===36009){currentBoundFramebuffers[36160]=framebuffer;}if(target===36160){currentBoundFramebuffers[36009]=framebuffer;}}return true;}return false;}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}const equationToGL={[AddEquation]:32774,[SubtractEquation]:32778,[ReverseSubtractEquation]:32779};if(isWebGL2){equationToGL[MinEquation]=32775;equationToGL[MaxEquation]=32776;}else{const extension=extensions.get('EXT_blend_minmax');if(extension!==null){equationToGL[MinEquation]=extension.MIN_EXT;equationToGL[MaxEquation]=extension.MAX_EXT;}}const factorToGL={[ZeroFactor]:0,[OneFactor]:1,[SrcColorFactor]:768,[SrcAlphaFactor]:770,[SrcAlphaSaturateFactor]:776,[DstColorFactor]:774,[DstAlphaFactor]:772,[OneMinusSrcColorFactor]:769,[OneMinusSrcAlphaFactor]:771,[OneMinusDstColorFactor]:775,[OneMinusDstAlphaFactor]:773};function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(3042);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(3042);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(32774);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(1,771,1,771);break;case AdditiveBlending:gl.blendFunc(1,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,0,769,771);break;case MultiplyBlending:gl.blendFuncSeparate(0,768,0,770);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else{switch(blending){case NormalBlending:gl.blendFuncSeparate(770,771,1,771);break;case AdditiveBlending:gl.blendFunc(770,1);break;case SubtractiveBlending:gl.blendFunc(0,769);break;case MultiplyBlending:gl.blendFunc(0,768);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}currentBlending=blending;currentPremultipledAlpha=null;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(2884):enable(2884);let flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);const stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(32926):disable(32926);}//
function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(2304);}else{gl.frontFace(2305);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(2884);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(1029);}else if(cullFace===CullFaceFront){gl.cullFace(1028);}else{gl.cullFace(1032);}}}else{disable(2884);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(32823);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(32823);}}function setScissorTest(scissorTest){if(scissorTest){enable(3089);}else{disable(3089);}}// texture
function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=33984+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}let boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){const boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
function reset(){// reset state
gl.disable(3042);gl.disable(2884);gl.disable(2929);gl.disable(32823);gl.disable(3089);gl.disable(2960);gl.disable(32926);gl.blendEquation(32774);gl.blendFunc(1,0);gl.blendFuncSeparate(1,0,1,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(513);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(519,0,0xffffffff);gl.stencilOp(7680,7680,7680);gl.clearStencil(0);gl.cullFace(1029);gl.frontFace(2305);gl.polygonOffset(0,0);gl.activeTexture(33984);gl.bindFramebuffer(36160,null);if(isWebGL2===true){gl.bindFramebuffer(36009,null);gl.bindFramebuffer(36008,null);}gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};xrFramebuffer=null;currentBoundFramebuffers={};currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,bindXRFramebuffer:bindXRFramebuffer,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){const isWebGL2=capabilities.isWebGL2;const maxTextures=capabilities.maxTextures;const maxCubemapSize=capabilities.maxCubemapSize;const maxTextureSize=capabilities.maxTextureSize;const maxSamples=capabilities.maxSamples;const _videoTextures=new WeakMap();let _canvas;// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
let useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'&&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
}function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
return useOffscreenCanvas?new OffscreenCanvas(width,height):document.createElementNS('http://www.w3.org/1999/xhtml','canvas');}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){let scale=1;// handle case if texture exceeds max size
if(image.width>maxSize||image.height>maxSize){scale=maxSize/Math.max(image.width,image.height);}// only perform resize if necessary
if(scale<1||needsPowerOfTwo===true){// only perform resize for certain image types
if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){const floor=needsPowerOfTwo?floorPowerOfTwo:Math.floor;const width=floor(scale*image.width);const height=floor(scale*image.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
const canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;const context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);console.warn('THREE.WebGLRenderer: Texture has been resized from ('+image.width+'x'+image.height+') to ('+width+'x'+height+').');return canvas;}else{if('data'in image){console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+image.width+'x'+image.height+').');}return image;}}return image;}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height);}function textureNeedsPowerOfTwo(texture){if(isWebGL2)return false;return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target,texture,width,height,depth=1){_gl.generateMipmap(target);const textureProperties=properties.get(texture);textureProperties.__maxMipLevel=Math.log2(Math.max(width,height,depth));}function getInternalFormat(internalFormatName,glFormat,glType){if(isWebGL2===false)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}let internalFormat=glFormat;if(glFormat===6403){if(glType===5126)internalFormat=33326;if(glType===5131)internalFormat=33325;if(glType===5121)internalFormat=33321;}if(glFormat===6407){if(glType===5126)internalFormat=34837;if(glType===5131)internalFormat=34843;if(glType===5121)internalFormat=32849;}if(glFormat===6408){if(glType===5126)internalFormat=34836;if(glType===5131)internalFormat=34842;if(glType===5121)internalFormat=32856;}if(internalFormat===33325||internalFormat===33326||internalFormat===34842||internalFormat===34836){extensions.get('EXT_color_buffer_float');}return internalFormat;}// Fallback filters for non-power-of-2 textures
function filterFallback(f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return 9728;}return 9729;}//
function onTextureDispose(event){const texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures.delete(texture);}info.memory.textures--;}function onRenderTargetDispose(event){const renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
function deallocateTexture(texture){const textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);properties.remove(texture);}function deallocateRenderTarget(renderTarget){const texture=renderTarget.texture;const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);info.memory.textures--;}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLCubeRenderTarget){for(let i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}if(renderTarget.isWebGLMultipleRenderTargets){for(let i=0,il=texture.length;i<il;i++){const attachmentProperties=properties.get(texture[i]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(texture[i]);}}properties.remove(texture);properties.remove(renderTarget);}//
let textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){const textureUnit=textureUnits;if(textureUnit>=maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+maxTextures);}textureUnits+=1;return textureUnit;}//
function setTexture2D(texture,slot){const textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.version>0&&textureProperties.__version!==texture.version){const image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(33984+slot);state.bindTexture(3553,textureProperties.__webglTexture);}function setTexture2DArray(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(35866,textureProperties.__webglTexture);}function setTexture3D(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(32879,textureProperties.__webglTexture);}function setTextureCube(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);}const wrappingToGL={[RepeatWrapping]:10497,[ClampToEdgeWrapping]:33071,[MirroredRepeatWrapping]:33648};const filterToGL={[NearestFilter]:9728,[NearestMipmapNearestFilter]:9984,[NearestMipmapLinearFilter]:9986,[LinearFilter]:9729,[LinearMipmapNearestFilter]:9985,[LinearMipmapLinearFilter]:9987};function setTextureParameters(textureType,texture,supportsMips){if(supportsMips){_gl.texParameteri(textureType,10242,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,10243,wrappingToGL[texture.wrapT]);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,10240,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,10241,filterToGL[texture.minFilter]);}else{_gl.texParameteri(textureType,10242,33071);_gl.texParameteri(textureType,10243,33071);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,33071);}if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');}_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');}}if(extensions.has('EXT_texture_filter_anisotropic')===true){const extension=extensions.get('EXT_texture_filter_anisotropic');if(texture.type===FloatType&&extensions.has('OES_texture_float_linear')===false)return;// verify extension for WebGL 1 and WebGL 2
if(isWebGL2===false&&texture.type===HalfFloatType&&extensions.has('OES_texture_half_float_linear')===false)return;// verify extension for WebGL 1 only
if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}function uploadTexture(textureProperties,texture,slot){let textureType=3553;if(texture.isDataTexture2DArray)textureType=35866;if(texture.isDataTexture3D)textureType=32879;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(textureType,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);const needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo$1(texture.image)===false;const image=resizeImage(texture.image,needsPowerOfTwo,false,maxTextureSize);const supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format);let glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);setTextureParameters(textureType,texture,supportsMips);let mipmap;const mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
glInternalFormat=6402;if(isWebGL2){if(texture.type===FloatType){glInternalFormat=36012;}else if(texture.type===UnsignedIntType){glInternalFormat=33190;}else if(texture.type===UnsignedInt248Type){glInternalFormat=35056;}else{glInternalFormat=33189;// WebGL2 requires sized internalformat for glTexImage2D
}}else{if(texture.type===FloatType){console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');}}// validation checks for WebGL 1
if(texture.format===DepthFormat&&glInternalFormat===6402){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}if(texture.format===DepthStencilFormat&&glInternalFormat===6402){// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
glInternalFormat=34041;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}//
state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&supportsMips){for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}}else if(texture.isCompressedTexture){for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else{state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}textureProperties.__maxMipLevel=mipmaps.length-1;}else if(texture.isDataTexture2DArray){state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else if(texture.isDataTexture3D){state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else{// regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&supportsMips){for(let i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(3553,i,glInternalFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);textureProperties.__maxMipLevel=0;}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(textureType,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);const isCompressed=texture&&(texture.isCompressedTexture||texture.image[0].isCompressedTexture);const isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;const cubeImage=[];for(let i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=resizeImage(texture.image[i],false,true,maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}const image=cubeImage[0],supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);setTextureParameters(34067,texture,supportsMips);let mipmaps;if(isCompressed){for(let i=0;i<6;i++){mipmaps=cubeImage[i].mipmaps;for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else{state.texImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}textureProperties.__maxMipLevel=mipmaps.length-1;}else{mipmaps=texture.mipmaps;for(let i=0;i<6;i++){if(isDataTexture){state.texImage2D(34069+i,0,glInternalFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];const mipmapImage=mipmap.image[i].image;state.texImage2D(34069+i,j+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}else{state.texImage2D(34069+i,0,glInternalFormat,glFormat,glType,cubeImage[i]);for(let j=0;j<mipmaps.length;j++){const mipmap=mipmaps[j];state.texImage2D(34069+i,j+1,glInternalFormat,glFormat,glType,mipmap.image[i]);}}}textureProperties.__maxMipLevel=mipmaps.length;}if(textureNeedsGenerateMipmaps(texture,supportsMips)){// We assume images for cube map have the same size.
generateMipmap(34067,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget){const glFormat=utils.convert(texture.format);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);if(textureTarget===32879||textureTarget===35866){state.texImage3D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,renderTarget.depth,0,glFormat,glType,null);}else{state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);}state.bindFramebuffer(36160,framebuffer);_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(texture).__webglTexture,0);state.bindFramebuffer(36160,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(36161,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){let glInternalFormat=33189;if(isMultisample){const depthTexture=renderTarget.depthTexture;if(depthTexture&&depthTexture.isDepthTexture){if(depthTexture.type===FloatType){glInternalFormat=36012;}else if(depthTexture.type===UnsignedIntType){glInternalFormat=33190;}}const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){if(isMultisample){const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,35056,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);}else{// Use the first texture for MRT so far
const texture=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture[0]:renderTarget.texture;const glFormat=utils.convert(texture.format);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);if(isMultisample){const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}}_gl.bindRenderbuffer(36161,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){const isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(36160,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);const webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){const renderTargetProperties=properties.get(renderTarget);const isCube=renderTarget.isWebGLCubeRenderTarget===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(let i=0;i<6;i++){state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget,false);}}else{state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}}state.bindFramebuffer(36160,null);}// Set up GL resources for the render target
function setupRenderTarget(renderTarget){const texture=renderTarget.texture;const renderTargetProperties=properties.get(renderTarget);const textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);if(renderTarget.isWebGLMultipleRenderTargets!==true){textureProperties.__webglTexture=_gl.createTexture();textureProperties.__version=texture.version;info.memory.textures++;}const isCube=renderTarget.isWebGLCubeRenderTarget===true;const isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===true;const isMultisample=renderTarget.isWebGLMultisampleRenderTarget===true;const isRenderTarget3D=texture.isDataTexture3D||texture.isDataTexture2DArray;const supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;// Handles WebGL2 RGBFormat fallback - #18858
if(isWebGL2&&texture.format===RGBFormat&&(texture.type===FloatType||texture.type===HalfFloatType)){texture.format=RGBAFormat;console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');}// Setup framebuffer
if(isCube){renderTargetProperties.__webglFramebuffer=[];for(let i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultipleRenderTargets){if(capabilities.drawBuffers){const textures=renderTarget.texture;for(let i=0,il=textures.length;i<il;i++){const attachmentProperties=properties.get(textures[i]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}else{console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');}}else if(isMultisample){if(isWebGL2){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=_gl.createRenderbuffer();_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer);const glFormat=utils.convert(texture.format);const glType=utils.convert(texture.type);const glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);const samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064,36161,renderTargetProperties.__webglColorRenderbuffer);_gl.bindRenderbuffer(36161,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(36160,null);}else{console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}// Setup color buffer
if(isCube){state.bindTexture(34067,textureProperties.__webglTexture);setTextureParameters(34067,texture,supportsMips);for(let i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,texture,36064,34069+i);}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(34067,texture,renderTarget.width,renderTarget.height);}state.bindTexture(34067,null);}else if(isMultipleRenderTargets){const textures=renderTarget.texture;for(let i=0,il=textures.length;i<il;i++){const attachment=textures[i];const attachmentProperties=properties.get(attachment);state.bindTexture(3553,attachmentProperties.__webglTexture);setTextureParameters(3553,attachment,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,36064+i,3553);if(textureNeedsGenerateMipmaps(attachment,supportsMips)){generateMipmap(3553,attachment,renderTarget.width,renderTarget.height);}}state.bindTexture(3553,null);}else{let glTextureType=3553;if(isRenderTarget3D){// Render targets containing layers, i.e: Texture 3D and 2d arrays
if(isWebGL2){const isTexture3D=texture.isDataTexture3D;glTextureType=isTexture3D?32879:35866;}else{console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');}}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,36064,glTextureType);if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(glTextureType,texture,renderTarget.width,renderTarget.height,renderTarget.depth);}state.bindTexture(glTextureType,null);}// Setup depth and stencil buffers
if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){const supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;const textures=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture:[renderTarget.texture];for(let i=0,il=textures.length;i<il;i++){const texture=textures[i];if(textureNeedsGenerateMipmaps(texture,supportsMips)){const target=renderTarget.isWebGLCubeRenderTarget?34067:3553;const webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target,texture,renderTarget.width,renderTarget.height);state.bindTexture(target,null);}}}function updateMultisampleRenderTarget(renderTarget){if(renderTarget.isWebGLMultisampleRenderTarget){if(isWebGL2){const width=renderTarget.width;const height=renderTarget.height;let mask=16384;if(renderTarget.depthBuffer)mask|=256;if(renderTarget.stencilBuffer)mask|=1024;const renderTargetProperties=properties.get(renderTarget);state.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,renderTargetProperties.__webglMultisampledFramebuffer);}else{console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}function getRenderTargetSamples(renderTarget){return isWebGL2&&renderTarget.isWebGLMultisampleRenderTarget?Math.min(maxSamples,renderTarget.samples):0;}function updateVideoTexture(texture){const frame=info.render.frame;// Check the last frame we updated the VideoTexture
if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}// backwards compatibility
let warnedTexture2D=false;let warnedTextureCube=false;function safeSetTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(warnedTexture2D===false){console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');warnedTexture2D=true;}texture=texture.texture;}setTexture2D(texture,slot);}function safeSetTextureCube(texture,slot){if(texture&&texture.isWebGLCubeRenderTarget){if(warnedTextureCube===false){console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');warnedTextureCube=true;}texture=texture.texture;}setTextureCube(texture,slot);}//
this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.safeSetTexture2D=safeSetTexture2D;this.safeSetTextureCube=safeSetTextureCube;}function WebGLUtils(gl,extensions,capabilities){const isWebGL2=capabilities.isWebGL2;function convert(p){let extension;if(p===UnsignedByteType)return 5121;if(p===UnsignedShort4444Type)return 32819;if(p===UnsignedShort5551Type)return 32820;if(p===UnsignedShort565Type)return 33635;if(p===ByteType)return 5120;if(p===ShortType)return 5122;if(p===UnsignedShortType)return 5123;if(p===IntType)return 5124;if(p===UnsignedIntType)return 5125;if(p===FloatType)return 5126;if(p===HalfFloatType){if(isWebGL2)return 5131;extension=extensions.get('OES_texture_half_float');if(extension!==null){return extension.HALF_FLOAT_OES;}else{return null;}}if(p===AlphaFormat)return 6406;if(p===RGBFormat)return 6407;if(p===RGBAFormat)return 6408;if(p===LuminanceFormat)return 6409;if(p===LuminanceAlphaFormat)return 6410;if(p===DepthFormat)return 6402;if(p===DepthStencilFormat)return 34041;if(p===RedFormat)return 6403;// WebGL2 formats.
if(p===RedIntegerFormat)return 36244;if(p===RGFormat)return 33319;if(p===RGIntegerFormat)return 33320;if(p===RGBIntegerFormat)return 36248;if(p===RGBAIntegerFormat)return 36249;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else{return null;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else{return null;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null){return extension.COMPRESSED_RGB_ETC1_WEBGL;}else{return null;}}if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC2_Format)return extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return extension.COMPRESSED_RGBA8_ETC2_EAC;}}if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format||p===SRGB8_ALPHA8_ASTC_4x4_Format||p===SRGB8_ALPHA8_ASTC_5x4_Format||p===SRGB8_ALPHA8_ASTC_5x5_Format||p===SRGB8_ALPHA8_ASTC_6x5_Format||p===SRGB8_ALPHA8_ASTC_6x6_Format||p===SRGB8_ALPHA8_ASTC_8x5_Format||p===SRGB8_ALPHA8_ASTC_8x6_Format||p===SRGB8_ALPHA8_ASTC_8x8_Format||p===SRGB8_ALPHA8_ASTC_10x5_Format||p===SRGB8_ALPHA8_ASTC_10x6_Format||p===SRGB8_ALPHA8_ASTC_10x8_Format||p===SRGB8_ALPHA8_ASTC_10x10_Format||p===SRGB8_ALPHA8_ASTC_12x10_Format||p===SRGB8_ALPHA8_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){// TODO Complete?
return p;}else{return null;}}if(p===RGBA_BPTC_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){// TODO Complete?
return p;}else{return null;}}if(p===UnsignedInt248Type){if(isWebGL2)return 34042;extension=extensions.get('WEBGL_depth_texture');if(extension!==null){return extension.UNSIGNED_INT_24_8_WEBGL;}else{return null;}}}return{convert:convert};}class ArrayCamera extends PerspectiveCamera{constructor(array=[]){super();this.cameras=array;}}ArrayCamera.prototype.isArrayCamera=true;class Group extends Object3D{constructor(){super();this.type='Group';}}Group.prototype.isGroup=true;const _moveEvent={type:'move'};class WebXRController{constructor(){this._targetRay=null;this._grip=null;this._hand=null;}getHandSpace(){if(this._hand===null){this._hand=new Group();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new three_module_Vector3();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new three_module_Vector3();}return this._targetRay;}getGripSpace(){if(this._grip===null){this._grip=new Group();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new three_module_Vector3();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new three_module_Vector3();}return this._grip;}dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}update(inputSource,frame,referenceSpace){let inputPose=null;let gripPose=null;let handPose=null;const targetRay=this._targetRay;const grip=this._grip;const hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else{targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else{targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}if(hand&&inputSource.hand){handPose=true;for(const inputjoint of inputSource.hand.values()){// Update the joints groups with the XRJoint poses
const jointPose=frame.getJointPose(inputjoint,referenceSpace);if(hand.joints[inputjoint.jointName]===undefined){// The transform of this joint will be updated with the joint pose on each frame
const joint=new Group();joint.matrixAutoUpdate=false;joint.visible=false;hand.joints[inputjoint.jointName]=joint;// ??
hand.add(joint);}const joint=hand.joints[inputjoint.jointName];if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
// Check pinchz
const indexTip=hand.joints['index-finger-tip'];const thumbTip=hand.joints['thumb-tip'];const distance=indexTip.position.distanceTo(thumbTip.position);const distanceToPinch=0.02;const threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else{if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else{grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else{grip.hasAngularVelocity=false;}}}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}}class WebXRManager extends EventDispatcher{constructor(renderer,gl){super();const scope=this;const state=renderer.state;let session=null;let framebufferScaleFactor=1.0;let referenceSpace=null;let referenceSpaceType='local-floor';let pose=null;let glBinding=null;let glFramebuffer=null;let glProjLayer=null;let glBaseLayer=null;const controllers=[];const inputSourcesMap=new Map();//
const cameraL=new PerspectiveCamera();cameraL.layers.enable(1);cameraL.viewport=new Vector4();const cameraR=new PerspectiveCamera();cameraR.layers.enable(2);cameraR.viewport=new Vector4();const cameras=[cameraL,cameraR];const cameraVR=new ArrayCamera();cameraVR.layers.enable(1);cameraVR.layers.enable(2);let _currentDepthNear=null;let _currentDepthFar=null;//
this.cameraAutoUpdate=true;this.enabled=false;this.isPresenting=false;this.getController=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};this.getControllerGrip=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};this.getHand=function(index){let controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
function onSessionEvent(event){const controller=inputSourcesMap.get(event.inputSource);if(controller){controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){inputSourcesMap.forEach(function(controller,inputSource){controller.disconnect(inputSource);});inputSourcesMap.clear();_currentDepthNear=null;_currentDepthFar=null;// restore framebuffer/rendering state
state.bindXRFramebuffer(null);renderer.setRenderTarget(renderer.getRenderTarget());//
animation.stop();scope.isPresenting=false;scope.dispatchEvent({type:'sessionend'});}this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');}};this.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');}};this.getReferenceSpace=function(){return referenceSpace;};this.getSession=function(){return session;};this.setSession=async function(value){session=value;if(session!==null){session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);const attributes=gl.getContextAttributes();if(attributes.xrCompatible!==true){await gl.makeXRCompatible();}if(session.renderState.layers===undefined){const layerInit={antialias:attributes.antialias,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});}else{let depthFormat=0;// for anti-aliased output, use classic webgllayer for now
if(attributes.antialias){const layerInit={antialias:true,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({layers:[glBaseLayer]});}else{if(attributes.depth){depthFormat=attributes.stencil?34041:6402;}const projectionlayerInit={colorFormat:attributes.alpha?6408:6407,depthFormat:depthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);glFramebuffer=gl.createFramebuffer();session.updateRenderState({layers:[glProjLayer]});}}referenceSpace=await session.requestReferenceSpace(referenceSpaceType);animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});}};function onInputSourcesChange(event){const inputSources=session.inputSources;// Assign inputSources to available controllers
for(let i=0;i<controllers.length;i++){inputSourcesMap.set(inputSources[i],controllers[i]);}// Notify disconnected
for(let i=0;i<event.removed.length;i++){const inputSource=event.removed[i];const controller=inputSourcesMap.get(inputSource);if(controller){controller.dispatchEvent({type:'disconnected',data:inputSource});inputSourcesMap.delete(inputSource);}}// Notify connected
for(let i=0;i<event.added.length;i++){const inputSource=event.added[i];const controller=inputSourcesMap.get(inputSource);if(controller){controller.dispatchEvent({type:'connected',data:inputSource});}}}//
const cameraLPos=new three_module_Vector3();const cameraRPos=new three_module_Vector3();/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);const ipd=cameraLPos.distanceTo(cameraRPos);const projL=cameraL.projectionMatrix.elements;const projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
// most likely identical top and bottom frustum extents.
// Use the left camera for these values.
const near=projL[14]/(projL[10]-1);const far=projL[14]/(projL[10]+1);const topFov=(projL[9]+1)/projL[5];const bottomFov=(projL[9]-1)/projL[5];const leftFov=(projL[8]-1)/projL[0];const rightFov=(projR[8]+1)/projR[0];const left=near*leftFov;const right=near*rightFov;// Calculate the new camera's position offset from the
// left camera. xOffset should be roughly half `ipd`.
const zOffset=ipd/(-leftFov+rightFov);const xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
const near2=near+zOffset;const far2=far+zOffset;const left2=left-xOffset;const right2=right+(ipd-xOffset);const top2=topFov*far/far2*near2;const bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else{camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}this.updateCamera=function(camera){if(session===null)return;cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far){// Note that the new renderState won't apply until the next frame. See #18320
session.updateRenderState({depthNear:cameraVR.near,depthFar:cameraVR.far});_currentDepthNear=cameraVR.near;_currentDepthFar=cameraVR.far;}const parent=camera.parent;const cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(let i=0;i<cameras.length;i++){updateCamera(cameras[i],parent);}cameraVR.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);// update user camera and its children
camera.position.copy(cameraVR.position);camera.quaternion.copy(cameraVR.quaternion);camera.scale.copy(cameraVR.scale);camera.matrix.copy(cameraVR.matrix);camera.matrixWorld.copy(cameraVR.matrixWorld);const children=camera.children;for(let i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(true);}// update projection matrix for proper view frustum culling
if(cameras.length===2){setProjectionFromUnion(cameraVR,cameraL,cameraR);}else{// assume single camera setup (AR)
cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);}};this.getCamera=function(){return cameraVR;};this.getFoveation=function(){if(glProjLayer!==null){return glProjLayer.fixedFoveation;}if(glBaseLayer!==null){return glBaseLayer.fixedFoveation;}return undefined;};this.setFoveation=function(foveation){// 0 = no foveation = full resolution
// 1 = maximum foveation = the edges render at lower resolution
if(glProjLayer!==null){glProjLayer.fixedFoveation=foveation;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=foveation;}};// Animation Loop
let onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(referenceSpace);if(pose!==null){const views=pose.views;if(glBaseLayer!==null){state.bindXRFramebuffer(glBaseLayer.framebuffer);}let cameraVRNeedsUpdate=false;// check if it's necessary to rebuild cameraVR's camera list
if(views.length!==cameraVR.cameras.length){cameraVR.cameras.length=0;cameraVRNeedsUpdate=true;}for(let i=0;i<views.length;i++){const view=views[i];let viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else{const glSubImage=glBinding.getViewSubImage(glProjLayer,view);state.bindXRFramebuffer(glFramebuffer);if(glSubImage.depthStencilTexture!==undefined){gl.framebufferTexture2D(36160,36096,3553,glSubImage.depthStencilTexture,0);}gl.framebufferTexture2D(36160,36064,3553,glSubImage.colorTexture,0);viewport=glSubImage.viewport;}const camera=cameras[i];camera.matrix.fromArray(view.transform.matrix);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(i===0){cameraVR.matrix.copy(camera.matrix);}if(cameraVRNeedsUpdate===true){cameraVR.cameras.push(camera);}}}//
const inputSources=session.inputSources;for(let i=0;i<controllers.length;i++){const controller=controllers[i];const inputSource=inputSources[i];controller.update(inputSource,frame,referenceSpace);}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};this.dispose=function(){};}}function WebGLMaterials(properties){function refreshFogUniforms(uniforms,fog){uniforms.fogColor.value.copy(fog.color);if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsLambert(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}else{refreshUniformsStandard(uniforms,material);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDepth(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsNormal(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
}}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}const envMap=properties.get(material).envMap;if(envMap){uniforms.envMap.value=envMap;uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;const maxMipLevel=properties.get(envMap).__maxMipLevel;if(maxMipLevel!==undefined){uniforms.maxMipLevel.value=maxMipLevel;}}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. displacementMap map
// 4. normal map
// 5. bump map
// 6. roughnessMap map
// 7. metalnessMap map
// 8. alphaMap map
// 9. emissiveMap map
// 10. clearcoat map
// 11. clearcoat normal map
// 12. clearcoat roughnessMap map
// 13. specular intensity map
// 14. specular tint map
let uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}else if(material.clearcoatMap){uvScaleMap=material.clearcoatMap;}else if(material.clearcoatNormalMap){uvScaleMap=material.clearcoatNormalMap;}else if(material.clearcoatRoughnessMap){uvScaleMap=material.clearcoatRoughnessMap;}else if(material.specularIntensityMap){uvScaleMap=material.specularIntensityMap;}else if(material.specularTintMap){uvScaleMap=material.specularTintMap;}if(uvScaleMap!==undefined){// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}// uv repeat and offset setting priorities for uv2
// 1. ao map
// 2. light map
let uv2ScaleMap;if(material.aoMap){uv2ScaleMap=material.aoMap;}else if(material.lightMap){uv2ScaleMap=material.lightMap;}if(uv2ScaleMap!==undefined){// backwards compatibility
if(uv2ScaleMap.isWebGLRenderTarget){uv2ScaleMap=uv2ScaleMap.texture;}if(uv2ScaleMap.matrixAutoUpdate===true){uv2ScaleMap.updateMatrix();}uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}// uv repeat and offset setting priorities
// 1. color map
// 2. alpha map
let uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}// uv repeat and offset setting priorities
// 1. color map
// 2. alpha map
let uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}const envMap=properties.get(material).envMap;if(envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){refreshUniformsStandard(uniforms,material);uniforms.reflectivity.value=material.reflectivity;// also part of uniforms common
uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.sheen)uniforms.sheen.value.copy(material.sheen);if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;}if(material.clearcoatNormalMap){uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}uniforms.transmission.value=material.transmission;if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;}if(material.transmission>0.0){uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationTint.value.copy(material.attenuationTint);uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularTint.value.copy(material.specularTint);if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;}if(material.specularTintMap){uniforms.specularTintMap.value=material.specularTintMap;}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}return{refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function createCanvasElement(){const canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.style.display='block';return canvas;}function WebGLRenderer(parameters={}){const _canvas=parameters.canvas!==undefined?parameters.canvas:createCanvasElement(),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;let currentRenderList=null;let currentRenderState=null;// render() can be called from within a callback triggered by another render.
// We track this so that the nested render call gets its list and state isolated from the parent render call.
const renderListStack=[];const renderStateStack=[];// public properties
this.domElement=_canvas;// Debug configuration container
this.debug={/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */checkShaderErrors:true};// clearing
this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
this.sortObjects=true;// user-defined clipping
this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
this.gammaFactor=2.0;// for backwards compatibility
this.outputEncoding=LinearEncoding;// physical lights
this.physicallyCorrectLights=false;// tone mapping
this.toneMapping=NoToneMapping;this.toneMappingExposure=1.0;// internal properties
const _this=this;let _isContextLost=false;// internal state cache
let _currentActiveCubeFace=0;let _currentActiveMipmapLevel=0;let _currentRenderTarget=null;let _currentMaterialId=-1;let _currentCamera=null;const _currentViewport=new Vector4();const _currentScissor=new Vector4();let _currentScissorTest=null;//
let _width=_canvas.width;let _height=_canvas.height;let _pixelRatio=1;let _opaqueSort=null;let _transparentSort=null;const _viewport=new Vector4(0,0,_width,_height);const _scissor=new Vector4(0,0,_width,_height);let _scissorTest=false;//
const _currentDrawBuffers=[];// frustum
const _frustum=new Frustum();// clipping
let _clippingEnabled=false;let _localClippingEnabled=false;// transmission
let _transmissionRenderTarget=null;// camera matrices cache
const _projScreenMatrix=new Matrix4();const _vector3=new three_module_Vector3();const _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
let _gl=_context;function getContext(contextNames,contextAttributes){for(let i=0;i<contextNames.length;i++){const contextName=contextNames[i];const context=_canvas.getContext(contextName,contextAttributes);if(context!==null)return context;}return null;}try{const contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat};// event listeners must be registered before WebGL context is created, see #12753
_canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);if(_gl===null){const contextNames=['webgl2','webgl','experimental-webgl'];if(_this.isWebGL1Renderer===true){contextNames.shift();}_gl=getContext(contextNames,contextAttributes);if(_gl===null){if(getContext(contextNames)){throw new Error('Error creating WebGL context with your selected attributes.');}else{throw new Error('Error creating WebGL context.');}}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}let extensions,capabilities,state,info;let properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;let programCache,materials,renderLists,renderStates,clipping,shadowMap;let background,morphtargets,bufferRenderer,indexedBufferRenderer;let utils,bindingStates;function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters);extensions.init(capabilities);utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);_currentDrawBuffers[0]=1029;info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl,capabilities);bindingStates=new WebGLBindingStates(_gl,extensions,attributes,capabilities);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(properties);renderLists=new WebGLRenderLists(properties);renderStates=new WebGLRenderStates(extensions,capabilities);background=new WebGLBackground(_this,cubemaps,state,objects,_premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=state;_this.info=info;}initGLContext();// xr
const xr=new WebXRManager(_this,_gl);this.xr=xr;// API
this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){const extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){return target.set(_width,_height);};this.setSize=function(width,height,updateStyle){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=Math.floor(width*_pixelRatio);_canvas.height=Math.floor(height*_pixelRatio);if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else{_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else{_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
this.getClearColor=function(target){return target.copy(background.getClearColor());};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){let bits=0;if(color===undefined||color)bits|=16384;if(depth===undefined||depth)bits|=256;if(stencil===undefined||stencil)bits|=1024;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);if(_transmissionRenderTarget){_transmissionRenderTarget.dispose();_transmissionRenderTarget=null;}animation.stop();};// Events
function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore(/* event */){console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;const infoAutoReset=info.autoReset;const shadowMapEnabled=shadowMap.enabled;const shadowMapAutoUpdate=shadowMap.autoUpdate;const shadowMapNeedsUpdate=shadowMap.needsUpdate;const shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onMaterialDispose(event){const material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){const programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});}}// Buffer rendering
function renderObjectImmediate(object,program){object.render(function(object){_this.renderBufferImmediate(object,program);});}this.renderBufferImmediate=function(object,program){bindingStates.initAttributes();const buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();const programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(34962,buffers.position);_gl.bufferData(34962,object.positionArray,35048);bindingStates.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,5126,false,0,0);}if(object.hasNormals){_gl.bindBuffer(34962,buffers.normal);_gl.bufferData(34962,object.normalArray,35048);bindingStates.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,5126,false,0,0);}if(object.hasUvs){_gl.bindBuffer(34962,buffers.uv);_gl.bufferData(34962,object.uvArray,35048);bindingStates.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(programAttributes.uv,2,5126,false,0,0);}if(object.hasColors){_gl.bindBuffer(34962,buffers.color);_gl.bufferData(34962,object.colorArray,35048);bindingStates.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,5126,false,0,0);}bindingStates.disableUnusedAttributes();_gl.drawArrays(4,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
const frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;const program=setProgram(camera,scene,material,object);state.setMaterial(material,frontFaceCW);//
let index=geometry.index;const position=geometry.attributes.position;//
if(index===null){if(position===undefined||position.count===0)return;}else if(index.count===0){return;}//
let rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}if(geometry.morphAttributes.position!==undefined||geometry.morphAttributes.normal!==undefined){morphtargets.update(object,geometry,material,program);}bindingStates.setup(object,material,program,geometry,index);let attribute;let renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
const dataCount=index!==null?index.count:position.count;const rangeStart=geometry.drawRange.start*rangeFactor;const rangeCount=geometry.drawRange.count*rangeFactor;const groupStart=group!==null?group.start*rangeFactor:0;const groupCount=group!==null?group.count*rangeFactor:Infinity;const drawStart=Math.max(rangeStart,groupStart);const drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;const drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(1);}else{renderer.setMode(4);}}else if(object.isLine){let lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(1);}else if(object.isLineLoop){renderer.setMode(2);}else{renderer.setMode(3);}}else if(object.isPoints){renderer.setMode(0);}else if(object.isSprite){renderer.setMode(4);}if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){const instanceCount=Math.min(geometry.instanceCount,geometry._maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else{renderer.render(drawStart,drawCount);}};// Compile
this.compile=function(scene,camera){currentRenderState=renderStates.get(scene);currentRenderState.init();renderStateStack.push(currentRenderState);scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights();scene.traverse(function(object){const material=object.material;if(material){if(Array.isArray(material)){for(let i=0;i<material.length;i++){const material2=material[i];getProgram(material2,scene,object);}}else{getProgram(material,scene,object);}}});renderStateStack.pop();currentRenderState=null;};// Animation Loop
let onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}const animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof window!=='undefined')animation.setContext(window);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
if(camera.parent===null)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
}//
if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init();renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}//
if(_clippingEnabled===true)clipping.beginShadows();const shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);currentRenderState.setupLights();currentRenderState.setupLightsView(camera);if(_clippingEnabled===true)clipping.endShadows();//
if(this.info.autoReset===true)this.info.reset();//
background.render(currentRenderList,scene);// render scene
const opaqueObjects=currentRenderList.opaque;const transmissiveObjects=currentRenderList.transmissive;const transparentObjects=currentRenderList.transparent;if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderTransmissiveObjects(opaqueObjects,transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);//
if(_currentRenderTarget!==null){// resolve multisample renderbuffers to a single-sample texture if necessary
textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
textures.updateRenderTargetMipmap(_currentRenderTarget);}//
if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);// _gl.finish();
bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];}else{currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else{currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;const visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}const geometry=objects.update(object);const material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,groupOrder,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){// update skeleton only once in a frame
if(object.skeleton.frame!==info.render.frame){object.skeleton.update();object.skeleton.frame=info.render.frame;}}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}const geometry=objects.update(object);const material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];const groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}}const children=object.children;for(let i=0,l=children.length;i<l;i++){projectObject(children[i],camera,groupOrder,sortObjects);}}function renderTransmissiveObjects(opaqueObjects,transmissiveObjects,scene,camera){if(_transmissionRenderTarget===null){const needsAntialias=_antialias===true&&capabilities.isWebGL2===true;const renderTargetType=needsAntialias?WebGLMultisampleRenderTarget:WebGLRenderTarget;_transmissionRenderTarget=new renderTargetType(1024,1024,{generateMipmaps:true,type:utils.convert(HalfFloatType)!==null?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,magFilter:NearestFilter,wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping});}const currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(_transmissionRenderTarget);_this.clear();// Turn off the features which can affect the frag color for opaque objects pass.
// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
const currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;renderObjects(opaqueObjects,scene,camera);_this.toneMapping=currentToneMapping;textures.updateMultisampleRenderTarget(_transmissionRenderTarget);textures.updateRenderTargetMipmap(_transmissionRenderTarget);_this.setRenderTarget(currentRenderTarget);renderObjects(transmissiveObjects,scene,camera);}function renderObjects(renderList,scene,camera){const overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;if(camera.isArrayCamera){const cameras=camera.cameras;for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];state.viewport(_currentViewport.copy(camera2.viewport));currentRenderState.setupLightsView(camera2);for(let j=0,jl=renderList.length;j<jl;j++){const renderItem=renderList[j];const object=renderItem.object;const geometry=renderItem.geometry;const material=overrideMaterial===null?renderItem.material:overrideMaterial;const group=renderItem.group;if(object.layers.test(camera2.layers)){renderObject(object,scene,camera2,geometry,material,group);}}}}else{for(let j=0,jl=renderList.length;j<jl;j++){const renderItem=renderList[j];const object=renderItem.object;const geometry=renderItem.geometry;const material=overrideMaterial===null?renderItem.material:overrideMaterial;const group=renderItem.group;renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){const program=setProgram(camera,scene,material,object);state.setMaterial(material);bindingStates.reset();renderObjectImmediate(object,program);}else{if(material.transparent===true&&material.side===DoubleSide){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide;}else{_this.renderBufferDirect(camera,scene,geometry,material,object,group);}}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;const shadowsArray=currentRenderState.state.shadowsArray;const lightsStateVersion=lights.state.version;const parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);const programCacheKey=programCache.getProgramCacheKey(parameters);let programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);if(programs===undefined){// new material
material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}let program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else{parameters.uniforms=programCache.getUniforms(material);material.onBuild(parameters,_this);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}const uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
}const progUniforms=program.getUniforms();const uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.currentProgram=program;materialProperties.uniformsList=uniformsList;return program;}function updateCommonMaterialProperties(material,parameters){const materialProperties=properties.get(material);materialProperties.outputEncoding=parameters.outputEncoding;materialProperties.instancing=parameters.instancing;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;}function setProgram(camera,scene,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
textures.resetTextureUnits();const fog=scene.fog;const environment=material.isMeshStandardMaterial?scene.environment:null;const encoding=_currentRenderTarget===null?_this.outputEncoding:_currentRenderTarget.texture.encoding;const envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);const vertexAlphas=material.vertexColors===true&&!!object.geometry&&!!object.geometry.attributes.color&&object.geometry.attributes.color.itemSize===4;const vertexTangents=!!object.geometry&&!!object.geometry.attributes.tangent;const morphTargets=!!object.geometry&&!!object.geometry.morphAttributes.position;const morphNormals=!!object.geometry&&!!object.geometry.morphAttributes.normal;const materialProperties=properties.get(material);const lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){const useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
clipping.setState(material,camera,useCache);}}//
let needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputEncoding!==encoding){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}}else{needsProgramChange=true;materialProperties.__version=material.version;}//
let program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}let refreshProgram=false;let refreshMaterial=false;let refreshLights=false;const p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done
}// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshStandardMaterial||material.envMap){const uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.isShadowMaterial||object.isSkinnedMesh){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// otherwise textures used for skinning can take over texture units reserved for other material textures
if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');const skeleton=object.skeleton;if(skeleton){if(capabilities.floatVertexTextures){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
if(fog&&material.fog){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,_transmissionRenderTarget);WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget,activeCubeFace=0,activeMipmapLevel=0){_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}let framebuffer=null;let isCube=false;let isRenderTarget3D=false;if(renderTarget){const texture=renderTarget.texture;if(texture.isDataTexture3D||texture.isDataTexture2DArray){isRenderTarget3D=true;}const __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){framebuffer=__webglFramebuffer[activeCubeFace];isCube=true;}else if(renderTarget.isWebGLMultisampleRenderTarget){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else{framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else{_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}const framebufferBound=state.bindFramebuffer(36160,framebuffer);if(framebufferBound&&capabilities.drawBuffers){let needsUpdate=false;if(renderTarget){if(renderTarget.isWebGLMultipleRenderTargets){const textures=renderTarget.texture;if(_currentDrawBuffers.length!==textures.length||_currentDrawBuffers[0]!==36064){for(let i=0,il=textures.length;i<il;i++){_currentDrawBuffers[i]=36064+i;}_currentDrawBuffers.length=textures.length;needsUpdate=true;}}else{if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==36064){_currentDrawBuffers[0]=36064;_currentDrawBuffers.length=1;needsUpdate=true;}}}else{if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==1029){_currentDrawBuffers[0]=1029;_currentDrawBuffers.length=1;needsUpdate=true;}}if(needsUpdate){if(capabilities.isWebGL2){_gl.drawBuffers(_currentDrawBuffers);}else{extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);}}}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){const textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(36160,36064,34069+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){const textureProperties=properties.get(renderTarget.texture);const layer=activeCubeFace||0;_gl.framebufferTextureLayer(36160,36064,textureProperties.__webglTexture,activeMipmapLevel||0,layer);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(36160,framebuffer);try{const texture=renderTarget.texture;const textureFormat=texture.format;const textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}const halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||capabilities.isWebGL2&&extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(capabilities.isWebGL2||extensions.has('OES_texture_float')||extensions.has('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!halfFloatSupportedByExt){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(36160)===36053){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{// restore framebuffer of current render target if necessary
const framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(36160,framebuffer);}}};this.copyFramebufferToTexture=function(position,texture,level=0){const levelScale=Math.pow(2,-level);const width=Math.floor(texture.image.width*levelScale);const height=Math.floor(texture.image.height*levelScale);let glFormat=utils.convert(texture.format);if(capabilities.isWebGL2){// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
// Not needed in Chrome 93+
if(glFormat===6407)glFormat=32849;if(glFormat===6408)glFormat=32856;}textures.setTexture2D(texture,0);_gl.copyTexImage2D(3553,level,glFormat,position.x,position.y,width,height,0);state.unbindTexture();};this.copyTextureToTexture=function(position,srcTexture,dstTexture,level=0){const width=srcTexture.image.width;const height=srcTexture.image.height;const glFormat=utils.convert(dstTexture.format);const glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);// As another texture upload may have changed pixelStorei
// parameters, make sure they are correct for the dstTexture
_gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);if(srcTexture.isDataTexture){_gl.texSubImage2D(3553,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);}else{if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(3553,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data);}else{_gl.texSubImage2D(3553,level,position.x,position.y,glFormat,glType,srcTexture.image);}}// Generate mipmaps only when copying level 0
if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(3553);state.unbindTexture();};this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture,level=0){if(_this.isWebGL1Renderer){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');return;}const width=sourceBox.max.x-sourceBox.min.x+1;const height=sourceBox.max.y-sourceBox.min.y+1;const depth=sourceBox.max.z-sourceBox.min.z+1;const glFormat=utils.convert(dstTexture.format);const glType=utils.convert(dstTexture.type);let glTarget;if(dstTexture.isDataTexture3D){textures.setTexture3D(dstTexture,0);glTarget=32879;}else if(dstTexture.isDataTexture2DArray){textures.setTexture2DArray(dstTexture,0);glTarget=35866;}else{console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');return;}_gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);const unpackRowLen=_gl.getParameter(3314);const unpackImageHeight=_gl.getParameter(32878);const unpackSkipPixels=_gl.getParameter(3316);const unpackSkipRows=_gl.getParameter(3315);const unpackSkipImages=_gl.getParameter(32877);const image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(3314,image.width);_gl.pixelStorei(32878,image.height);_gl.pixelStorei(3316,sourceBox.min.x);_gl.pixelStorei(3315,sourceBox.min.y);_gl.pixelStorei(32877,sourceBox.min.z);if(srcTexture.isDataTexture||srcTexture.isDataTexture3D){_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image.data);}else{if(srcTexture.isCompressedTexture){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,image.data);}else{_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image);}}_gl.pixelStorei(3314,unpackRowLen);_gl.pixelStorei(32878,unpackImageHeight);_gl.pixelStorei(3316,unpackSkipPixels);_gl.pixelStorei(3315,unpackSkipRows);_gl.pixelStorei(32877,unpackSkipImages);// Generate mipmaps only when copying level 0
if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(glTarget);state.unbindTexture();};this.initTexture=function(texture){textures.setTexture2D(texture,0);state.unbindTexture();};this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
}}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=true;class FogExp2{constructor(color,density=0.00025){this.name='';this.color=new Color(color);this.density=density;}clone(){return new FogExp2(this.color,this.density);}toJSON(/* meta */){return{type:'FogExp2',color:this.color.getHex(),density:this.density};}}FogExp2.prototype.isFogExp2=true;class Fog{constructor(color,near=1,far=1000){this.name='';this.color=new Color(color);this.near=near;this.far=far;}clone(){return new Fog(this.color,this.near,this.far);}toJSON(/* meta */){return{type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};}}Fog.prototype.isFog=true;class Scene extends Object3D{constructor(){super();this.type='Scene';this.background=null;this.environment=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
}}copy(source,recursive){super.copy(source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}toJSON(meta){const data=super.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}}Scene.prototype.isScene=true;class InterleavedBuffer{constructor(array,stride){this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;this.uuid=generateUUID();}onUploadCallback(){}set needsUpdate(value){if(value===true)this.version++;}setUsage(value){this.usage=value;return this;}copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.usage=source.usage;return this;}copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(let i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;}set(value,offset=0){this.array.set(value,offset);return this;}clone(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer;}const array=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);const ib=new this.constructor(array,this.stride);ib.setUsage(this.usage);return ib;}onUpload(callback){this.onUploadCallback=callback;return this;}toJSON(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}// generate UUID for array buffer if necessary
if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer));}//
return{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride};}}InterleavedBuffer.prototype.isInterleavedBuffer=true;const _vector$6=/*@__PURE__*/new three_module_Vector3();class InterleavedBufferAttribute{constructor(interleavedBuffer,itemSize,offset,normalized=false){this.name='';this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}get count(){return this.data.count;}get array(){return this.data.array;}set needsUpdate(value){this.data.needsUpdate=value;}applyMatrix4(m){for(let i=0,l=this.data.count;i<l;i++){_vector$6.x=this.getX(i);_vector$6.y=this.getY(i);_vector$6.z=this.getZ(i);_vector$6.applyMatrix4(m);this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++){_vector$6.x=this.getX(i);_vector$6.y=this.getY(i);_vector$6.z=this.getZ(i);_vector$6.applyNormalMatrix(m);this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}transformDirection(m){for(let i=0,l=this.count;i<l;i++){_vector$6.x=this.getX(i);_vector$6.y=this.getY(i);_vector$6.z=this.getZ(i);_vector$6.transformDirection(m);this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;}setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;}setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;}setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;}getX(index){return this.data.array[index*this.data.stride+this.offset];}getY(index){return this.data.array[index*this.data.stride+this.offset+1];}getZ(index){return this.data.array[index*this.data.stride+this.offset+2];}getW(index){return this.data.array[index*this.data.stride+this.offset+3];}setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;}setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;}setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}clone(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');const array=[];for(let i=0;i<this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}return new BufferAttribute(new this.array.constructor(array),this.itemSize,this.normalized);}else{if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.clone(data);}return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);}}toJSON(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');const array=[];for(let i=0;i<this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}// deinterleave data and save it as an ordinary buffer attribute for now
return{itemSize:this.itemSize,type:this.array.constructor.name,array:array,normalized:this.normalized};}else{// save as true interlaved attribtue
if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data);}return{isInterleavedBufferAttribute:true,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};}}}InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute=true;/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */class SpriteMaterial extends Material{constructor(parameters){super();this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.rotation=0;this.sizeAttenuation=true;this.transparent=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.rotation=source.rotation;this.sizeAttenuation=source.sizeAttenuation;return this;}}SpriteMaterial.prototype.isSpriteMaterial=true;let _geometry;const _intersectPoint=/*@__PURE__*/new three_module_Vector3();const _worldScale=/*@__PURE__*/new three_module_Vector3();const _mvPosition=/*@__PURE__*/new three_module_Vector3();const _alignedPosition=/*@__PURE__*/new Vector2();const _rotatedPosition=/*@__PURE__*/new Vector2();const _viewWorldMatrix=/*@__PURE__*/new Matrix4();const _vA=/*@__PURE__*/new three_module_Vector3();const _vB=/*@__PURE__*/new three_module_Vector3();const _vC=/*@__PURE__*/new three_module_Vector3();const _uvA=/*@__PURE__*/new Vector2();const _uvB=/*@__PURE__*/new Vector2();const _uvC=/*@__PURE__*/new Vector2();class Sprite extends Object3D{constructor(material){super();this.type='Sprite';if(_geometry===undefined){_geometry=new BufferGeometry();const float32Array=new Float32Array([-0.5,-0.5,0,0,0,0.5,-0.5,0,1,0,0.5,0.5,0,1,1,-0.5,0.5,0,0,1]);const interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry.setIndex([0,1,2,0,2,3]);_geometry.setAttribute('position',new InterleavedBufferAttribute(interleavedBuffer,3,0,false));_geometry.setAttribute('uv',new InterleavedBufferAttribute(interleavedBuffer,2,3,false));}this.geometry=_geometry;this.material=material!==undefined?material:new SpriteMaterial();this.center=new Vector2(0.5,0.5);}raycast(raycaster,intersects){if(raycaster.camera===null){console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');}_worldScale.setFromMatrixScale(this.matrixWorld);_viewWorldMatrix.copy(raycaster.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld);_mvPosition.setFromMatrixPosition(this.modelViewMatrix);if(raycaster.camera.isPerspectiveCamera&&this.material.sizeAttenuation===false){_worldScale.multiplyScalar(-_mvPosition.z);}const rotation=this.material.rotation;let sin,cos;if(rotation!==0){cos=Math.cos(rotation);sin=Math.sin(rotation);}const center=this.center;transformVertex(_vA.set(-0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vB.set(0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vC.set(0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvA.set(0,0);_uvB.set(1,0);_uvC.set(1,1);// check first triangle
let intersect=raycaster.ray.intersectTriangle(_vA,_vB,_vC,false,_intersectPoint);if(intersect===null){// check second triangle
transformVertex(_vB.set(-0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvB.set(0,1);intersect=raycaster.ray.intersectTriangle(_vA,_vC,_vB,false,_intersectPoint);if(intersect===null){return;}}const distance=raycaster.ray.origin.distanceTo(_intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:_intersectPoint.clone(),uv:Triangle.getUV(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2()),face:null,object:this});}copy(source){super.copy(source);if(source.center!==undefined)this.center.copy(source.center);this.material=source.material;return this;}}Sprite.prototype.isSprite=true;function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){// compute position in camera space
_alignedPosition.subVectors(vertexPosition,center).addScalar(0.5).multiply(scale);// to check if rotation is not zero
if(sin!==undefined){_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y;_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y;}else{_rotatedPosition.copy(_alignedPosition);}vertexPosition.copy(mvPosition);vertexPosition.x+=_rotatedPosition.x;vertexPosition.y+=_rotatedPosition.y;// transform to world space
vertexPosition.applyMatrix4(_viewWorldMatrix);}const _v1$2=/*@__PURE__*/new three_module_Vector3();const _v2$1=/*@__PURE__*/new three_module_Vector3();class LOD extends (/* unused pure expression or super */ null && (Object3D)){constructor(){super();this._currentLevel=0;this.type='LOD';Object.defineProperties(this,{levels:{enumerable:true,value:[]},isLOD:{value:true}});this.autoUpdate=true;}copy(source){super.copy(source,false);const levels=source.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];this.addLevel(level.object.clone(),level.distance);}this.autoUpdate=source.autoUpdate;return this;}addLevel(object,distance=0){distance=Math.abs(distance);const levels=this.levels;let l;for(l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);return this;}getCurrentLevel(){return this._currentLevel;}getObjectForDistance(distance){const levels=this.levels;if(levels.length>0){let i,l;for(i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;}return null;}raycast(raycaster,intersects){const levels=this.levels;if(levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(distance).raycast(raycaster,intersects);}}update(camera){const levels=this.levels;if(levels.length>1){_v1$2.setFromMatrixPosition(camera.matrixWorld);_v2$1.setFromMatrixPosition(this.matrixWorld);const distance=_v1$2.distanceTo(_v2$1)/camera.zoom;levels[0].object.visible=true;let i,l;for(i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}this._currentLevel=i-1;for(;i<l;i++){levels[i].object.visible=false;}}}toJSON(meta){const data=super.toJSON(meta);if(this.autoUpdate===false)data.object.autoUpdate=false;data.object.levels=[];const levels=this.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}}const _basePosition=/*@__PURE__*/new three_module_Vector3();const _skinIndex=/*@__PURE__*/new Vector4();const _skinWeight=/*@__PURE__*/new Vector4();const _vector$5=/*@__PURE__*/new three_module_Vector3();const _matrix=/*@__PURE__*/new Matrix4();class SkinnedMesh extends three_module_Mesh{constructor(geometry,material){super(geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();}copy(source){super.copy(source);this.bindMode=source.bindMode;this.bindMatrix.copy(source.bindMatrix);this.bindMatrixInverse.copy(source.bindMatrixInverse);this.skeleton=source.skeleton;return this;}bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.copy(bindMatrix).invert();}pose(){this.skeleton.pose();}normalizeSkinWeights(){const vector=new Vector4();const skinWeight=this.geometry.attributes.skinWeight;for(let i=0,l=skinWeight.count;i<l;i++){vector.x=skinWeight.getX(i);vector.y=skinWeight.getY(i);vector.z=skinWeight.getZ(i);vector.w=skinWeight.getW(i);const scale=1.0/vector.manhattanLength();if(scale!==Infinity){vector.multiplyScalar(scale);}else{vector.set(1,0,0,0);// do something reasonable
}skinWeight.setXYZW(i,vector.x,vector.y,vector.z,vector.w);}}updateMatrixWorld(force){super.updateMatrixWorld(force);if(this.bindMode==='attached'){this.bindMatrixInverse.copy(this.matrixWorld).invert();}else if(this.bindMode==='detached'){this.bindMatrixInverse.copy(this.bindMatrix).invert();}else{console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}}boneTransform(index,target){const skeleton=this.skeleton;const geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index);_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,index);_basePosition.fromBufferAttribute(geometry.attributes.position,index).applyMatrix4(this.bindMatrix);target.set(0,0,0);for(let i=0;i<4;i++){const weight=_skinWeight.getComponent(i);if(weight!==0){const boneIndex=_skinIndex.getComponent(i);_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]);target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix),weight);}}return target.applyMatrix4(this.bindMatrixInverse);}}SkinnedMesh.prototype.isSkinnedMesh=true;class Bone extends Object3D{constructor(){super();this.type='Bone';}}Bone.prototype.isBone=true;class DataTexture extends Texture{constructor(data=null,width=1,height=1,format,type,mapping,wrapS,wrapT,magFilter=NearestFilter,minFilter=NearestFilter,anisotropy,encoding){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter;this.minFilter=minFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture.prototype.isDataTexture=true;const _offsetMatrix=/*@__PURE__*/new Matrix4();const _identityMatrix=/*@__PURE__*/new Matrix4();class Skeleton{constructor(bones=[],boneInverses=[]){this.uuid=generateUUID();this.bones=bones.slice(0);this.boneInverses=boneInverses;this.boneMatrices=null;this.boneTexture=null;this.boneTextureSize=0;this.frame=-1;this.init();}init(){const bones=this.bones;const boneInverses=this.boneInverses;this.boneMatrices=new Float32Array(bones.length*16);// calculate inverse bone matrices if necessary
if(boneInverses.length===0){this.calculateInverses();}else{// handle special case
if(bones.length!==boneInverses.length){console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');this.boneInverses=[];for(let i=0,il=this.bones.length;i<il;i++){this.boneInverses.push(new Matrix4());}}}}calculateInverses(){this.boneInverses.length=0;for(let i=0,il=this.bones.length;i<il;i++){const inverse=new Matrix4();if(this.bones[i]){inverse.copy(this.bones[i].matrixWorld).invert();}this.boneInverses.push(inverse);}}pose(){// recover the bind-time world matrices
for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];if(bone){bone.matrixWorld.copy(this.boneInverses[i]).invert();}}// compute the local matrices, positions, rotations and scales
for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.copy(bone.parent.matrixWorld).invert();bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}}update(){const bones=this.bones;const boneInverses=this.boneInverses;const boneMatrices=this.boneMatrices;const boneTexture=this.boneTexture;// flatten bone matrices to array
for(let i=0,il=bones.length;i<il;i++){// compute the offset between the current and the original transform
const matrix=bones[i]?bones[i].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);_offsetMatrix.toArray(boneMatrices,i*16);}if(boneTexture!==null){boneTexture.needsUpdate=true;}}clone(){return new Skeleton(this.bones,this.boneInverses);}computeBoneTexture(){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
let size=Math.sqrt(this.bones.length*4);// 4 pixels needed for 1 matrix
size=ceilPowerOfTwo(size);size=Math.max(size,4);const boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
boneMatrices.set(this.boneMatrices);// copy current values
const boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);this.boneMatrices=boneMatrices;this.boneTexture=boneTexture;this.boneTextureSize=size;return this;}getBoneByName(name){for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];if(bone.name===name){return bone;}}return undefined;}dispose(){if(this.boneTexture!==null){this.boneTexture.dispose();this.boneTexture=null;}}fromJSON(json,bones){this.uuid=json.uuid;for(let i=0,l=json.bones.length;i<l;i++){const uuid=json.bones[i];let bone=bones[uuid];if(bone===undefined){console.warn('THREE.Skeleton: No bone found with UUID:',uuid);bone=new Bone();}this.bones.push(bone);this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));}this.init();return this;}toJSON(){const data={metadata:{version:4.5,type:'Skeleton',generator:'Skeleton.toJSON'},bones:[],boneInverses:[]};data.uuid=this.uuid;const bones=this.bones;const boneInverses=this.boneInverses;for(let i=0,l=bones.length;i<l;i++){const bone=bones[i];data.bones.push(bone.uuid);const boneInverse=boneInverses[i];data.boneInverses.push(boneInverse.toArray());}return data;}}const _instanceLocalMatrix=/*@__PURE__*/new Matrix4();const _instanceWorldMatrix=/*@__PURE__*/new Matrix4();const _instanceIntersects=[];const _mesh=/*@__PURE__*/new three_module_Mesh();class InstancedMesh extends three_module_Mesh{constructor(geometry,material,count){super(geometry,material);this.instanceMatrix=new BufferAttribute(new Float32Array(count*16),16);this.instanceColor=null;this.count=count;this.frustumCulled=false;}copy(source){super.copy(source);this.instanceMatrix.copy(source.instanceMatrix);if(source.instanceColor!==null)this.instanceColor=source.instanceColor.clone();this.count=source.count;return this;}getColorAt(index,color){color.fromArray(this.instanceColor.array,index*3);}getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,index*16);}raycast(raycaster,intersects){const matrixWorld=this.matrixWorld;const raycastTimes=this.count;_mesh.geometry=this.geometry;_mesh.material=this.material;if(_mesh.material===undefined)return;for(let instanceId=0;instanceId<raycastTimes;instanceId++){// calculate the world matrix for each instance
this.getMatrixAt(instanceId,_instanceLocalMatrix);_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix);// the mesh represents this single instance
_mesh.matrixWorld=_instanceWorldMatrix;_mesh.raycast(raycaster,_instanceIntersects);// process the result of raycast
for(let i=0,l=_instanceIntersects.length;i<l;i++){const intersect=_instanceIntersects[i];intersect.instanceId=instanceId;intersect.object=this;intersects.push(intersect);}_instanceIntersects.length=0;}}setColorAt(index,color){if(this.instanceColor===null){this.instanceColor=new BufferAttribute(new Float32Array(this.instanceMatrix.count*3),3);}color.toArray(this.instanceColor.array,index*3);}setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,index*16);}updateMorphTargets(){}dispose(){this.dispatchEvent({type:'dispose'});}}InstancedMesh.prototype.isInstancedMesh=true;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */class LineBasicMaterial extends Material{constructor(parameters){super();this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;}}LineBasicMaterial.prototype.isLineBasicMaterial=true;const _start$1=/*@__PURE__*/new three_module_Vector3();const _end$1=/*@__PURE__*/new three_module_Vector3();const _inverseMatrix$1=/*@__PURE__*/new Matrix4();const _ray$1=/*@__PURE__*/new Ray();const _sphere$1=/*@__PURE__*/new Sphere();class Line extends Object3D{constructor(geometry=new BufferGeometry(),material=new LineBasicMaterial()){super();this.type='Line';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);this.material=source.material;this.geometry=source.geometry;return this;}computeLineDistances(){const geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
if(geometry.index===null){const positionAttribute=geometry.attributes.position;const lineDistances=[0];for(let i=1,l=positionAttribute.count;i<l;i++){_start$1.fromBufferAttribute(positionAttribute,i-1);_end$1.fromBufferAttribute(positionAttribute,i);lineDistances[i]=lineDistances[i-1];lineDistances[i]+=_start$1.distanceTo(_end$1);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}raycast(raycaster,intersects){const geometry=this.geometry;const matrixWorld=this.matrixWorld;const threshold=raycaster.params.Line.threshold;const drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$1.copy(geometry.boundingSphere);_sphere$1.applyMatrix4(matrixWorld);_sphere$1.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere$1)===false)return;//
_inverseMatrix$1.copy(matrixWorld).invert();_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);const localThresholdSq=localThreshold*localThreshold;const vStart=new three_module_Vector3();const vEnd=new three_module_Vector3();const interSegment=new three_module_Vector3();const interRay=new three_module_Vector3();const step=this.isLineSegments?2:1;if(geometry.isBufferGeometry){const index=geometry.index;const attributes=geometry.attributes;const positionAttribute=attributes.position;if(index!==null){const start=Math.max(0,drawRange.start);const end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,l=end-1;i<l;i+=step){const a=index.getX(i);const b=index.getX(i+1);vStart.fromBufferAttribute(positionAttribute,a);vEnd.fromBufferAttribute(positionAttribute,b);const distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
const distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{const start=Math.max(0,drawRange.start);const end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(let i=start,l=end-1;i<l;i+=step){vStart.fromBufferAttribute(positionAttribute,i);vEnd.fromBufferAttribute(positionAttribute,i+1);const distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
const distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}updateMorphTargets(){const geometry=this.geometry;if(geometry.isBufferGeometry){const morphAttributes=geometry.morphAttributes;const keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{const morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}Line.prototype.isLine=true;const _start=/*@__PURE__*/new three_module_Vector3();const _end=/*@__PURE__*/new three_module_Vector3();class LineSegments extends Line{constructor(geometry,material){super(geometry,material);this.type='LineSegments';}computeLineDistances(){const geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
if(geometry.index===null){const positionAttribute=geometry.attributes.position;const lineDistances=[];for(let i=0,l=positionAttribute.count;i<l;i+=2){_start.fromBufferAttribute(positionAttribute,i);_end.fromBufferAttribute(positionAttribute,i+1);lineDistances[i]=i===0?0:lineDistances[i-1];lineDistances[i+1]=lineDistances[i]+_start.distanceTo(_end);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}}LineSegments.prototype.isLineSegments=true;class LineLoop extends Line{constructor(geometry,material){super(geometry,material);this.type='LineLoop';}}LineLoop.prototype.isLineLoop=true;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 * }
 */class PointsMaterial extends Material{constructor(parameters){super();this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.size=1;this.sizeAttenuation=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;}}PointsMaterial.prototype.isPointsMaterial=true;const _inverseMatrix=/*@__PURE__*/new Matrix4();const _ray=/*@__PURE__*/new Ray();const _sphere=/*@__PURE__*/new Sphere();const _position$2=/*@__PURE__*/new three_module_Vector3();class Points extends Object3D{constructor(geometry=new BufferGeometry(),material=new PointsMaterial()){super();this.type='Points';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);this.material=source.material;this.geometry=source.geometry;return this;}raycast(raycaster,intersects){const geometry=this.geometry;const matrixWorld=this.matrixWorld;const threshold=raycaster.params.Points.threshold;const drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere);_sphere.applyMatrix4(matrixWorld);_sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere)===false)return;//
_inverseMatrix.copy(matrixWorld).invert();_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);const localThresholdSq=localThreshold*localThreshold;if(geometry.isBufferGeometry){const index=geometry.index;const attributes=geometry.attributes;const positionAttribute=attributes.position;if(index!==null){const start=Math.max(0,drawRange.start);const end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,il=end;i<il;i++){const a=index.getX(i);_position$2.fromBufferAttribute(positionAttribute,a);testPoint(_position$2,a,localThresholdSq,matrixWorld,raycaster,intersects,this);}}else{const start=Math.max(0,drawRange.start);const end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(let i=start,l=end;i<l;i++){_position$2.fromBufferAttribute(positionAttribute,i);testPoint(_position$2,i,localThresholdSq,matrixWorld,raycaster,intersects,this);}}}else{console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}updateMorphTargets(){const geometry=this.geometry;if(geometry.isBufferGeometry){const morphAttributes=geometry.morphAttributes;const keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{const morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}Points.prototype.isPoints=true;function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects,object){const rayPointDistanceSq=_ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){const intersectPoint=new three_module_Vector3();_ray.closestPointToPoint(point,intersectPoint);intersectPoint.applyMatrix4(matrixWorld);const distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index:index,face:null,object:object});}}class VideoTexture extends Texture{constructor(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.format=format!==undefined?format:RGBFormat;this.minFilter=minFilter!==undefined?minFilter:LinearFilter;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.generateMipmaps=false;const scope=this;function updateVideo(){scope.needsUpdate=true;video.requestVideoFrameCallback(updateVideo);}if('requestVideoFrameCallback'in video){video.requestVideoFrameCallback(updateVideo);}}clone(){return new this.constructor(this.image).copy(this);}update(){const video=this.image;const hasVideoFrameCallback=('requestVideoFrameCallback'in video);if(hasVideoFrameCallback===false&&video.readyState>=video.HAVE_CURRENT_DATA){this.needsUpdate=true;}}}VideoTexture.prototype.isVideoTexture=true;class CompressedTexture extends Texture{constructor(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=false;// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=false;}}CompressedTexture.prototype.isCompressedTexture=true;class CanvasTexture extends Texture{constructor(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}}CanvasTexture.prototype.isCanvasTexture=true;class DepthTexture extends Texture{constructor(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}}DepthTexture.prototype.isDepthTexture=true;class CircleGeometry extends BufferGeometry{constructor(radius=1,segments=8,thetaStart=0,thetaLength=Math.PI*2){super();this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};segments=Math.max(3,segments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
const vertex=new three_module_Vector3();const uv=new Vector2();// center point
vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(let s=0,i=3;s<=segments;s++,i+=3){const segment=thetaStart+s/segments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uvs
uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
for(let i=1;i<=segments;i++){indices.push(i,i+1,0);}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new CircleGeometry(data.radius,data.segments,data.thetaStart,data.thetaLength);}}class CylinderGeometry extends BufferGeometry{constructor(radiusTop=1,radiusBottom=1,height=1,radialSegments=8,heightSegments=1,openEnded=false,thetaStart=0,thetaLength=Math.PI*2){super();this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};const scope=this;radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
let index=0;const indexArray=[];const halfHeight=height/2;let groupStart=0;// generate geometry
generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){const normal=new three_module_Vector3();const vertex=new three_module_Vector3();let groupCount=0;// this will be used to calculate the normal
const slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
for(let y=0;y<=heightSegments;y++){const indexRow=[];const v=y/heightSegments;// calculate the radius of the current row
const radius=v*(radiusBottom-radiusTop)+radiusTop;for(let x=0;x<=radialSegments;x++){const u=x/radialSegments;const theta=u*thetaLength+thetaStart;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);// save index of vertex in respective row
indexRow.push(index++);}// now save vertices of the row in our index array
indexArray.push(indexRow);}// generate indices
for(let x=0;x<radialSegments;x++){for(let y=0;y<heightSegments;y++){// we use the index array to access the correct indices
const a=indexArray[y][x];const b=indexArray[y+1][x];const c=indexArray[y+1][x+1];const d=indexArray[y][x+1];// faces
indices.push(a,b,d);indices.push(b,c,d);// update group counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
groupStart+=groupCount;}function generateCap(top){// save the index of the first center vertex
const centerIndexStart=index;const uv=new Vector2();const vertex=new three_module_Vector3();let groupCount=0;const radius=top===true?radiusTop:radiusBottom;const sign=top===true?1:-1;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(let x=1;x<=radialSegments;x++){// vertex
vertices.push(0,halfHeight*sign,0);// normal
normals.push(0,sign,0);// uv
uvs.push(0.5,0.5);// increase index
index++;}// save the index of the last center vertex
const centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
for(let x=0;x<=radialSegments;x++){const u=x/radialSegments;const theta=u*thetaLength+thetaStart;const cosTheta=Math.cos(theta);const sinTheta=Math.sin(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,sign,0);// uv
uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
index++;}// generate indices
for(let x=0;x<radialSegments;x++){const c=centerIndexStart+x;const i=centerIndexEnd+x;if(top===true){// face top
indices.push(i,i+1,c);}else{// face bottom
indices.push(i+1,i,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
groupStart+=groupCount;}}static fromJSON(data){return new CylinderGeometry(data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);}}class ConeGeometry extends CylinderGeometry{constructor(radius=1,height=1,radialSegments=8,heightSegments=1,openEnded=false,thetaStart=0,thetaLength=Math.PI*2){super(0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}static fromJSON(data){return new ConeGeometry(data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);}}class PolyhedronGeometry extends BufferGeometry{constructor(vertices,indices,radius=1,detail=0){super();this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};// default buffer data
const vertexBuffer=[];const uvBuffer=[];// the subdivision creates the vertex buffer data
subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
applyRadius(radius);// finally, create the uv data
generateUVs();// build non-indexed geometry
this.setAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.setAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.setAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){this.computeVertexNormals();// flat normals
}else{this.normalizeNormals();// smooth normals
}// helper functions
function subdivide(detail){const a=new three_module_Vector3();const b=new three_module_Vector3();const c=new three_module_Vector3();// iterate over all faces and apply a subdivison with the given detail value
for(let i=0;i<indices.length;i+=3){// get the vertices of the face
getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){const cols=detail+1;// we use this multidimensional array as a data structure for creating the subdivision
const v=[];// construct all of the vertices for this subdivision
for(let i=0;i<=cols;i++){v[i]=[];const aj=a.clone().lerp(c,i/cols);const bj=b.clone().lerp(c,i/cols);const rows=cols-i;for(let j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
for(let i=0;i<cols;i++){for(let j=0;j<2*(cols-i)-1;j++){const k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function applyRadius(radius){const vertex=new three_module_Vector3();// iterate over the entire buffer and apply the radius to each vertex
for(let i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){const vertex=new three_module_Vector3();for(let i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];const u=azimuth(vertex)/2/Math.PI+0.5;const v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
for(let i=0;i<uvBuffer.length;i+=6){// uv data of a single face
const x0=uvBuffer[i+0];const x1=uvBuffer[i+2];const x2=uvBuffer[i+4];const max=Math.max(x0,x1,x2);const min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){const stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){const a=new three_module_Vector3();const b=new three_module_Vector3();const c=new three_module_Vector3();const centroid=new three_module_Vector3();const uvA=new Vector2();const uvB=new Vector2();const uvC=new Vector2();for(let i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);const azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}static fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,data.details);}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/2;const r=1/t;const vertices=[// (±1, ±1, ±1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, ±1/φ, ±φ)
0,-r,-t,0,-r,t,0,r,-t,0,r,t,// (±1/φ, ±φ, 0)
-r,-t,0,-r,t,0,r,-t,0,r,t,0,// (±φ, 0, ±1/φ)
-t,0,-r,t,0,-r,-t,0,r,t,0,r];const indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(vertices,indices,radius,detail);this.type='DodecahedronGeometry';this.parameters={radius:radius,detail:detail};}static fromJSON(data){return new DodecahedronGeometry(data.radius,data.detail);}}const _v0=new three_module_Vector3();const _v1$1=new three_module_Vector3();const _normal=new three_module_Vector3();const _triangle=new Triangle();class EdgesGeometry extends BufferGeometry{constructor(geometry,thresholdAngle){super();this.type='EdgesGeometry';this.parameters={thresholdAngle:thresholdAngle};thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;if(geometry.isGeometry===true){console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');return;}const thresholdDot=Math.cos(DEG2RAD*thresholdAngle);const indexAttr=geometry.getIndex();const positionAttr=geometry.getAttribute('position');const indexCount=indexAttr?indexAttr.count:positionAttr.count;const indexArr=[0,0,0];const vertKeys=['a','b','c'];const hashes=new Array(3);const edgeData={};const vertices=[];for(let i=0;i<indexCount;i+=3){if(indexAttr){indexArr[0]=indexAttr.getX(i);indexArr[1]=indexAttr.getX(i+1);indexArr[2]=indexAttr.getX(i+2);}else{indexArr[0]=i;indexArr[1]=i+1;indexArr[2]=i+2;}const{a,b,c}=_triangle;a.fromBufferAttribute(positionAttr,indexArr[0]);b.fromBufferAttribute(positionAttr,indexArr[1]);c.fromBufferAttribute(positionAttr,indexArr[2]);_triangle.getNormal(_normal);// create hashes for the edge from the vertices
hashes[0]=`${a.x},${a.y},${a.z}`;hashes[1]=`${b.x},${b.y},${b.z}`;hashes[2]=`${c.x},${c.y},${c.z}`;// skip degenerate triangles
if(hashes[0]===hashes[1]||hashes[1]===hashes[2]||hashes[2]===hashes[0]){continue;}// iterate over every edge
for(let j=0;j<3;j++){// get the first and next vertex making up the edge
const jNext=(j+1)%3;const vecHash0=hashes[j];const vecHash1=hashes[jNext];const v0=_triangle[vertKeys[j]];const v1=_triangle[vertKeys[jNext]];const hash=`${vecHash0}_${vecHash1}`;const reverseHash=`${vecHash1}_${vecHash0}`;if(reverseHash in edgeData&&edgeData[reverseHash]){// if we found a sibling edge add it into the vertex array if
// it meets the angle threshold and delete the edge from the map.
if(_normal.dot(edgeData[reverseHash].normal)<=thresholdDot){vertices.push(v0.x,v0.y,v0.z);vertices.push(v1.x,v1.y,v1.z);}edgeData[reverseHash]=null;}else if(!(hash in edgeData)){// if we've already got an edge here then skip adding a new one
edgeData[hash]={index0:indexArr[j],index1:indexArr[jNext],normal:_normal.clone()};}}}// iterate over all remaining, unmatched edges and add them to the vertex array
for(const key in edgeData){if(edgeData[key]){const{index0,index1}=edgeData[key];_v0.fromBufferAttribute(positionAttr,index0);_v1$1.fromBufferAttribute(positionAttr,index1);vertices.push(_v0.x,_v0.y,_v0.z);vertices.push(_v1$1.x,_v1$1.y,_v1$1.z);}}this.setAttribute('position',new Float32BufferAttribute(vertices,3));}}/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/class Curve{constructor(){this.type='Curve';this.arcLengthDivisions=200;}// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint(/* t, optionalTarget */){console.warn('THREE.Curve: .getPoint() not implemented.');return null;}// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt(u,optionalTarget){const t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);}// Get sequence of points using getPoint( t )
getPoints(divisions=5){const points=[];for(let d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;}// Get sequence of points using getPointAt( u )
getSpacedPoints(divisions=5){const points=[];for(let d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;}// Get total curve arc length
getLength(){const lengths=this.getLengths();return lengths[lengths.length-1];}// Get list of cumulative segment lengths
getLengths(divisions=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;const cache=[];let current,last=this.getPoint(0);let sum=0;cache.push(0);for(let p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
}updateArcLengths(){this.needsUpdate=true;this.getLengths();}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping(u,distance){const arcLengths=this.getLengths();let i=0;const il=arcLengths.length;let targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
let low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
const lengthBefore=arcLengths[i];const lengthAfter=arcLengths[i+1];const segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
const segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
const t=(i+segmentFraction)/(il-1);return t;}// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent(t,optionalTarget){const delta=0.0001;let t1=t-delta;let t2=t+delta;// Capping in case of danger
if(t1<0)t1=0;if(t2>1)t2=1;const pt1=this.getPoint(t1);const pt2=this.getPoint(t2);const tangent=optionalTarget||(pt1.isVector2?new Vector2():new three_module_Vector3());tangent.copy(pt2).sub(pt1).normalize();return tangent;}getTangentAt(u,optionalTarget){const t=this.getUtoTmapping(u);return this.getTangent(t,optionalTarget);}computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
const normal=new three_module_Vector3();const tangents=[];const normals=[];const binormals=[];const vec=new three_module_Vector3();const mat=new Matrix4();// compute the tangent vectors for each segment on the curve
for(let i=0;i<=segments;i++){const u=i/segments;tangents[i]=this.getTangentAt(u,new three_module_Vector3());tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
normals[0]=new three_module_Vector3();binormals[0]=new three_module_Vector3();let min=Number.MAX_VALUE;const tx=Math.abs(tangents[0].x);const ty=Math.abs(tangents[0].y);const tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(let i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>Number.EPSILON){vec.normalize();const theta=Math.acos(clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(closed===true){let theta=Math.acos(clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(let i=1;i<=segments;i++){// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};}clone(){return new this.constructor().copy(this);}copy(source){this.arcLengthDivisions=source.arcLengthDivisions;return this;}toJSON(){const data={metadata:{version:4.5,type:'Curve',generator:'Curve.toJSON'}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data;}fromJSON(json){this.arcLengthDivisions=json.arcLengthDivisions;return this;}}class EllipseCurve extends Curve{constructor(aX=0,aY=0,xRadius=1,yRadius=1,aStartAngle=0,aEndAngle=Math.PI*2,aClockwise=false,aRotation=0){super();this.type='EllipseCurve';this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation;}getPoint(t,optionalTarget){const point=optionalTarget||new Vector2();const twoPi=Math.PI*2;let deltaAngle=this.aEndAngle-this.aStartAngle;const samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0)deltaAngle+=twoPi;while(deltaAngle>twoPi)deltaAngle-=twoPi;if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}const angle=this.aStartAngle+t*deltaAngle;let x=this.aX+this.xRadius*Math.cos(angle);let y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){const cos=Math.cos(this.aRotation);const sin=Math.sin(this.aRotation);const tx=x-this.aX;const ty=y-this.aY;// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);}copy(source){super.copy(source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this;}toJSON(){const data=super.toJSON();data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data;}fromJSON(json){super.fromJSON(json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this;}}EllipseCurve.prototype.isEllipseCurve=true;class ArcCurve extends EllipseCurve{constructor(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){super(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);this.type='ArcCurve';}}ArcCurve.prototype.isArcCurve=true;/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function CubicPoly(){let c0=0,c1=0,c2=0,c3=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
let t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;let t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function(t){const t2=t*t;const t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
const tmp=new three_module_Vector3();const px=new CubicPoly(),py=new CubicPoly(),pz=new CubicPoly();class CatmullRomCurve3 extends Curve{constructor(points=[],closed=false,curveType='centripetal',tension=0.5){super();this.type='CatmullRomCurve3';this.points=points;this.closed=closed;this.curveType=curveType;this.tension=tension;}getPoint(t,optionalTarget=new three_module_Vector3()){const point=optionalTarget;const points=this.points;const l=points.length;const p=(l-(this.closed?0:1))*t;let intPoint=Math.floor(p);let weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}let p0,p3;// 4 points (p1 & p2 defined below)
if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}const p1=points[intPoint%l];const p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.curveType==='centripetal'||this.curveType==='chordal'){// init Centripetal / Chordal Catmull-Rom
const pow=this.curveType==='chordal'?0.5:0.25;let dt0=Math.pow(p0.distanceToSquared(p1),pow);let dt1=Math.pow(p1.distanceToSquared(p2),pow);let dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.curveType==='catmullrom'){px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);}point.set(px.calc(weight),py.calc(weight),pz.calc(weight));return point;}copy(source){super.copy(source);this.points=[];for(let i=0,l=source.points.length;i<l;i++){const point=source.points[i];this.points.push(point.clone());}this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this;}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++){const point=this.points[i];data.points.push(point.toArray());}data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data;}fromJSON(json){super.fromJSON(json);this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push(new three_module_Vector3().fromArray(point));}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this;}}CatmullRomCurve3.prototype.isCatmullRomCurve3=true;/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */function CatmullRom(t,p0,p1,p2,p3){const v0=(p2-p0)*0.5;const v1=(p3-p1)*0.5;const t2=t*t;const t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
function QuadraticBezierP0(t,p){const k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
function CubicBezierP0(t,p){const k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){const k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}class CubicBezierCurve extends Curve{constructor(v0=new Vector2(),v1=new Vector2(),v2=new Vector2(),v3=new Vector2()){super();this.type='CubicBezierCurve';this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}getPoint(t,optionalTarget=new Vector2()){const point=optionalTarget;const v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}CubicBezierCurve.prototype.isCubicBezierCurve=true;class CubicBezierCurve3 extends Curve{constructor(v0=new three_module_Vector3(),v1=new three_module_Vector3(),v2=new three_module_Vector3(),v3=new three_module_Vector3()){super();this.type='CubicBezierCurve3';this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}getPoint(t,optionalTarget=new three_module_Vector3()){const point=optionalTarget;const v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}CubicBezierCurve3.prototype.isCubicBezierCurve3=true;class LineCurve extends Curve{constructor(v1=new Vector2(),v2=new Vector2()){super();this.type='LineCurve';this.v1=v1;this.v2=v2;}getPoint(t,optionalTarget=new Vector2()){const point=optionalTarget;if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}getTangent(t,optionalTarget){const tangent=optionalTarget||new Vector2();tangent.copy(this.v2).sub(this.v1).normalize();return tangent;}copy(source){super.copy(source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){const data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}LineCurve.prototype.isLineCurve=true;class LineCurve3 extends Curve{constructor(v1=new three_module_Vector3(),v2=new three_module_Vector3()){super();this.type='LineCurve3';this.isLineCurve3=true;this.v1=v1;this.v2=v2;}getPoint(t,optionalTarget=new three_module_Vector3()){const point=optionalTarget;if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}copy(source){super.copy(source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){const data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}class QuadraticBezierCurve extends Curve{constructor(v0=new Vector2(),v1=new Vector2(),v2=new Vector2()){super();this.type='QuadraticBezierCurve';this.v0=v0;this.v1=v1;this.v2=v2;}getPoint(t,optionalTarget=new Vector2()){const point=optionalTarget;const v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;class QuadraticBezierCurve3 extends Curve{constructor(v0=new three_module_Vector3(),v1=new three_module_Vector3(),v2=new three_module_Vector3()){super();this.type='QuadraticBezierCurve3';this.v0=v0;this.v1=v1;this.v2=v2;}getPoint(t,optionalTarget=new three_module_Vector3()){const point=optionalTarget;const v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;class SplineCurve extends Curve{constructor(points=[]){super();this.type='SplineCurve';this.points=points;}getPoint(t,optionalTarget=new Vector2()){const point=optionalTarget;const points=this.points;const p=(points.length-1)*t;const intPoint=Math.floor(p);const weight=p-intPoint;const p0=points[intPoint===0?intPoint:intPoint-1];const p1=points[intPoint];const p2=points[intPoint>points.length-2?points.length-1:intPoint+1];const p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;}copy(source){super.copy(source);this.points=[];for(let i=0,l=source.points.length;i<l;i++){const point=source.points[i];this.points.push(point.clone());}return this;}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++){const point=this.points[i];data.points.push(point.toArray());}return data;}fromJSON(json){super.fromJSON(json);this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push(new Vector2().fromArray(point));}return this;}}SplineCurve.prototype.isSplineCurve=true;var Curves=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */const Earcut={triangulate:function(data,holeIndices,dim=2){const hasHoles=holeIndices&&holeIndices.length;const outerLen=hasHoles?holeIndices[0]*dim:data.length;let outerNode=linkedList(data,0,outerLen,dim,true);const triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(let i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}};// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){let i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim)last=insertNode(i,data[i],data[i+1],last);}else{for(i=end-dim;i>=start;i-=dim)last=insertNode(i,data[i],data[i+1],last);}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;let p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||three_module_area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);let stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertex leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(filterPoints(ear),triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){const a=ear.prev,b=ear,c=ear.next;if(three_module_area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
let p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&three_module_area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){const a=ear.prev,b=ear,c=ear.next;if(three_module_area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
const minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
const minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);let p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&three_module_area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&three_module_area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&three_module_area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&three_module_area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){let p=start;do{const a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return filterPoints(p);}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
let a=start;do{let b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
let c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){const queue=[];let i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){const b=splitPolygon(outerNode,hole);// filter collinear points around the cuts
filterPoints(outerNode,outerNode.next);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){let p=outerNode;const hx=hole.x;const hy=hole.y;let qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){const x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m;// hole touches outer segment; pick leftmost endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
const stop=m,mx=m.x,my=m.y;let tanMin=Infinity,tan;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if(locallyInside(p,hole)&&(tan<tanMin||tan===tanMin&&(p.x>m.x||p.x===m.x&&sectorContainsSector(m,p)))){m=p;tanMin=tan;}}p=p.next;}while(p!==stop);return m;}// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m,p){return three_module_area(m.prev,m,p.prev)<0&&three_module_area(p.next,m,m.next)<0;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,invSize){let p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){let i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){let p=start,leftmost=start;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&(// dones't intersect other edges
locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b)&&(// locally visible
three_module_area(a.prev,a,b.prev)||three_module_area(a,b.prev,b))||// does not create opposite-facing sectors
equals(a,b)&&three_module_area(a.prev,a,a.next)>0&&three_module_area(b.prev,b,b.next)>0);// special zero-length case
}// signed area of a triangle
function three_module_area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){const o1=sign(three_module_area(p1,q1,p2));const o2=sign(three_module_area(p1,q1,q2));const o3=sign(three_module_area(p2,q2,p1));const o4=sign(three_module_area(p2,q2,q1));if(o1!==o2&&o3!==o4)return true;// general case
if(o1===0&&onSegment(p1,p2,q1))return true;// p1, q1 and p2 are collinear and p2 lies on p1q1
if(o2===0&&onSegment(p1,q2,q1))return true;// p1, q1 and q2 are collinear and q2 lies on p1q1
if(o3===0&&onSegment(p2,p1,q2))return true;// p2, q2 and p1 are collinear and p1 lies on p2q2
if(o4===0&&onSegment(p2,q1,q2))return true;// p2, q2 and q1 are collinear and q1 lies on p2q2
return false;}// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y);}function sign(num){return num>0?1:num<0?-1:0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){let p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return three_module_area(a.prev,a,a.next)<0?three_module_area(a,b,a.next)>=0&&three_module_area(a,a.prev,b)>=0:three_module_area(a,b,a.prev)<0||three_module_area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){let p=a,inside=false;const px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){const a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){const p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertex index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertex nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}function signedArea(data,start,end,dim){let sum=0;for(let i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}class ShapeUtils{// calculate area of the contour polygon
static area(contour){const n=contour.length;let a=0.0;for(let p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;}static isClockWise(pts){return ShapeUtils.area(pts)<0;}static triangulateShape(contour,holes){const vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
const holeIndices=[];// array of hole indices
const faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
removeDupEndPts(contour);addContour(vertices,contour);//
let holeIndex=contour.length;holes.forEach(removeDupEndPts);for(let i=0;i<holes.length;i++){holeIndices.push(holeIndex);holeIndex+=holes[i].length;addContour(vertices,holes[i]);}//
const triangles=Earcut.triangulate(vertices,holeIndices);//
for(let i=0;i<triangles.length;i+=3){faces.push(triangles.slice(i,i+3));}return faces;}}function removeDupEndPts(points){const l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}function addContour(vertices,contour){for(let i=0;i<contour.length;i++){vertices.push(contour[i].x);vertices.push(contour[i].y);}}/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */class ExtrudeGeometry extends BufferGeometry{constructor(shapes,options){super();this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};shapes=Array.isArray(shapes)?shapes:[shapes];const scope=this;const verticesArray=[];const uvArray=[];for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];addShape(shape);}// build geometry
this.setAttribute('position',new Float32BufferAttribute(verticesArray,3));this.setAttribute('uv',new Float32BufferAttribute(uvArray,2));this.computeVertexNormals();// functions
function addShape(shape){const placeholder=[];// options
const curveSegments=options.curveSegments!==undefined?options.curveSegments:12;const steps=options.steps!==undefined?options.steps:1;let depth=options.depth!==undefined?options.depth:100;let bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;let bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;let bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;let bevelOffset=options.bevelOffset!==undefined?options.bevelOffset:0;let bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;const extrudePath=options.extrudePath;const uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;// deprecated options
if(options.amount!==undefined){console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');depth=options.amount;}//
let extrudePts,extrudeByPath=false;let splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
splineTube=extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
binormal=new three_module_Vector3();normal=new three_module_Vector3();position2=new three_module_Vector3();}// Safeguards if bevels are not enabled
if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;bevelOffset=0;}// Variables initialization
const shapePoints=shape.extractPoints(curveSegments);let vertices=shapePoints.shape;const holes=shapePoints.holes;const reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}const faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */const contour=vertices;// vertices has all points but contour has only points of circumference
for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error('THREE.ExtrudeGeometry: vec does not exist');return vec.clone().multiplyScalar(size).add(pt);}const vlen=vertices.length,flen=faces.length;// Find directions for point movement
function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.
let v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
const v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;const v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;const v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
const collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
// length of vectors for normalizing
const v_prev_len=Math.sqrt(v_prev_lensq);const v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
const ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;const ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;const ptNextShift_x=inNext.x-v_next_y/v_next_len;const ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
const sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
const v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
let direction_eq=false;// assumes: opposite
if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else{if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}const contourMovements=[];for(let i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}const holesMovements=[];let oneHoleMovements,verticesMovements=contourMovements.concat();for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];oneHoleMovements=[];for(let i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
for(let b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
const t=b/bevelSegments;const z=bevelThickness*Math.cos(t*Math.PI/2);const bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
for(let i=0,il=contour.length;i<il;i++){const vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];oneHoleMovements=holesMovements[h];for(let i=0,il=ahole.length;i<il;i++){const vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}const bs=bevelSize+bevelOffset;// Back facing vertices
for(let i=0;i<vlen;i++){const vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
// Including front facing vertices
for(let s=1;s<=steps;s++){for(let i=0;i<vlen;i++){const vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,depth/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(let b=bevelSegments-1;b>=0;b--){const t=b/bevelSegments;const z=bevelThickness*Math.cos(t*Math.PI/2);const bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
for(let i=0,il=contour.length;i<il;i++){const vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,depth+z);}// expand holes
for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];oneHoleMovements=holesMovements[h];for(let i=0,il=ahole.length;i<il;i++){const vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,depth+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */ // Top and bottom faces
buildLidFaces();// Sides faces
buildSideFaces();/////  Internal functions
function buildLidFaces(){const start=verticesArray.length/3;if(bevelEnabled){let layer=0;// steps + 1
let offset=vlen*layer;// Bottom faces
for(let i=0;i<flen;i++){const face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
for(let i=0;i<flen;i++){const face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
for(let i=0;i<flen;i++){const face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
for(let i=0;i<flen;i++){const face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,0);}// Create faces for the z-sides of the shape
function buildSideFaces(){const start=verticesArray.length/3;let layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];sidewalls(ahole,layeroffset);//, true
layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,1);}function sidewalls(contour,layeroffset){let i=contour.length;while(--i>=0){const j=i;let k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
for(let s=0,sl=steps+bevelSegments*2;s<sl;s++){const slen1=vlen*s;const slen2=vlen*(s+1);const a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);const nextIndex=verticesArray.length/3;const uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);const nextIndex=verticesArray.length/3;const uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}}}toJSON(){const data=super.toJSON();const shapes=this.parameters.shapes;const options=this.parameters.options;return toJSON$1(shapes,options,data);}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<jl;j++){const shape=shapes[data.shapes[j]];geometryShapes.push(shape);}const extrudePath=data.options.extrudePath;if(extrudePath!==undefined){data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath);}return new ExtrudeGeometry(geometryShapes,data.options);}}const WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){const a_x=vertices[indexA*3];const a_y=vertices[indexA*3+1];const b_x=vertices[indexB*3];const b_y=vertices[indexB*3+1];const c_x=vertices[indexC*3];const c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){const a_x=vertices[indexA*3];const a_y=vertices[indexA*3+1];const a_z=vertices[indexA*3+2];const b_x=vertices[indexB*3];const b_y=vertices[indexB*3+1];const b_z=vertices[indexB*3+2];const c_x=vertices[indexC*3];const c_y=vertices[indexC*3+1];const c_z=vertices[indexC*3+2];const d_x=vertices[indexD*3];const d_y=vertices[indexD*3+1];const d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<Math.abs(a_x-b_x)){return[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};function toJSON$1(shapes,options,data){data.shapes=[];if(Array.isArray(shapes)){for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];data.shapes.push(shape.uuid);}}else{data.shapes.push(shapes.uuid);}if(options.extrudePath!==undefined)data.options.extrudePath=options.extrudePath.toJSON();return data;}class IcosahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/2;const vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];const indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(vertices,indices,radius,detail);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};}static fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail);}}class LatheGeometry extends BufferGeometry{constructor(points,segments=12,phiStart=0,phiLength=Math.PI*2){super();this.type='LatheGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};segments=Math.floor(segments);// clamp phiLength so it's in range of [ 0, 2PI ]
phiLength=clamp(phiLength,0,Math.PI*2);// buffers
const indices=[];const vertices=[];const uvs=[];// helper variables
const inverseSegments=1.0/segments;const vertex=new three_module_Vector3();const uv=new Vector2();// generate vertices and uvs
for(let i=0;i<=segments;i++){const phi=phiStart+i*inverseSegments*phiLength;const sin=Math.sin(phi);const cos=Math.cos(phi);for(let j=0;j<=points.length-1;j++){// vertex
vertex.x=points[j].x*sin;vertex.y=points[j].y;vertex.z=points[j].x*cos;vertices.push(vertex.x,vertex.y,vertex.z);// uv
uv.x=i/segments;uv.y=j/(points.length-1);uvs.push(uv.x,uv.y);}}// indices
for(let i=0;i<segments;i++){for(let j=0;j<points.length-1;j++){const base=j+i*points.length;const a=base;const b=base+points.length;const c=base+points.length+1;const d=base+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// generate normals
this.computeVertexNormals();// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).
if(phiLength===Math.PI*2){const normals=this.attributes.normal.array;const n1=new three_module_Vector3();const n2=new three_module_Vector3();const n=new three_module_Vector3();// this is the buffer offset for the last line of vertices
const base=segments*points.length*3;for(let i=0,j=0;i<points.length;i++,j+=3){// select the normal of the vertex in the first line
n1.x=normals[j+0];n1.y=normals[j+1];n1.z=normals[j+2];// select the normal of the vertex in the last line
n2.x=normals[base+j+0];n2.y=normals[base+j+1];n2.z=normals[base+j+2];// average normals
n.addVectors(n1,n2).normalize();// assign the new values to both normals
normals[j+0]=normals[base+j+0]=n.x;normals[j+1]=normals[base+j+1]=n.y;normals[j+2]=normals[base+j+2]=n.z;}}}static fromJSON(data){return new LatheGeometry(data.points,data.segments,data.phiStart,data.phiLength);}}class OctahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];const indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(vertices,indices,radius,detail);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};}static fromJSON(data){return new OctahedronGeometry(data.radius,data.detail);}}/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */class ParametricGeometry extends BufferGeometry{constructor(func,slices,stacks){super();this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];const EPS=0.00001;const normal=new three_module_Vector3();const p0=new three_module_Vector3(),p1=new three_module_Vector3();const pu=new three_module_Vector3(),pv=new three_module_Vector3();if(func.length<3){console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');}// generate vertices, normals and uvs
const sliceCount=slices+1;for(let i=0;i<=stacks;i++){const v=i/stacks;for(let j=0;j<=slices;j++){const u=j/slices;// vertex
func(u,v,p0);vertices.push(p0.x,p0.y,p0.z);// normal
// approximate tangent vectors via finite differences
if(u-EPS>=0){func(u-EPS,v,p1);pu.subVectors(p0,p1);}else{func(u+EPS,v,p1);pu.subVectors(p1,p0);}if(v-EPS>=0){func(u,v-EPS,p1);pv.subVectors(p0,p1);}else{func(u,v+EPS,p1);pv.subVectors(p1,p0);}// cross product of tangent vectors returns surface normal
normal.crossVectors(pu,pv).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,v);}}// generate indices
for(let i=0;i<stacks;i++){for(let j=0;j<slices;j++){const a=i*sliceCount+j;const b=i*sliceCount+j+1;const c=(i+1)*sliceCount+j+1;const d=(i+1)*sliceCount+j;// faces one and two
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}}class RingGeometry extends BufferGeometry{constructor(innerRadius=0.5,outerRadius=1,thetaSegments=8,phiSegments=1,thetaStart=0,thetaLength=Math.PI*2){super();this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};thetaSegments=Math.max(3,thetaSegments);phiSegments=Math.max(1,phiSegments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// some helper variables
let radius=innerRadius;const radiusStep=(outerRadius-innerRadius)/phiSegments;const vertex=new three_module_Vector3();const uv=new Vector2();// generate vertices, normals and uvs
for(let j=0;j<=phiSegments;j++){for(let i=0;i<=thetaSegments;i++){// values are generate from the inside of the ring to the outside
const segment=thetaStart+i/thetaSegments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uv
uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
radius+=radiusStep;}// indices
for(let j=0;j<phiSegments;j++){const thetaSegmentLevel=j*(thetaSegments+1);for(let i=0;i<thetaSegments;i++){const segment=i+thetaSegmentLevel;const a=segment;const b=segment+thetaSegments+1;const c=segment+thetaSegments+2;const d=segment+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new RingGeometry(data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);}}class ShapeGeometry extends BufferGeometry{constructor(shapes,curveSegments=12){super();this.type='ShapeGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
let groupStart=0;let groupCount=0;// allow single and array values for "shapes" parameter
if(Array.isArray(shapes)===false){addShape(shapes);}else{for(let i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
groupStart+=groupCount;groupCount=0;}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
function addShape(shape){const indexOffset=vertices.length/3;const points=shape.extractPoints(curveSegments);let shapeVertices=points.shape;const shapeHoles=points.holes;// check direction of vertices
if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();}for(let i=0,l=shapeHoles.length;i<l;i++){const shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}const faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
for(let i=0,l=shapeHoles.length;i<l;i++){const shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
for(let i=0,l=shapeVertices.length;i<l;i++){const vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
}// incides
for(let i=0,l=faces.length;i<l;i++){const face=faces[i];const a=face[0]+indexOffset;const b=face[1]+indexOffset;const c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}toJSON(){const data=super.toJSON();const shapes=this.parameters.shapes;return toJSON(shapes,data);}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<jl;j++){const shape=shapes[data.shapes[j]];geometryShapes.push(shape);}return new ShapeGeometry(geometryShapes,data.curveSegments);}}function toJSON(shapes,data){data.shapes=[];if(Array.isArray(shapes)){for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];data.shapes.push(shape.uuid);}}else{data.shapes.push(shapes.uuid);}return data;}class SphereGeometry extends BufferGeometry{constructor(radius=1,widthSegments=32,heightSegments=16,phiStart=0,phiLength=Math.PI*2,thetaStart=0,thetaLength=Math.PI){super();this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};widthSegments=Math.max(3,Math.floor(widthSegments));heightSegments=Math.max(2,Math.floor(heightSegments));const thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);let index=0;const grid=[];const vertex=new three_module_Vector3();const normal=new three_module_Vector3();// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// generate vertices, normals and uvs
for(let iy=0;iy<=heightSegments;iy++){const verticesRow=[];const v=iy/heightSegments;// special case for the poles
let uOffset=0;if(iy==0&&thetaStart==0){uOffset=0.5/widthSegments;}else if(iy==heightSegments&&thetaEnd==Math.PI){uOffset=-0.5/widthSegments;}for(let ix=0;ix<=widthSegments;ix++){const u=ix/widthSegments;// vertex
vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.copy(vertex).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u+uOffset,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
for(let iy=0;iy<heightSegments;iy++){for(let ix=0;ix<widthSegments;ix++){const a=grid[iy][ix+1];const b=grid[iy][ix];const c=grid[iy+1][ix];const d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];const indices=[2,1,0,0,3,2,1,3,0,2,3,1];super(vertices,indices,radius,detail);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};}static fromJSON(data){return new TetrahedronGeometry(data.radius,data.detail);}}/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */class TextGeometry extends ExtrudeGeometry{constructor(text,parameters={}){const font=parameters.font;if(!(font&&font.isFont)){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new BufferGeometry();}const shapes=font.generateShapes(text,parameters.size);// translate parameters to ExtrudeGeometry API
parameters.depth=parameters.height!==undefined?parameters.height:50;// defaults
if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;super(shapes,parameters);this.type='TextGeometry';}}class TorusGeometry extends BufferGeometry{constructor(radius=1,tube=0.4,radialSegments=8,tubularSegments=6,arc=Math.PI*2){super();this.type='TorusGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};radialSegments=Math.floor(radialSegments);tubularSegments=Math.floor(tubularSegments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
const center=new three_module_Vector3();const vertex=new three_module_Vector3();const normal=new three_module_Vector3();// generate vertices, normals and uvs
for(let j=0;j<=radialSegments;j++){for(let i=0;i<=tubularSegments;i++){const u=i/tubularSegments*arc;const v=j/radialSegments*Math.PI*2;// vertex
vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices.push(vertex.x,vertex.y,vertex.z);// normal
center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);normal.subVectors(vertex,center).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(let j=1;j<=radialSegments;j++){for(let i=1;i<=tubularSegments;i++){// indices
const a=(tubularSegments+1)*j+i-1;const b=(tubularSegments+1)*(j-1)+i-1;const c=(tubularSegments+1)*(j-1)+i;const d=(tubularSegments+1)*j+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new TorusGeometry(data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);}}class TorusKnotGeometry extends BufferGeometry{constructor(radius=1,tube=0.4,tubularSegments=64,radialSegments=8,p=2,q=3){super();this.type='TorusKnotGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};tubularSegments=Math.floor(tubularSegments);radialSegments=Math.floor(radialSegments);// buffers
const indices=[];const vertices=[];const normals=[];const uvs=[];// helper variables
const vertex=new three_module_Vector3();const normal=new three_module_Vector3();const P1=new three_module_Vector3();const P2=new three_module_Vector3();const B=new three_module_Vector3();const T=new three_module_Vector3();const N=new three_module_Vector3();// generate vertices, normals and uvs
for(let i=0;i<=tubularSegments;++i){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
const u=i/tubularSegments*p*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
calculatePositionOnCurve(u,p,q,radius,P1);calculatePositionOnCurve(u+0.01,p,q,radius,P2);// calculate orthonormal basis
T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);// normalize B, N. T can be ignored, we don't use it
B.normalize();N.normalize();for(let j=0;j<=radialSegments;++j){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
const v=j/radialSegments*Math.PI*2;const cx=-tube*Math.cos(v);const cy=tube*Math.sin(v);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
vertex.x=P1.x+(cx*N.x+cy*B.x);vertex.y=P1.y+(cx*N.y+cy*B.y);vertex.z=P1.z+(cx*N.z+cy*B.z);vertices.push(vertex.x,vertex.y,vertex.z);// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
normal.subVectors(vertex,P1).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(let j=1;j<=tubularSegments;j++){for(let i=1;i<=radialSegments;i++){// indices
const a=(radialSegments+1)*(j-1)+(i-1);const b=(radialSegments+1)*j+(i-1);const c=(radialSegments+1)*j+i;const d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// this function calculates the current position on the torus curve
function calculatePositionOnCurve(u,p,q,radius,position){const cu=Math.cos(u);const su=Math.sin(u);const quOverP=q/p*u;const cs=Math.cos(quOverP);position.x=radius*(2+cs)*0.5*cu;position.y=radius*(2+cs)*su*0.5;position.z=radius*Math.sin(quOverP)*0.5;}}static fromJSON(data){return new TorusKnotGeometry(data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);}}class TubeGeometry extends BufferGeometry{constructor(path,tubularSegments=64,radius=1,radialSegments=8,closed=false){super();this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};const frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
const vertex=new three_module_Vector3();const normal=new three_module_Vector3();const uv=new Vector2();let P=new three_module_Vector3();// buffer
const vertices=[];const normals=[];const uvs=[];const indices=[];// create buffer data
generateBufferData();// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
function generateBufferData(){for(let i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
generateUVs();// finally create faces
generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
P=path.getPointAt(i/tubularSegments,P);// retrieve corresponding normal and binormal
const N=frames.normals[i];const B=frames.binormals[i];// generate normals and vertices for the current segment
for(let j=0;j<=radialSegments;j++){const v=j/radialSegments*Math.PI*2;const sin=Math.sin(v);const cos=-Math.cos(v);// normal
normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(let j=1;j<=tubularSegments;j++){for(let i=1;i<=radialSegments;i++){const a=(radialSegments+1)*(j-1)+(i-1);const b=(radialSegments+1)*j+(i-1);const c=(radialSegments+1)*j+i;const d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(let i=0;i<=tubularSegments;i++){for(let j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}toJSON(){const data=super.toJSON();data.path=this.parameters.path.toJSON();return data;}static fromJSON(data){// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path),data.tubularSegments,data.radius,data.radialSegments,data.closed);}}class WireframeGeometry extends BufferGeometry{constructor(geometry){super();this.type='WireframeGeometry';if(geometry.isGeometry===true){console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');return;}// buffer
const vertices=[];const edges=new Set();// helper variables
const start=new three_module_Vector3();const end=new three_module_Vector3();if(geometry.index!==null){// indexed BufferGeometry
const position=geometry.attributes.position;const indices=geometry.index;let groups=geometry.groups;if(groups.length===0){groups=[{start:0,count:indices.count,materialIndex:0}];}// create a data structure that contains all eges without duplicates
for(let o=0,ol=groups.length;o<ol;++o){const group=groups[o];const groupStart=group.start;const groupCount=group.count;for(let i=groupStart,l=groupStart+groupCount;i<l;i+=3){for(let j=0;j<3;j++){const index1=indices.getX(i+j);const index2=indices.getX(i+(j+1)%3);start.fromBufferAttribute(position,index1);end.fromBufferAttribute(position,index2);if(isUniqueEdge(start,end,edges)===true){vertices.push(start.x,start.y,start.z);vertices.push(end.x,end.y,end.z);}}}}}else{// non-indexed BufferGeometry
const position=geometry.attributes.position;for(let i=0,l=position.count/3;i<l;i++){for(let j=0;j<3;j++){// three edges per triangle, an edge is represented as (index1, index2)
// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
const index1=3*i+j;const index2=3*i+(j+1)%3;start.fromBufferAttribute(position,index1);end.fromBufferAttribute(position,index2);if(isUniqueEdge(start,end,edges)===true){vertices.push(start.x,start.y,start.z);vertices.push(end.x,end.y,end.z);}}}}// build geometry
this.setAttribute('position',new Float32BufferAttribute(vertices,3));}}function isUniqueEdge(start,end,edges){const hash1=`${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;const hash2=`${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;// coincident edge
if(edges.has(hash1)===true||edges.has(hash2)===true){return false;}else{edges.add(hash1,hash2);return true;}}var Geometries=/*#__PURE__*/Object.freeze({__proto__:null,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronGeometry,EdgesGeometry:EdgesGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeGeometry,WireframeGeometry:WireframeGeometry});/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */class ShadowMaterial extends Material{constructor(parameters){super();this.type='ShadowMaterial';this.color=new Color(0x000000);this.transparent=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);return this;}}ShadowMaterial.prototype.isShadowMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */class MeshStandardMaterial extends Material{constructor(parameters){super();this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
this.roughness=1.0;this.metalness=0.0;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}MeshStandardMaterial.prototype.isMeshStandardMaterial=true;/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationTint: <Color>,
 *
 *  specularIntensity: <float>,
 *  specularIntensityhMap: new THREE.Texture( <Image> ),
 *  specularTint: <Color>,
 *  specularTintMap: new THREE.Texture( <Image> )
 * }
 */class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(parameters){super();this.defines={'STANDARD':'','PHYSICAL':''};this.type='MeshPhysicalMaterial';this.clearcoat=0.0;this.clearcoatMap=null;this.clearcoatRoughness=0.0;this.clearcoatRoughnessMap=null;this.clearcoatNormalScale=new Vector2(1,1);this.clearcoatNormalMap=null;this.reflectivity=0.5;// maps to F0 = 0.04
Object.defineProperty(this,'ior',{get:function(){return(1+0.4*this.reflectivity)/(1-0.4*this.reflectivity);},set:function(ior){this.reflectivity=clamp(2.5*(ior-1)/(ior+1),0,1);}});this.sheen=null;// null will disable sheen bsdf
this.transmission=0.0;this.transmissionMap=null;this.thickness=0.01;this.thicknessMap=null;this.attenuationDistance=0.0;this.attenuationTint=new Color(1,1,1);this.specularIntensity=1.0;this.specularIntensityMap=null;this.specularTint=new Color(1,1,1);this.specularTintMap=null;this.setValues(parameters);}copy(source){super.copy(source);this.defines={'STANDARD':'','PHYSICAL':''};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.reflectivity=source.reflectivity;if(source.sheen){this.sheen=(this.sheen||new Color()).copy(source.sheen);}else{this.sheen=null;}this.transmission=source.transmission;this.transmissionMap=source.transmissionMap;this.thickness=source.thickness;this.thicknessMap=source.thicknessMap;this.attenuationDistance=source.attenuationDistance;this.attenuationTint.copy(source.attenuationTint);this.specularIntensity=source.specularIntensity;this.specularIntensityMap=source.specularIntensityMap;this.specularTint.copy(source.specularTint);this.specularTintMap=source.specularTintMap;return this;}}MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */class MeshPhongMaterial extends Material{constructor(parameters){super();this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}MeshPhongMaterial.prototype.isMeshPhongMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */class MeshToonMaterial extends Material{constructor(parameters){super();this.defines={'TOON':''};this.type='MeshToonMaterial';this.color=new Color(0xffffff);this.map=null;this.gradientMap=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.gradientMap=source.gradientMap;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshToonMaterial.prototype.isMeshToonMaterial=true;/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  flatShading: <bool>
 * }
 */class MeshNormalMaterial extends Material{constructor(parameters){super();this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.flatShading=source.flatShading;return this;}}MeshNormalMaterial.prototype.isMeshNormalMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */class MeshLambertMaterial extends Material{constructor(parameters){super();this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshLambertMaterial.prototype.isMeshLambertMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  flatShading: <bool>
 * }
 */class MeshMatcapMaterial extends Material{constructor(parameters){super();this.defines={'MATCAP':''};this.type='MeshMatcapMaterial';this.color=new Color(0xffffff);// diffuse
this.matcap=null;this.map=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.defines={'MATCAP':''};this.color.copy(source.color);this.matcap=source.matcap;this.map=source.map;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.flatShading=source.flatShading;return this;}}MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */class LineDashedMaterial extends LineBasicMaterial{constructor(parameters){super();this.type='LineDashedMaterial';this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters);}copy(source){super.copy(source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;}}LineDashedMaterial.prototype.isLineDashedMaterial=true;var Materials=/*#__PURE__*/Object.freeze({__proto__:null,ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});const AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
// but array.subarray(from) or array.subarray(from, len) is correct
return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
convertArray:function(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
}return Array.prototype.slice.call(array);// create Array
},isTypedArray:function(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
getKeyframeOrder:function(times){function compareTime(i,j){return times[i]-times[j];}const n=times.length;const result=new Array(n);for(let i=0;i!==n;++i)result[i]=i;result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function(values,stride,order){const nValues=values.length;const result=new values.constructor(nValues);for(let i=0,dstOffset=0;dstOffset!==nValues;++i){const srcOffset=order[i]*stride;for(let j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
flattenJSON:function(jsonKeys,times,values,valuePropertyName){let i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
let value=key[valuePropertyName];if(value===undefined)return;// no data
if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}},subclip:function(sourceClip,name,startFrame,endFrame,fps=30){const clip=sourceClip.clone();clip.name=name;const tracks=[];for(let i=0;i<clip.tracks.length;++i){const track=clip.tracks[i];const valueSize=track.getValueSize();const times=[];const values=[];for(let j=0;j<track.times.length;++j){const frame=track.times[j]*fps;if(frame<startFrame||frame>=endFrame)continue;times.push(track.times[j]);for(let k=0;k<valueSize;++k){values.push(track.values[j*valueSize+k]);}}if(times.length===0)continue;track.times=AnimationUtils.convertArray(times,track.times.constructor);track.values=AnimationUtils.convertArray(values,track.values.constructor);tracks.push(track);}clip.tracks=tracks;// find minimum .times value across all tracks in the trimmed clip
let minStartTime=Infinity;for(let i=0;i<clip.tracks.length;++i){if(minStartTime>clip.tracks[i].times[0]){minStartTime=clip.tracks[i].times[0];}}// shift all tracks such that clip begins at t=0
for(let i=0;i<clip.tracks.length;++i){clip.tracks[i].shift(-1*minStartTime);}clip.resetDuration();return clip;},makeClipAdditive:function(targetClip,referenceFrame=0,referenceClip=targetClip,fps=30){if(fps<=0)fps=30;const numTracks=referenceClip.tracks.length;const referenceTime=referenceFrame/fps;// Make each track's values relative to the values at the reference frame
for(let i=0;i<numTracks;++i){const referenceTrack=referenceClip.tracks[i];const referenceTrackType=referenceTrack.ValueTypeName;// Skip this track if it's non-numeric
if(referenceTrackType==='bool'||referenceTrackType==='string')continue;// Find the track in the target clip whose name and type matches the reference track
const targetTrack=targetClip.tracks.find(function(track){return track.name===referenceTrack.name&&track.ValueTypeName===referenceTrackType;});if(targetTrack===undefined)continue;let referenceOffset=0;const referenceValueSize=referenceTrack.getValueSize();if(referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){referenceOffset=referenceValueSize/3;}let targetOffset=0;const targetValueSize=targetTrack.getValueSize();if(targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){targetOffset=targetValueSize/3;}const lastIndex=referenceTrack.times.length-1;let referenceValue;// Find the value to subtract out of the track
if(referenceTime<=referenceTrack.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
const startIndex=referenceOffset;const endIndex=referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,startIndex,endIndex);}else if(referenceTime>=referenceTrack.times[lastIndex]){// Reference frame is after the last keyframe, so just use the last keyframe
const startIndex=lastIndex*referenceValueSize+referenceOffset;const endIndex=startIndex+referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,startIndex,endIndex);}else{// Interpolate to the reference value
const interpolant=referenceTrack.createInterpolant();const startIndex=referenceOffset;const endIndex=referenceValueSize-referenceOffset;interpolant.evaluate(referenceTime);referenceValue=AnimationUtils.arraySlice(interpolant.resultBuffer,startIndex,endIndex);}// Conjugate the quaternion
if(referenceTrackType==='quaternion'){const referenceQuat=new Quaternion().fromArray(referenceValue).normalize().conjugate();referenceQuat.toArray(referenceValue);}// Subtract the reference value from all of the track values
const numTimes=targetTrack.times.length;for(let j=0;j<numTimes;++j){const valueStart=j*targetValueSize+targetOffset;if(referenceTrackType==='quaternion'){// Multiply the conjugate for quaternion track types
Quaternion.multiplyQuaternionsFlat(targetTrack.values,valueStart,referenceValue,0,targetTrack.values,valueStart);}else{const valueEnd=targetValueSize-targetOffset*2;// Subtract each value for all other numeric track types
for(let k=0;k<valueEnd;++k){targetTrack.values[valueStart+k]-=referenceValue[k];}}}}targetClip.blendMode=AdditiveAnimationBlendMode;return targetClip;}};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */class Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;this.settings=null;this.DefaultSettings_={};}evaluate(t){const pp=this.parameterPositions;let i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{let right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){for(let giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
break seek;}}// prepare binary search on the right side of the index
right=pp.length;break linear_scan;}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){// looping?
const t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
t0=t1global;}// linear reverse scan
for(let giveUpAt=i1-2;;){if(t0===undefined){// before start
this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
break seek;}}// prepare binary search on the left side of the index
right=i1;i1=0;break linear_scan;}// the interval is valid
break validate_interval;}// linear scan
// binary search
while(i1<right){const mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
return this.interpolate_(i1,t0,t,t1);}getSettings_(){return this.settings||this.DefaultSettings_;}copySampleValue_(index){// copies a sample value to the result buffer
const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(let i=0;i!==stride;++i){result[i]=values[offset+i];}return result;}// Template methods for derived classes:
interpolate_(/* i1, t0, t, t1 */){throw new Error('call to abstract method');// implementations shall return this.resultBuffer
}intervalChanged_(/* i1, t0, t1 */){// empty
}}// ALIAS DEFINITIONS
Interpolant.prototype.beforeStart_=Interpolant.prototype.copySampleValue_;Interpolant.prototype.afterEnd_=Interpolant.prototype.copySampleValue_;/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */class CubicInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};}intervalChanged_(i1,t0,t1){const pp=this.parameterPositions;let iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;tNext=t0;}}const halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
const sP=-wP*ppp+2*wP*pp-wP*p;const s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;const s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;const sN=wN*ppp-wN*pp;// combine data linearly
for(let i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}}class LinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(let i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}}/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */class DiscreteInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}}class KeyframeTrack{constructor(name,times,values,interpolation){if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);}// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
static toJSON(track){const trackType=track.constructor;let json;// derived classes can define a static toJSON method
if(trackType.toJSON!==this.toJSON){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};const interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
return json;}InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);}InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);}InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);}setInterpolation(interpolation){let factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){const message='unsupported interpolation for '+this.ValueTypeName+' keyframe track named '+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
}}console.warn('THREE.KeyframeTrack:',message);return this;}this.createInterpolant=factoryMethod;return this;}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}}getValueSize(){return this.values.length/this.times.length;}// move all keyframes either forwards or backwards in time
shift(timeOffset){if(timeOffset!==0.0){const times=this.times;for(let i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale(timeScale){if(timeScale!==1.0){const times=this.times;for(let i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim(startTime,endTime){const times=this.times,nKeys=times.length;let from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
if(from>=to){to=Math.max(to,1);from=to-1;}const stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate(){let valid=true;const valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}const times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}let prevTime=null;for(let i=0;i!==nKeys;i++){const currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(let i=0,n=values.length;i!==n;++i){const value=values[i];if(isNaN(value)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,i,value);valid=false;break;}}}}return valid;}// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
const times=AnimationUtils.arraySlice(this.times),values=AnimationUtils.arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,lastIndex=times.length-1;let writeIndex=1;for(let i=1;i<lastIndex;++i){let keep=false;const time=times[i];const timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
if(time!==timeNext&&(i!==1||time!==times[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
const offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(let j=0;j!==stride;++j){const value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else{keep=true;}}// in-place compaction
if(keep){if(i!==writeIndex){times[writeIndex]=times[i];const readOffset=i*stride,writeOffset=writeIndex*stride;for(let j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
if(lastIndex>0){times[writeIndex]=times[lastIndex];for(let readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}else{this.times=times;this.values=values;}return this;}clone(){const times=AnimationUtils.arraySlice(this.times,0);const values=AnimationUtils.arraySlice(this.values,0);const TypedKeyframeTrack=this.constructor;const track=new TypedKeyframeTrack(this.name,times,values);// Interpolant argument to constructor is not saved, so copy the factory method directly.
track.createInterpolant=this.createInterpolant;return track;}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;/**
 * A Track of Boolean keyframe values.
 */class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName='bool';BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
 * A Track of keyframe values that represent color.
 */class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName='color';/**
 * A Track of numeric keyframe values.
 */class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName='number';/**
 * Spherical linear unit quaternion interpolant.
 */class QuaternionLinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,alpha=(t-t0)/(t1-t0);let offset=i1*stride;for(let end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}}/**
 * A Track of quaternion keyframe values.
 */class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);}}QuaternionKeyframeTrack.prototype.ValueTypeName='quaternion';// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
 * A Track that interpolates Strings
 */class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName='string';StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
 * A Track of vectored keyframe values.
 */class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName='vector';class AnimationClip{constructor(name,duration=-1,tracks,blendMode=NormalAnimationBlendMode){this.name=name;this.tracks=tracks;this.duration=duration;this.blendMode=blendMode;this.uuid=generateUUID();// this means it should figure out its duration by scanning the tracks
if(this.duration<0){this.resetDuration();}}static parse(json){const tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(let i=0,n=jsonTracks.length;i!==n;++i){tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));}const clip=new this(json.name,json.duration,tracks,json.blendMode);clip.uuid=json.uuid;return clip;}static toJSON(clip){const tracks=[],clipTracks=clip.tracks;const json={'name':clip.name,'duration':clip.duration,'tracks':tracks,'uuid':clip.uuid,'blendMode':clip.blendMode};for(let i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;}static CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){const numMorphTargets=morphTargetSequence.length;const tracks=[];for(let i=0;i<numMorphTargets;i++){let times=[];let values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);const order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new this(name,-1,tracks);}static findByName(objectOrClipArray,name){let clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){const o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(let i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;}static CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){const animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
const pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(let i=0,il=morphTargets.length;i<il;i++){const morphTarget=morphTargets[i];const parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){const name=parts[1];let animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}const clips=[];for(const name in animationToMorphTargets){clips.push(this.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;}// parse the animation.hierarchy format
static parseAnimation(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}const addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
if(animationKeys.length!==0){const times=[];const values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};const tracks=[];const clipName=animation.name||'default';const fps=animation.fps||30;const blendMode=animation.blendMode;// automatic length determination in AnimationClip.
let duration=animation.length||-1;const hierarchyTracks=animation.hierarchy||[];for(let h=0;h<hierarchyTracks.length;h++){const animationKeys=hierarchyTracks[h].keys;// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;// process morph targets
if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
const morphTargetNames={};let k;for(k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(let m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(const morphTargetName in morphTargetNames){const times=[];const values=[];for(let m=0;m!==animationKeys[k].morphTargets.length;++m){const animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
const boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}const clip=new this(clipName,duration,tracks,blendMode);return clip;}resetDuration(){const tracks=this.tracks;let duration=0;for(let i=0,n=tracks.length;i!==n;++i){const track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;return this;}trim(){for(let i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;}validate(){let valid=true;for(let i=0;i<this.tracks.length;i++){valid=valid&&this.tracks[i].validate();}return valid;}optimize(){for(let i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}clone(){const tracks=[];for(let i=0;i<this.tracks.length;i++){tracks.push(this.tracks[i].clone());}return new this.constructor(this.name,this.duration,tracks,this.blendMode);}toJSON(){return this.constructor.toJSON(this);}}function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);}function parseKeyframeTrack(json){if(json.type===undefined){throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');}const trackType=getTrackTypeForValueTypeName(json.type);if(json.times===undefined){const times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we assume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);}}const Cache={enabled:false,files:{},add:function(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
this.files[key]=file;},get:function(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[key];},remove:function(key){delete this.files[key];},clear:function(){this.files={};}};class LoadingManager{constructor(onLoad,onProgress,onError){const scope=this;let isLoading=false;let itemsLoaded=0;let itemsTotal=0;let urlModifier=undefined;const handlers=[];// Refer to #5689 for the reason why we don't set .onStart
// in the constructor
this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this;};this.removeHandler=function(regex){const index=handlers.indexOf(regex);if(index!==-1){handlers.splice(index,2);}return this;};this.getHandler=function(file){for(let i=0,l=handlers.length;i<l;i+=2){const regex=handlers[i];const loader=handlers[i+1];if(regex.global)regex.lastIndex=0;// see #17920
if(regex.test(file)){return loader;}}return null;};}}const DefaultLoadingManager=new LoadingManager();class Loader{constructor(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.withCredentials=false;this.path='';this.resourcePath='';this.requestHeader={};}load(/* url, onLoad, onProgress, onError */){}loadAsync(url,onProgress){const scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject);});}parse(/* data */){}setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;}setWithCredentials(value){this.withCredentials=value;return this;}setPath(path){this.path=path;return this;}setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this;}}const loading={};class FileLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);const scope=this;const cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Check for data: URI
const dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;const dataUriRegexResult=url.match(dataUriRegex);let request;// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){const mimeType=dataUriRegexResult[1];const isBase64=!!dataUriRegexResult[2];let data=dataUriRegexResult[3];data=decodeURIComponent(data);if(isBase64)data=atob(data);try{let response;const responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':const view=new Uint8Array(data.length);for(let i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([view.buffer],{type:mimeType});}else{response=view.buffer;}break;case'document':const parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
response=data;break;}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){if(onError)onError(error);scope.manager.itemError(url);scope.manager.itemEnd(url);},0);}}else{// Initialise array for duplicate requests
loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){const response=this.response;const callbacks=loading[url];delete loading[url];if(this.status===200||this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
if(this.status===0)console.warn('THREE.FileLoader: HTTP Status 0 received.');// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
Cache.add(url,response);for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else{for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);}},false);request.addEventListener('progress',function(event){const callbacks=loading[url];for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onProgress)callback.onProgress(event);}},false);request.addEventListener('error',function(event){const callbacks=loading[url];delete loading[url];for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);request.addEventListener('abort',function(event){const callbacks=loading[url];delete loading[url];for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(const header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;}setResponseType(value){this.responseType=value;return this;}setMimeType(value){this.mimeType=value;return this;}}class AnimationLoader extends (/* unused pure expression or super */ null && (Loader)){constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)));}catch(e){if(onError){onError(e);}else{console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}parse(json){const animations=[];for(let i=0;i<json.length;i++){const clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;}}/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */class CompressedTextureLoader extends (/* unused pure expression or super */ null && (Loader)){constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const images=[];const texture=new CompressedTexture();const loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(scope.withCredentials);let loaded=0;function loadTexture(i){loader.load(url[i],function(buffer){const texDatas=scope.parse(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.image=images;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){for(let i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
loader.load(url,function(buffer){const texDatas=scope.parse(buffer,true);if(texDatas.isCubemap){const faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(let f=0;f<faces;f++){images[f]={mipmaps:[]};for(let i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}texture.image=images;}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;}}class ImageLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);const scope=this;const cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}const image=document.createElementNS('http://www.w3.org/1999/xhtml','img');function onImageLoad(){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);}function onImageError(event){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);if(onError)onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url);}image.addEventListener('load',onImageLoad,false);image.addEventListener('error',onImageError,false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;}}class CubeTextureLoader extends Loader{constructor(manager){super(manager);}load(urls,onLoad,onProgress,onError){const texture=new CubeTexture();const loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);let loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(let i=0;i<urls.length;++i){loadTexture(i);}return texture;}}/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */class DataTextureLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const texture=new DataTexture();const loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setRequestHeader(this.requestHeader);loader.setPath(this.path);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){const texData=scope.parse(buffer);if(!texData)return;if(texData.image!==undefined){texture.image=texData.image;}else if(texData.data!==undefined){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=texData.wrapS!==undefined?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=texData.wrapT!==undefined?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=texData.magFilter!==undefined?texData.magFilter:LinearFilter;texture.minFilter=texData.minFilter!==undefined?texData.minFilter:LinearFilter;texture.anisotropy=texData.anisotropy!==undefined?texData.anisotropy:1;if(texData.encoding!==undefined){texture.encoding=texData.encoding;}if(texData.flipY!==undefined){texture.flipY=texData.flipY;}if(texData.format!==undefined){texture.format=texData.format;}if(texData.type!==undefined){texture.type=texData.type;}if(texData.mipmaps!==undefined){texture.mipmaps=texData.mipmaps;texture.minFilter=LinearMipmapLinearFilter;// presumably...
}if(texData.mipmapCount===1){texture.minFilter=LinearFilter;}if(texData.generateMipmaps!==undefined){texture.generateMipmaps=texData.generateMipmaps;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}}class TextureLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const texture=new Texture();const loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
const isJPEG=url.search(/\.jpe?g($|\?)/i)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;}}/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/class CurvePath extends Curve{constructor(){super();this.type='CurvePath';this.curves=[];this.autoClose=false;// Automatically closes the path
}add(curve){this.curves.push(curve);}closePath(){// Add a line curve if start and end of lines are not connected
const startPoint=this.curves[0].getPoint(0);const endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}}// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint(t){const d=t*this.getLength();const curveLengths=this.getCurveLengths();let i=0;// To think about boundaries points.
while(i<curveLengths.length){if(curveLengths[i]>=d){const diff=curveLengths[i]-d;const curve=this.curves[i];const segmentLength=curve.getLength();const u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
}// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength(){const lens=this.getCurveLengths();return lens[lens.length-1];}// cacheLengths must be recalculated.
updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();}// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
// Push sums into cached array
const lengths=[];let sums=0;for(let i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;}getSpacedPoints(divisions=40){const points=[];for(let i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;}getPoints(divisions=12){const points=[];let last;for(let i=0,curves=this.curves;i<curves.length;i++){const curve=curves[i];const resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&(curve.isLineCurve||curve.isLineCurve3)?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;const pts=curve.getPoints(resolution);for(let j=0;j<pts.length;j++){const point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;}copy(source){super.copy(source);this.curves=[];for(let i=0,l=source.curves.length;i<l;i++){const curve=source.curves[i];this.curves.push(curve.clone());}this.autoClose=source.autoClose;return this;}toJSON(){const data=super.toJSON();data.autoClose=this.autoClose;data.curves=[];for(let i=0,l=this.curves.length;i<l;i++){const curve=this.curves[i];data.curves.push(curve.toJSON());}return data;}fromJSON(json){super.fromJSON(json);this.autoClose=json.autoClose;this.curves=[];for(let i=0,l=json.curves.length;i<l;i++){const curve=json.curves[i];this.curves.push(new Curves[curve.type]().fromJSON(curve));}return this;}}class Path extends CurvePath{constructor(points){super();this.type='Path';this.currentPoint=new Vector2();if(points){this.setFromPoints(points);}}setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(let i=1,l=points.length;i<l;i++){this.lineTo(points[i].x,points[i].y);}return this;}moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
return this;}lineTo(x,y){const curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);return this;}quadraticCurveTo(aCPx,aCPy,aX,aY){const curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){const curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}splineThru(pts/*Array of Vector*/){const npts=[this.currentPoint.clone()].concat(pts);const curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);return this;}arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){const x0=this.currentPoint.x;const y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const x0=this.currentPoint.x;const y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);return this;}absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
const firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);const lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);return this;}copy(source){super.copy(source);this.currentPoint.copy(source.currentPoint);return this;}toJSON(){const data=super.toJSON();data.currentPoint=this.currentPoint.toArray();return data;}fromJSON(json){super.fromJSON(json);this.currentPoint.fromArray(json.currentPoint);return this;}}class Shape extends Path{constructor(points){super(points);this.uuid=generateUUID();this.type='Shape';this.holes=[];}getPointsHoles(divisions){const holesPts=[];for(let i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;}// get points of shape and holes (keypoints based on segments parameter)
extractPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};}copy(source){super.copy(source);this.holes=[];for(let i=0,l=source.holes.length;i<l;i++){const hole=source.holes[i];this.holes.push(hole.clone());}return this;}toJSON(){const data=super.toJSON();data.uuid=this.uuid;data.holes=[];for(let i=0,l=this.holes.length;i<l;i++){const hole=this.holes[i];data.holes.push(hole.toJSON());}return data;}fromJSON(json){super.fromJSON(json);this.uuid=json.uuid;this.holes=[];for(let i=0,l=json.holes.length;i<l;i++){const hole=json.holes[i];this.holes.push(new Path().fromJSON(hole));}return this;}}class Light extends Object3D{constructor(color,intensity=1){super();this.type='Light';this.color=new Color(color);this.intensity=intensity;}dispose(){// Empty here in base class; some subclasses override.
}copy(source){super.copy(source);this.color.copy(source.color);this.intensity=source.intensity;return this;}toJSON(meta){const data=super.toJSON(meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}}Light.prototype.isLight=true;class HemisphereLight extends Light{constructor(skyColor,groundColor,intensity){super(skyColor,intensity);this.type='HemisphereLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}}HemisphereLight.prototype.isHemisphereLight=true;const _projScreenMatrix$1=/*@__PURE__*/new Matrix4();const _lightPositionWorld$1=/*@__PURE__*/new three_module_Vector3();const _lookTarget$1=/*@__PURE__*/new three_module_Vector3();class LightShadow{constructor(camera){this.camera=camera;this.bias=0;this.normalBias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4();this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}getViewportCount(){return this._viewportCount;}getFrustum(){return this._frustum;}updateMatrices(light){const shadowCamera=this.camera;const shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}getViewport(viewportIndex){return this._viewports[viewportIndex];}getFrameExtents(){return this._frameExtents;}dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;}clone(){return new this.constructor().copy(this);}toJSON(){const object={};if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,0.5,500));this.focus=1;}updateMatrices(light){const camera=this.camera;const fov=RAD2DEG*2*light.angle*this.focus;const aspect=this.mapSize.width/this.mapSize.height;const far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}super.updateMatrices(light);}copy(source){super.copy(source);this.focus=source.focus;return this;}}SpotLightShadow.prototype.isSpotLightShadow=true;class SpotLight extends Light{constructor(color,intensity,distance=0,angle=Math.PI/3,penumbra=0,decay=1){super(color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.distance=distance;this.angle=angle;this.penumbra=penumbra;this.decay=decay;// for physically correct lights, should be 2.
this.shadow=new SpotLightShadow();}get power(){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*Math.PI;}set power(power){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/Math.PI;}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}SpotLight.prototype.isSpotLight=true;const _projScreenMatrix=/*@__PURE__*/new Matrix4();const _lightPositionWorld=/*@__PURE__*/new three_module_Vector3();const _lookTarget=/*@__PURE__*/new three_module_Vector3();class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,0.5,500));this._frameExtents=new Vector2(4,2);this._viewportCount=6;this._viewports=[// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
new Vector4(2,1,1,1),// negative X
new Vector4(0,1,1,1),// positive Z
new Vector4(3,1,1,1),// negative Z
new Vector4(1,1,1,1),// positive Y
new Vector4(3,0,1,1),// negative Y
new Vector4(1,0,1,1)];this._cubeDirections=[new three_module_Vector3(1,0,0),new three_module_Vector3(-1,0,0),new three_module_Vector3(0,0,1),new three_module_Vector3(0,0,-1),new three_module_Vector3(0,1,0),new three_module_Vector3(0,-1,0)];this._cubeUps=[new three_module_Vector3(0,1,0),new three_module_Vector3(0,1,0),new three_module_Vector3(0,1,0),new three_module_Vector3(0,1,0),new three_module_Vector3(0,0,1),new three_module_Vector3(0,0,-1)];}updateMatrices(light,viewportIndex=0){const camera=this.camera;const shadowMatrix=this.matrix;const far=light.distance||camera.far;if(far!==camera.far){camera.far=far;camera.updateProjectionMatrix();}_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(_lightPositionWorld);_lookTarget.copy(camera.position);_lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(_lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix);}}PointLightShadow.prototype.isPointLightShadow=true;class PointLight extends Light{constructor(color,intensity,distance=0,decay=1){super(color,intensity);this.type='PointLight';this.distance=distance;this.decay=decay;// for physically correct lights, should be 2.
this.shadow=new PointLightShadow();}get power(){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*4*Math.PI;}set power(power){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/(4*Math.PI);}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}}PointLight.prototype.isPointLight=true;class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,0.5,500));}}DirectionalLightShadow.prototype.isDirectionalLightShadow=true;class DirectionalLight extends Light{constructor(color,intensity){super(color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}DirectionalLight.prototype.isDirectionalLight=true;class AmbientLight extends Light{constructor(color,intensity){super(color,intensity);this.type='AmbientLight';}}AmbientLight.prototype.isAmbientLight=true;class RectAreaLight extends Light{constructor(color,intensity,width=10,height=10){super(color,intensity);this.type='RectAreaLight';this.width=width;this.height=height;}copy(source){super.copy(source);this.width=source.width;this.height=source.height;return this;}toJSON(meta){const data=super.toJSON(meta);data.object.width=this.width;data.object.height=this.height;return data;}}RectAreaLight.prototype.isRectAreaLight=true;/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
class SphericalHarmonics3{constructor(){this.coefficients=[];for(let i=0;i<9;i++){this.coefficients.push(new three_module_Vector3());}}set(coefficients){for(let i=0;i<9;i++){this.coefficients[i].copy(coefficients[i]);}return this;}zero(){for(let i=0;i<9;i++){this.coefficients[i].set(0,0,0);}return this;}// get the radiance in the direction of the normal
// target is a Vector3
getAt(normal,target){// normal is assumed to be unit length
const x=normal.x,y=normal.y,z=normal.z;const coeff=this.coefficients;// band 0
target.copy(coeff[0]).multiplyScalar(0.282095);// band 1
target.addScaledVector(coeff[1],0.488603*y);target.addScaledVector(coeff[2],0.488603*z);target.addScaledVector(coeff[3],0.488603*x);// band 2
target.addScaledVector(coeff[4],1.092548*(x*y));target.addScaledVector(coeff[5],1.092548*(y*z));target.addScaledVector(coeff[6],0.315392*(3.0*z*z-1.0));target.addScaledVector(coeff[7],1.092548*(x*z));target.addScaledVector(coeff[8],0.546274*(x*x-y*y));return target;}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt(normal,target){// normal is assumed to be unit length
const x=normal.x,y=normal.y,z=normal.z;const coeff=this.coefficients;// band 0
target.copy(coeff[0]).multiplyScalar(0.886227);// π * 0.282095
// band 1
target.addScaledVector(coeff[1],2.0*0.511664*y);// ( 2 * π / 3 ) * 0.488603
target.addScaledVector(coeff[2],2.0*0.511664*z);target.addScaledVector(coeff[3],2.0*0.511664*x);// band 2
target.addScaledVector(coeff[4],2.0*0.429043*x*y);// ( π / 4 ) * 1.092548
target.addScaledVector(coeff[5],2.0*0.429043*y*z);target.addScaledVector(coeff[6],0.743125*z*z-0.247708);// ( π / 4 ) * 0.315392 * 3
target.addScaledVector(coeff[7],2.0*0.429043*x*z);target.addScaledVector(coeff[8],0.429043*(x*x-y*y));// ( π / 4 ) * 0.546274
return target;}add(sh){for(let i=0;i<9;i++){this.coefficients[i].add(sh.coefficients[i]);}return this;}addScaledSH(sh,s){for(let i=0;i<9;i++){this.coefficients[i].addScaledVector(sh.coefficients[i],s);}return this;}scale(s){for(let i=0;i<9;i++){this.coefficients[i].multiplyScalar(s);}return this;}lerp(sh,alpha){for(let i=0;i<9;i++){this.coefficients[i].lerp(sh.coefficients[i],alpha);}return this;}equals(sh){for(let i=0;i<9;i++){if(!this.coefficients[i].equals(sh.coefficients[i])){return false;}}return true;}copy(sh){return this.set(sh.coefficients);}clone(){return new this.constructor().copy(this);}fromArray(array,offset=0){const coefficients=this.coefficients;for(let i=0;i<9;i++){coefficients[i].fromArray(array,offset+i*3);}return this;}toArray(array=[],offset=0){const coefficients=this.coefficients;for(let i=0;i<9;i++){coefficients[i].toArray(array,offset+i*3);}return array;}// evaluate the basis functions
// shBasis is an Array[ 9 ]
static getBasisAt(normal,shBasis){// normal is assumed to be unit length
const x=normal.x,y=normal.y,z=normal.z;// band 0
shBasis[0]=0.282095;// band 1
shBasis[1]=0.488603*y;shBasis[2]=0.488603*z;shBasis[3]=0.488603*x;// band 2
shBasis[4]=1.092548*x*y;shBasis[5]=1.092548*y*z;shBasis[6]=0.315392*(3*z*z-1);shBasis[7]=1.092548*x*z;shBasis[8]=0.546274*(x*x-y*y);}}SphericalHarmonics3.prototype.isSphericalHarmonics3=true;class LightProbe extends Light{constructor(sh=new SphericalHarmonics3(),intensity=1){super(undefined,intensity);this.sh=sh;}copy(source){super.copy(source);this.sh.copy(source.sh);return this;}fromJSON(json){this.intensity=json.intensity;// TODO: Move this bit to Light.fromJSON();
this.sh.fromArray(json.sh);return this;}toJSON(meta){const data=super.toJSON(meta);data.object.sh=this.sh.toArray();return data;}}LightProbe.prototype.isLightProbe=true;class MaterialLoader extends (/* unused pure expression or super */ null && (Loader)){constructor(manager){super(manager);this.textures={};}load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)));}catch(e){if(onError){onError(e);}else{console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}parse(json){const textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}const material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined&&material.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.sheen!==undefined)material.sheen=new Color().setHex(json.sheen);if(json.emissive!==undefined&&material.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined&&material.specular!==undefined)material.specular.setHex(json.specular);if(json.specularIntensity!==undefined)material.specularIntensity=json.specularIntensity;if(json.specularTint!==undefined&&material.specularTint!==undefined)material.specularTint.setHex(json.specularTint);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearcoat!==undefined)material.clearcoat=json.clearcoat;if(json.clearcoatRoughness!==undefined)material.clearcoatRoughness=json.clearcoatRoughness;if(json.transmission!==undefined)material.transmission=json.transmission;if(json.thickness!==undefined)material.thickness=json.thickness;if(json.attenuationDistance!==undefined)material.attenuationDistance=json.attenuationDistance;if(json.attenuationTint!==undefined&&material.attenuationTint!==undefined)material.attenuationTint.setHex(json.attenuationTint);if(json.fog!==undefined)material.fog=json.fog;if(json.flatShading!==undefined)material.flatShading=json.flatShading;if(json.blending!==undefined)material.blending=json.blending;if(json.combine!==undefined)material.combine=json.combine;if(json.side!==undefined)material.side=json.side;if(json.shadowSide!==undefined)material.shadowSide=json.shadowSide;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.stencilWrite!==undefined)material.stencilWrite=json.stencilWrite;if(json.stencilWriteMask!==undefined)material.stencilWriteMask=json.stencilWriteMask;if(json.stencilFunc!==undefined)material.stencilFunc=json.stencilFunc;if(json.stencilRef!==undefined)material.stencilRef=json.stencilRef;if(json.stencilFuncMask!==undefined)material.stencilFuncMask=json.stencilFuncMask;if(json.stencilFail!==undefined)material.stencilFail=json.stencilFail;if(json.stencilZFail!==undefined)material.stencilZFail=json.stencilZFail;if(json.stencilZPass!==undefined)material.stencilZPass=json.stencilZPass;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.rotation!==undefined)material.rotation=json.rotation;if(json.linewidth!==1)material.linewidth=json.linewidth;if(json.dashSize!==undefined)material.dashSize=json.dashSize;if(json.gapSize!==undefined)material.gapSize=json.gapSize;if(json.scale!==undefined)material.scale=json.scale;if(json.polygonOffset!==undefined)material.polygonOffset=json.polygonOffset;if(json.polygonOffsetFactor!==undefined)material.polygonOffsetFactor=json.polygonOffsetFactor;if(json.polygonOffsetUnits!==undefined)material.polygonOffsetUnits=json.polygonOffsetUnits;if(json.dithering!==undefined)material.dithering=json.dithering;if(json.alphaToCoverage!==undefined)material.alphaToCoverage=json.alphaToCoverage;if(json.premultipliedAlpha!==undefined)material.premultipliedAlpha=json.premultipliedAlpha;if(json.visible!==undefined)material.visible=json.visible;if(json.toneMapped!==undefined)material.toneMapped=json.toneMapped;if(json.userData!==undefined)material.userData=json.userData;if(json.vertexColors!==undefined){if(typeof json.vertexColors==='number'){material.vertexColors=json.vertexColors>0?true:false;}else{material.vertexColors=json.vertexColors;}}// Shader Material
if(json.uniforms!==undefined){for(const name in json.uniforms){const uniform=json.uniforms[name];material.uniforms[name]={};switch(uniform.type){case't':material.uniforms[name].value=getTexture(uniform.value);break;case'c':material.uniforms[name].value=new Color().setHex(uniform.value);break;case'v2':material.uniforms[name].value=new Vector2().fromArray(uniform.value);break;case'v3':material.uniforms[name].value=new three_module_Vector3().fromArray(uniform.value);break;case'v4':material.uniforms[name].value=new Vector4().fromArray(uniform.value);break;case'm3':material.uniforms[name].value=new Matrix3().fromArray(uniform.value);break;case'm4':material.uniforms[name].value=new Matrix4().fromArray(uniform.value);break;default:material.uniforms[name].value=uniform.value;}}}if(json.defines!==undefined)material.defines=json.defines;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.extensions!==undefined){for(const key in json.extensions){material.extensions[key]=json.extensions[key];}}// Deprecated
if(json.shading!==undefined)material.flatShading=json.shading===1;// THREE.FlatShading
// for PointsMaterial
if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
if(json.map!==undefined)material.map=getTexture(json.map);if(json.matcap!==undefined)material.matcap=getTexture(json.matcap);if(json.alphaMap!==undefined)material.alphaMap=getTexture(json.alphaMap);if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalMapType!==undefined)material.normalMapType=json.normalMapType;if(json.normalScale!==undefined){let normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.specularIntensityMap!==undefined)material.specularIntensityMap=getTexture(json.specularIntensityMap);if(json.specularTintMap!==undefined)material.specularTintMap=getTexture(json.specularTintMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.envMapIntensity!==undefined)material.envMapIntensity=json.envMapIntensity;if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.refractionRatio!==undefined)material.refractionRatio=json.refractionRatio;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);if(json.clearcoatMap!==undefined)material.clearcoatMap=getTexture(json.clearcoatMap);if(json.clearcoatRoughnessMap!==undefined)material.clearcoatRoughnessMap=getTexture(json.clearcoatRoughnessMap);if(json.clearcoatNormalMap!==undefined)material.clearcoatNormalMap=getTexture(json.clearcoatNormalMap);if(json.clearcoatNormalScale!==undefined)material.clearcoatNormalScale=new Vector2().fromArray(json.clearcoatNormalScale);if(json.transmissionMap!==undefined)material.transmissionMap=getTexture(json.transmissionMap);if(json.thicknessMap!==undefined)material.thicknessMap=getTexture(json.thicknessMap);return material;}setTextures(value){this.textures=value;return this;}}class LoaderUtils{static decodeText(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.
let s='';for(let i=0,il=array.length;i<il;i++){// Implicitly assumes little-endian.
s+=String.fromCharCode(array[i]);}try{// merges multi-byte utf-8 characters.
return decodeURIComponent(escape(s));}catch(e){// see #16358
return s;}}static extractUrlBase(url){const index=url.lastIndexOf('/');if(index===-1)return'./';return url.substr(0,index+1);}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super();this.type='InstancedBufferGeometry';this.instanceCount=Infinity;}copy(source){super.copy(source);this.instanceCount=source.instanceCount;return this;}clone(){return new this.constructor().copy(this);}toJSON(){const data=super.toJSON(this);data.instanceCount=this.instanceCount;data.isInstancedBufferGeometry=true;return data;}}InstancedBufferGeometry.prototype.isInstancedBufferGeometry=true;class InstancedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized,meshPerAttribute=1){if(typeof normalized==='number'){meshPerAttribute=normalized;normalized=false;console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');}super(array,itemSize,normalized);this.meshPerAttribute=meshPerAttribute;}copy(source){super.copy(source);this.meshPerAttribute=source.meshPerAttribute;return this;}toJSON(){const data=super.toJSON();data.meshPerAttribute=this.meshPerAttribute;data.isInstancedBufferAttribute=true;return data;}}InstancedBufferAttribute.prototype.isInstancedBufferAttribute=true;class BufferGeometryLoader extends (/* unused pure expression or super */ null && (Loader)){constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)));}catch(e){if(onError){onError(e);}else{console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}parse(json){const interleavedBufferMap={};const arrayBufferMap={};function getInterleavedBuffer(json,uuid){if(interleavedBufferMap[uuid]!==undefined)return interleavedBufferMap[uuid];const interleavedBuffers=json.interleavedBuffers;const interleavedBuffer=interleavedBuffers[uuid];const buffer=getArrayBuffer(json,interleavedBuffer.buffer);const array=getTypedArray(interleavedBuffer.type,buffer);const ib=new InterleavedBuffer(array,interleavedBuffer.stride);ib.uuid=interleavedBuffer.uuid;interleavedBufferMap[uuid]=ib;return ib;}function getArrayBuffer(json,uuid){if(arrayBufferMap[uuid]!==undefined)return arrayBufferMap[uuid];const arrayBuffers=json.arrayBuffers;const arrayBuffer=arrayBuffers[uuid];const ab=new Uint32Array(arrayBuffer).buffer;arrayBufferMap[uuid]=ab;return ab;}const geometry=json.isInstancedBufferGeometry?new InstancedBufferGeometry():new BufferGeometry();const index=json.data.index;if(index!==undefined){const typedArray=getTypedArray(index.type,index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}const attributes=json.data.attributes;for(const key in attributes){const attribute=attributes[key];let bufferAttribute;if(attribute.isInterleavedBufferAttribute){const interleavedBuffer=getInterleavedBuffer(json.data,attribute.data);bufferAttribute=new InterleavedBufferAttribute(interleavedBuffer,attribute.itemSize,attribute.offset,attribute.normalized);}else{const typedArray=getTypedArray(attribute.type,attribute.array);const bufferAttributeConstr=attribute.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;bufferAttribute=new bufferAttributeConstr(typedArray,attribute.itemSize,attribute.normalized);}if(attribute.name!==undefined)bufferAttribute.name=attribute.name;if(attribute.usage!==undefined)bufferAttribute.setUsage(attribute.usage);if(attribute.updateRange!==undefined){bufferAttribute.updateRange.offset=attribute.updateRange.offset;bufferAttribute.updateRange.count=attribute.updateRange.count;}geometry.setAttribute(key,bufferAttribute);}const morphAttributes=json.data.morphAttributes;if(morphAttributes){for(const key in morphAttributes){const attributeArray=morphAttributes[key];const array=[];for(let i=0,il=attributeArray.length;i<il;i++){const attribute=attributeArray[i];let bufferAttribute;if(attribute.isInterleavedBufferAttribute){const interleavedBuffer=getInterleavedBuffer(json.data,attribute.data);bufferAttribute=new InterleavedBufferAttribute(interleavedBuffer,attribute.itemSize,attribute.offset,attribute.normalized);}else{const typedArray=getTypedArray(attribute.type,attribute.array);bufferAttribute=new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized);}if(attribute.name!==undefined)bufferAttribute.name=attribute.name;array.push(bufferAttribute);}geometry.morphAttributes[key]=array;}}const morphTargetsRelative=json.data.morphTargetsRelative;if(morphTargetsRelative){geometry.morphTargetsRelative=true;}const groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(let i=0,n=groups.length;i!==n;++i){const group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}const boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){const center=new three_module_Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}if(json.name)geometry.name=json.name;if(json.userData)geometry.userData=json.userData;return geometry;}}class ObjectLoader extends (/* unused pure expression or super */ null && (Loader)){constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const path=this.path===''?LoaderUtils.extractUrlBase(url):this.path;this.resourcePath=this.resourcePath||path;const loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){let json=null;try{json=JSON.parse(text);}catch(error){if(onError!==undefined)onError(error);console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}const metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url);return;}scope.parse(json,onLoad);},onProgress,onError);}async loadAsync(url,onProgress){const scope=this;const path=this.path===''?LoaderUtils.extractUrlBase(url):this.path;this.resourcePath=this.resourcePath||path;const loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);const text=await loader.loadAsync(url,onProgress);const json=JSON.parse(text);const metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){throw new Error('THREE.ObjectLoader: Can\'t load '+url);}return await scope.parseAsync(json);}parse(json,onLoad){const animations=this.parseAnimations(json.animations);const shapes=this.parseShapes(json.shapes);const geometries=this.parseGeometries(json.geometries,shapes);const images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});const textures=this.parseTextures(json.textures,images);const materials=this.parseMaterials(json.materials,textures);const object=this.parseObject(json.object,geometries,materials,textures,animations);const skeletons=this.parseSkeletons(json.skeletons,object);this.bindSkeletons(object,skeletons);//
if(onLoad!==undefined){let hasImages=false;for(const uuid in images){if(images[uuid]instanceof HTMLImageElement){hasImages=true;break;}}if(hasImages===false)onLoad(object);}return object;}async parseAsync(json){const animations=this.parseAnimations(json.animations);const shapes=this.parseShapes(json.shapes);const geometries=this.parseGeometries(json.geometries,shapes);const images=await this.parseImagesAsync(json.images);const textures=this.parseTextures(json.textures,images);const materials=this.parseMaterials(json.materials,textures);const object=this.parseObject(json.object,geometries,materials,textures,animations);const skeletons=this.parseSkeletons(json.skeletons,object);this.bindSkeletons(object,skeletons);return object;}parseShapes(json){const shapes={};if(json!==undefined){for(let i=0,l=json.length;i<l;i++){const shape=new Shape().fromJSON(json[i]);shapes[shape.uuid]=shape;}}return shapes;}parseSkeletons(json,object){const skeletons={};const bones={};// generate bone lookup table
object.traverse(function(child){if(child.isBone)bones[child.uuid]=child;});// create skeletons
if(json!==undefined){for(let i=0,l=json.length;i<l;i++){const skeleton=new Skeleton().fromJSON(json[i],bones);skeletons[skeleton.uuid]=skeleton;}}return skeletons;}parseGeometries(json,shapes){const geometries={};if(json!==undefined){const bufferGeometryLoader=new BufferGeometryLoader();for(let i=0,l=json.length;i<l;i++){let geometry;const data=json[i];switch(data.type){case'BufferGeometry':case'InstancedBufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');break;default:if(data.type in Geometries){geometry=Geometries[data.type].fromJSON(data,shapes);}else{console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);}}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;if(geometry.isBufferGeometry===true&&data.userData!==undefined)geometry.userData=data.userData;geometries[data.uuid]=geometry;}}return geometries;}parseMaterials(json,textures){const cache={};// MultiMaterial
const materials={};if(json!==undefined){const loader=new MaterialLoader();loader.setTextures(textures);for(let i=0,l=json.length;i<l;i++){const data=json[i];if(data.type==='MultiMaterial'){// Deprecated
const array=[];for(let j=0;j<data.materials.length;j++){const material=data.materials[j];if(cache[material.uuid]===undefined){cache[material.uuid]=loader.parse(material);}array.push(cache[material.uuid]);}materials[data.uuid]=array;}else{if(cache[data.uuid]===undefined){cache[data.uuid]=loader.parse(data);}materials[data.uuid]=cache[data.uuid];}}}return materials;}parseAnimations(json){const animations={};if(json!==undefined){for(let i=0;i<json.length;i++){const data=json[i];const clip=AnimationClip.parse(data);animations[clip.uuid]=clip;}}return animations;}parseImages(json,onLoad){const scope=this;const images={};let loader;function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemError(url);scope.manager.itemEnd(url);});}function deserializeImage(image){if(typeof image==='string'){const url=image;const path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)?url:scope.resourcePath+url;return loadImage(path);}else{if(image.data){return{data:getTypedArray(image.type,image.data),width:image.width,height:image.height};}else{return null;}}}if(json!==undefined&&json.length>0){const manager=new LoadingManager(onLoad);loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(let i=0,il=json.length;i<il;i++){const image=json[i];const url=image.url;if(Array.isArray(url)){// load array of images e.g CubeTexture
images[image.uuid]=[];for(let j=0,jl=url.length;j<jl;j++){const currentUrl=url[j];const deserializedImage=deserializeImage(currentUrl);if(deserializedImage!==null){if(deserializedImage instanceof HTMLImageElement){images[image.uuid].push(deserializedImage);}else{// special case: handle array of data textures for cube textures
images[image.uuid].push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height));}}}}else{// load single image
const deserializedImage=deserializeImage(image.url);if(deserializedImage!==null){images[image.uuid]=deserializedImage;}}}}return images;}async parseImagesAsync(json){const scope=this;const images={};let loader;async function deserializeImage(image){if(typeof image==='string'){const url=image;const path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)?url:scope.resourcePath+url;return await loader.loadAsync(path);}else{if(image.data){return{data:getTypedArray(image.type,image.data),width:image.width,height:image.height};}else{return null;}}}if(json!==undefined&&json.length>0){loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);for(let i=0,il=json.length;i<il;i++){const image=json[i];const url=image.url;if(Array.isArray(url)){// load array of images e.g CubeTexture
images[image.uuid]=[];for(let j=0,jl=url.length;j<jl;j++){const currentUrl=url[j];const deserializedImage=await deserializeImage(currentUrl);if(deserializedImage!==null){if(deserializedImage instanceof HTMLImageElement){images[image.uuid].push(deserializedImage);}else{// special case: handle array of data textures for cube textures
images[image.uuid].push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height));}}}}else{// load single image
const deserializedImage=await deserializeImage(image.url);if(deserializedImage!==null){images[image.uuid]=deserializedImage;}}}}return images;}parseTextures(json,images){function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}const textures={};if(json!==undefined){for(let i=0,l=json.length;i<l;i++){const data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}let texture;const image=images[data.image];if(Array.isArray(image)){texture=new CubeTexture(image);if(image.length===6)texture.needsUpdate=true;}else{if(image&&image.data){texture=new DataTexture(image.data,image.width,image.height);}else{texture=new Texture(image);}if(image)texture.needsUpdate=true;// textures can have undefined image data
}texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.center!==undefined)texture.center.fromArray(data.center);if(data.rotation!==undefined)texture.rotation=data.rotation;if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);}if(data.format!==undefined)texture.format=data.format;if(data.type!==undefined)texture.type=data.type;if(data.encoding!==undefined)texture.encoding=data.encoding;if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;if(data.premultiplyAlpha!==undefined)texture.premultiplyAlpha=data.premultiplyAlpha;if(data.unpackAlignment!==undefined)texture.unpackAlignment=data.unpackAlignment;textures[data.uuid]=texture;}}return textures;}parseObject(data,geometries,materials,textures,animations){let object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if(Array.isArray(name)){const array=[];for(let i=0,l=name.length;i<l;i++){const uuid=name[i];if(materials[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined material',uuid);}array.push(materials[uuid]);}return array;}if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}function getTexture(uuid){if(textures[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined texture',uuid);}return textures[uuid];}let geometry,material;switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if(Number.isInteger(data.background)){object.background=new Color(data.background);}else{object.background=getTexture(data.background);}}if(data.environment!==undefined){object.environment=getTexture(data.environment);}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);if(data.zoom!==undefined)object.zoom=data.zoom;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'RectAreaLight':object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'LightProbe':object=new LightProbe().fromJSON(data);break;case'SkinnedMesh':geometry=getGeometry(data.geometry);material=getMaterial(data.material);object=new SkinnedMesh(geometry,material);if(data.bindMode!==undefined)object.bindMode=data.bindMode;if(data.bindMatrix!==undefined)object.bindMatrix.fromArray(data.bindMatrix);if(data.skeleton!==undefined)object.skeleton=data.skeleton;break;case'Mesh':geometry=getGeometry(data.geometry);material=getMaterial(data.material);object=new three_module_Mesh(geometry,material);break;case'InstancedMesh':geometry=getGeometry(data.geometry);material=getMaterial(data.material);const count=data.count;const instanceMatrix=data.instanceMatrix;const instanceColor=data.instanceColor;object=new InstancedMesh(geometry,material,count);object.instanceMatrix=new BufferAttribute(new Float32Array(instanceMatrix.array),16);if(instanceColor!==undefined)object.instanceColor=new BufferAttribute(new Float32Array(instanceColor.array),instanceColor.itemSize);break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material));break;case'LineLoop':object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;case'Bone':object=new Bone();break;default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){object.matrix.fromArray(data.matrix);if(data.matrixAutoUpdate!==undefined)object.matrixAutoUpdate=data.matrixAutoUpdate;if(object.matrixAutoUpdate)object.matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.normalBias!==undefined)object.shadow.normalBias=data.shadow.normalBias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.frustumCulled!==undefined)object.frustumCulled=data.frustumCulled;if(data.renderOrder!==undefined)object.renderOrder=data.renderOrder;if(data.userData!==undefined)object.userData=data.userData;if(data.layers!==undefined)object.layers.mask=data.layers;if(data.children!==undefined){const children=data.children;for(let i=0;i<children.length;i++){object.add(this.parseObject(children[i],geometries,materials,textures,animations));}}if(data.animations!==undefined){const objectAnimations=data.animations;for(let i=0;i<objectAnimations.length;i++){const uuid=objectAnimations[i];object.animations.push(animations[uuid]);}}if(data.type==='LOD'){if(data.autoUpdate!==undefined)object.autoUpdate=data.autoUpdate;const levels=data.levels;for(let l=0;l<levels.length;l++){const level=levels[l];const child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;}bindSkeletons(object,skeletons){if(Object.keys(skeletons).length===0)return;object.traverse(function(child){if(child.isSkinnedMesh===true&&child.skeleton!==undefined){const skeleton=skeletons[child.skeleton];if(skeleton===undefined){console.warn('THREE.ObjectLoader: No skeleton found with UUID:',child.skeleton);}else{child.bind(skeleton,child.bindMatrix);}}});}/* DEPRECATED */setTexturePath(value){console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');return this.setResourcePath(value);}}const TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};const TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};const TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipmapNearestFilter:NearestMipmapNearestFilter,NearestMipmapLinearFilter:NearestMipmapLinearFilter,LinearFilter:LinearFilter,LinearMipmapNearestFilter:LinearMipmapNearestFilter,LinearMipmapLinearFilter:LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader{constructor(manager){super(manager);if(typeof createImageBitmap==='undefined'){console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');}if(typeof fetch==='undefined'){console.warn('THREE.ImageBitmapLoader: fetch() not supported.');}this.options={premultiplyAlpha:'none'};}setOptions(options){this.options=options;return this;}load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);const scope=this;const cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}const fetchOptions={};fetchOptions.credentials=this.crossOrigin==='anonymous'?'same-origin':'include';fetchOptions.headers=this.requestHeader;fetch(url,fetchOptions).then(function(res){return res.blob();}).then(function(blob){return createImageBitmap(blob,Object.assign(scope.options,{colorSpaceConversion:'none'}));}).then(function(imageBitmap){Cache.add(url,imageBitmap);if(onLoad)onLoad(imageBitmap);scope.manager.itemEnd(url);}).catch(function(e){if(onError)onError(e);scope.manager.itemError(url);scope.manager.itemEnd(url);});scope.manager.itemStart(url);}}ImageBitmapLoader.prototype.isImageBitmapLoader=true;class ShapePath{constructor(){this.type='ShapePath';this.color=new Color();this.subPaths=[];this.currentPath=null;}moveTo(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);return this;}lineTo(x,y){this.currentPath.lineTo(x,y);return this;}quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);return this;}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);return this;}splineThru(pts){this.currentPath.splineThru(pts);return this;}toShapes(isCCW,noHoles){function toShapesNoHoles(inSubpaths){const shapes=[];for(let i=0,l=inSubpaths.length;i<l;i++){const tmpPath=inSubpaths[i];const tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){const polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
let inside=false;for(let p=polyLen-1,q=0;q<polyLen;p=q++){let edgeLowPt=inPolygon[p];let edgeHighPt=inPolygon[q];let edgeDx=edgeHighPt.x-edgeLowPt.x;let edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){// not parallel
if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!
}else{const perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
}}else{// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;
}}return inside;}const isClockWise=ShapeUtils.isClockWise;const subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);let solid,tmpPath,tmpShape;const shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}let holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
const betterShapeHoles=[];const newShapes=[];let newShapeHoles=[];let mainIdx=0;let tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(let i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
}}// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){let ambiguous=false;const toChange=[];for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){const sho=newShapeHoles[sIdx];for(let hIdx=0;hIdx<sho.length;hIdx++){const ho=sho[hIdx];let hole_unassigned=true;for(let s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;}}let tmpHoles;for(let i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(let j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
return shapes;}}class Font{constructor(data){this.type='Font';this.data=data;}generateShapes(text,size=100){const shapes=[];const paths=createPaths(text,size,this.data);for(let p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}}function createPaths(text,size,data){const chars=Array.from(text);const scale=size/data.resolution;const line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;const paths=[];let offsetX=0,offsetY=0;for(let i=0;i<chars.length;i++){const char=chars[i];if(char==='\n'){offsetX=0;offsetY-=line_height;}else{const ret=createPath(char,scale,offsetX,offsetY,data);offsetX+=ret.offsetX;paths.push(ret.path);}}return paths;}function createPath(char,scale,offsetX,offsetY,data){const glyph=data.glyphs[char]||data.glyphs['?'];if(!glyph){console.error('THREE.Font: character "'+char+'" does not exists in font family '+data.familyName+'.');return;}const path=new ShapePath();let x,y,cpx,cpy,cpx1,cpy1,cpx2,cpy2;if(glyph.o){const outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(let i=0,l=outline.length;i<l;){const action=outline[i++];switch(action){case'm':// moveTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.moveTo(x,y);break;case'l':// lineTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.lineTo(x,y);break;case'q':// quadraticCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);break;case'b':// bezierCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;cpx2=outline[i++]*scale+offsetX;cpy2=outline[i++]*scale+offsetY;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);break;}}}return{offsetX:glyph.ha*scale,path:path};}Font.prototype.isFont=true;class FontLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){let json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}const font=scope.parse(json);if(onLoad)onLoad(font);},onProgress,onError);}parse(json){return new Font(json);}}let _context;const AudioContext={getContext:function(){if(_context===undefined){_context=new(window.AudioContext||window.webkitAudioContext)();}return _context;},setContext:function(value){_context=value;}};class AudioLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){const scope=this;const loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(buffer){try{// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
const bufferCopy=buffer.slice(0);const context=AudioContext.getContext();context.decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer);});}catch(e){if(onError){onError(e);}else{console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}}class HemisphereLightProbe extends LightProbe{constructor(skyColor,groundColor,intensity=1){super(undefined,intensity);const color1=new Color().set(skyColor);const color2=new Color().set(groundColor);const sky=new three_module_Vector3(color1.r,color1.g,color1.b);const ground=new three_module_Vector3(color2.r,color2.g,color2.b);// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
const c0=Math.sqrt(Math.PI);const c1=c0*Math.sqrt(0.75);this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);}}HemisphereLightProbe.prototype.isHemisphereLightProbe=true;class AmbientLightProbe extends LightProbe{constructor(color,intensity=1){super(undefined,intensity);const color1=new Color().set(color);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(color1.r,color1.g,color1.b).multiplyScalar(2*Math.sqrt(Math.PI));}}AmbientLightProbe.prototype.isAmbientLightProbe=true;const _eyeRight=/*@__PURE__*/new Matrix4();const _eyeLeft=/*@__PURE__*/new Matrix4();class StereoCamera{constructor(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null};}update(camera){const cache=this._cache;const needsUpdate=cache.focus!==camera.focus||cache.fov!==camera.fov||cache.aspect!==camera.aspect*this.aspect||cache.near!==camera.near||cache.far!==camera.far||cache.zoom!==camera.zoom||cache.eyeSep!==this.eyeSep;if(needsUpdate){cache.focus=camera.focus;cache.fov=camera.fov;cache.aspect=camera.aspect*this.aspect;cache.near=camera.near;cache.far=camera.far;cache.zoom=camera.zoom;cache.eyeSep=this.eyeSep;// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
const projectionMatrix=camera.projectionMatrix.clone();const eyeSepHalf=cache.eyeSep/2;const eyeSepOnProjection=eyeSepHalf*cache.near/cache.focus;const ymax=cache.near*Math.tan(DEG2RAD*cache.fov*0.5)/cache.zoom;let xmin,xmax;// translate xOffset
_eyeLeft.elements[12]=-eyeSepHalf;_eyeRight.elements[12]=eyeSepHalf;// for left eye
xmin=-ymax*cache.aspect+eyeSepOnProjection;xmax=ymax*cache.aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*cache.near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
xmin=-ymax*cache.aspect-eyeSepOnProjection;xmax=ymax*cache.aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*cache.near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);}}class Clock{constructor(autoStart=true){this.autoStart=autoStart;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}start(){this.startTime=now();this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;}stop(){this.getElapsedTime();this.running=false;this.autoStart=false;}getElapsedTime(){this.getDelta();return this.elapsedTime;}getDelta(){let diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){const newTime=now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}}function now(){return(typeof performance==='undefined'?Date:performance).now();// see #10732
}const _position$1=/*@__PURE__*/new three_module_Vector3();const _quaternion$1=/*@__PURE__*/new Quaternion();const _scale$1=/*@__PURE__*/new three_module_Vector3();const _orientation$1=/*@__PURE__*/new three_module_Vector3();class AudioListener extends (/* unused pure expression or super */ null && (Object3D)){constructor(){super();this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;this.timeDelta=0;// private
this._clock=new Clock();}getInput(){return this.gain;}removeFilter(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}return this;}getFilter(){return this.filter;}setFilter(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this;}getMasterVolume(){return this.gain.gain.value;}setMasterVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}updateMatrixWorld(force){super.updateMatrixWorld(force);const listener=this.context.listener;const up=this.up;this.timeDelta=this._clock.getDelta();this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1);_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1);if(listener.positionX){// code path for Chrome (see #14393)
const endTime=this.context.currentTime+this.timeDelta;listener.positionX.linearRampToValueAtTime(_position$1.x,endTime);listener.positionY.linearRampToValueAtTime(_position$1.y,endTime);listener.positionZ.linearRampToValueAtTime(_position$1.z,endTime);listener.forwardX.linearRampToValueAtTime(_orientation$1.x,endTime);listener.forwardY.linearRampToValueAtTime(_orientation$1.y,endTime);listener.forwardZ.linearRampToValueAtTime(_orientation$1.z,endTime);listener.upX.linearRampToValueAtTime(up.x,endTime);listener.upY.linearRampToValueAtTime(up.y,endTime);listener.upZ.linearRampToValueAtTime(up.z,endTime);}else{listener.setPosition(_position$1.x,_position$1.y,_position$1.z);listener.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,up.x,up.y,up.z);}}}class Audio extends Object3D{constructor(listener){super();this.type='Audio';this.listener=listener;this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.detune=0;this.loop=false;this.loopStart=0;this.loopEnd=0;this.offset=0;this.duration=undefined;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.source=null;this.sourceType='empty';this._startedAt=0;this._progress=0;this._connected=false;this.filters=[];}getOutput(){return this.gain;}setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;}setMediaElementSource(mediaElement){this.hasPlaybackControl=false;this.sourceType='mediaNode';this.source=this.context.createMediaElementSource(mediaElement);this.connect();return this;}setMediaStreamSource(mediaStream){this.hasPlaybackControl=false;this.sourceType='mediaStreamNode';this.source=this.context.createMediaStreamSource(mediaStream);this.connect();return this;}setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;}play(delay=0){if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._startedAt=this.context.currentTime+delay;const source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.loopStart=this.loopStart;source.loopEnd=this.loopEnd;source.onended=this.onEnded.bind(this);source.start(this._startedAt,this._progress+this.offset,this.duration);this.isPlaying=true;this.source=source;this.setDetune(this.detune);this.setPlaybackRate(this.playbackRate);return this.connect();}pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){// update current progress
this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate;if(this.loop===true){// ensure _progress does not exceed duration with looped audios
this._progress=this._progress%(this.duration||this.buffer.duration);}this.source.stop();this.source.onended=null;this.isPlaying=false;}return this;}stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._progress=0;this.source.stop();this.source.onended=null;this.isPlaying=false;return this;}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}this._connected=true;return this;}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}this._connected=false;return this;}getFilters(){return this.filters;}setFilters(value){if(!value)value=[];if(this._connected===true){this.disconnect();this.filters=value.slice();this.connect();}else{this.filters=value.slice();}return this;}setDetune(value){this.detune=value;if(this.source.detune===undefined)return;// only set detune when available
if(this.isPlaying===true){this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01);}return this;}getDetune(){return this.detune;}getFilter(){return this.getFilters()[0];}setFilter(filter){return this.setFilters(filter?[filter]:[]);}setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01);}return this;}getPlaybackRate(){return this.playbackRate;}onEnded(){this.isPlaying=false;}getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;}setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;}setLoopStart(value){this.loopStart=value;return this;}setLoopEnd(value){this.loopEnd=value;return this;}getVolume(){return this.gain.gain.value;}setVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}}const _position=/*@__PURE__*/new three_module_Vector3();const _quaternion=/*@__PURE__*/new Quaternion();const _scale=/*@__PURE__*/new three_module_Vector3();const _orientation=/*@__PURE__*/new three_module_Vector3();class PositionalAudio extends (/* unused pure expression or super */ null && (Audio)){constructor(listener){super(listener);this.panner=this.context.createPanner();this.panner.panningModel='HRTF';this.panner.connect(this.gain);}getOutput(){return this.panner;}getRefDistance(){return this.panner.refDistance;}setRefDistance(value){this.panner.refDistance=value;return this;}getRolloffFactor(){return this.panner.rolloffFactor;}setRolloffFactor(value){this.panner.rolloffFactor=value;return this;}getDistanceModel(){return this.panner.distanceModel;}setDistanceModel(value){this.panner.distanceModel=value;return this;}getMaxDistance(){return this.panner.maxDistance;}setMaxDistance(value){this.panner.maxDistance=value;return this;}setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){this.panner.coneInnerAngle=coneInnerAngle;this.panner.coneOuterAngle=coneOuterAngle;this.panner.coneOuterGain=coneOuterGain;return this;}updateMatrixWorld(force){super.updateMatrixWorld(force);if(this.hasPlaybackControl===true&&this.isPlaying===false)return;this.matrixWorld.decompose(_position,_quaternion,_scale);_orientation.set(0,0,1).applyQuaternion(_quaternion);const panner=this.panner;if(panner.positionX){// code path for Chrome and Firefox (see #14393)
const endTime=this.context.currentTime+this.listener.timeDelta;panner.positionX.linearRampToValueAtTime(_position.x,endTime);panner.positionY.linearRampToValueAtTime(_position.y,endTime);panner.positionZ.linearRampToValueAtTime(_position.z,endTime);panner.orientationX.linearRampToValueAtTime(_orientation.x,endTime);panner.orientationY.linearRampToValueAtTime(_orientation.y,endTime);panner.orientationZ.linearRampToValueAtTime(_orientation.z,endTime);}else{panner.setPosition(_position.x,_position.y,_position.z);panner.setOrientation(_orientation.x,_orientation.y,_orientation.z);}}}class AudioAnalyser{constructor(audio,fftSize=2048){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data;}getAverageFrequency(){let value=0;const data=this.getFrequencyData();for(let i=0;i<data.length;i++){value+=data[i];}return value/data.length;}}class PropertyMixer{constructor(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;let mixFunction,mixFunctionAdditive,setIdentity;// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
//
// 'add' is used for additive cumulative results
//
// 'work' is optional and is only present for quaternion types. It is used
// to store intermediate quaternion multiplication results
switch(typeName){case'quaternion':mixFunction=this._slerp;mixFunctionAdditive=this._slerpAdditive;setIdentity=this._setAdditiveIdentityQuaternion;this.buffer=new Float64Array(valueSize*6);this._workIndex=5;break;case'string':case'bool':mixFunction=this._select;// Use the regular mix function and for additive on these types,
// additive is not relevant for non-numeric types
mixFunctionAdditive=this._select;setIdentity=this._setAdditiveIdentityOther;this.buffer=new Array(valueSize*5);break;default:mixFunction=this._lerp;mixFunctionAdditive=this._lerpAdditive;setIdentity=this._setAdditiveIdentityNumeric;this.buffer=new Float64Array(valueSize*5);}this._mixBufferRegion=mixFunction;this._mixBufferRegionAdditive=mixFunctionAdditive;this._setIdentity=setIdentity;this._origIndex=3;this._addIndex=4;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;this.useCount=0;this.referenceCount=0;}// accumulate data in the 'incoming' region into 'accu<i>'
accumulate(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
const buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride;let currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
for(let i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
currentWeight+=weight;const mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;}// accumulate data in the 'incoming' region into 'add'
accumulateAdditive(weight){const buffer=this.buffer,stride=this.valueSize,offset=stride*this._addIndex;if(this.cumulativeWeightAdditive===0){// add = identity
this._setIdentity();}// add := add + incoming * weight
this._mixBufferRegionAdditive(buffer,offset,0,weight,stride);this.cumulativeWeightAdditive+=weight;}// apply the state of 'accu<i>' to the binding when accus differ
apply(accuIndex){const stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,weightAdditive=this.cumulativeWeightAdditive,binding=this.binding;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
const originalValueOffset=stride*this._origIndex;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}if(weightAdditive>0){// accuN := accuN + additive accuN
this._mixBufferRegionAdditive(buffer,offset,this._addIndex*stride,1,stride);}for(let i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
binding.setValue(buffer,offset);break;}}}// remember the state of the bound property and copy it to both accus
saveOriginalState(){const binding=this.binding;const buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*this._origIndex;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
for(let i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}// Add to identity for additive
this._setIdentity();this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;}// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState(){const originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);}_setAdditiveIdentityNumeric(){const startIndex=this._addIndex*this.valueSize;const endIndex=startIndex+this.valueSize;for(let i=startIndex;i<endIndex;i++){this.buffer[i]=0;}}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric();this.buffer[this._addIndex*this.valueSize+3]=1;}_setAdditiveIdentityOther(){const startIndex=this._origIndex*this.valueSize;const targetIndex=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++){this.buffer[targetIndex+i]=this.buffer[startIndex+i];}}// mix functions
_select(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(let i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}}_slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);}_slerpAdditive(buffer,dstOffset,srcOffset,t,stride){const workOffset=this._workIndex*stride;// Store result in intermediate buffer offset
Quaternion.multiplyQuaternionsFlat(buffer,workOffset,buffer,dstOffset,buffer,srcOffset);// Slerp to the intermediate result
Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,workOffset,t);}_lerp(buffer,dstOffset,srcOffset,t,stride){const s=1-t;for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}_lerpAdditive(buffer,dstOffset,srcOffset,t,stride){for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]=buffer[j]+buffer[srcOffset+i]*t;}}}// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE='\\[\\]\\.:\\/';const _reservedRe=new RegExp('['+_RESERVED_CHARS_RE+']','g');// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar='[^'+_RESERVED_CHARS_RE+']';const _wordCharOrDot='[^'+_RESERVED_CHARS_RE.replace('\\.','')+']';// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',_wordChar);// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe=/(WCOD+)?/.source.replace('WCOD',_wordCharOrDot);// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',_wordChar);// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',_wordChar);const _trackRe=new RegExp(''+'^'+_directoryRe+_nodeRe+_objectRe+_propertyRe+'$');const _supportedObjectNames=['material','materials','bones'];class Composite{constructor(targetGroup,path,optionalParsedPath){const parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}getValue(array,offset){this.bind();// bind all binding
const firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);}setValue(array,offset){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}}bind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}}unbind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}}// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding{constructor(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;// initial state of these methods that calls 'bind'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}static create(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}}/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */static sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(_reservedRe,'');}static parseTrackName(trackName){const matches=_trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}const results={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
propertyIndex:matches[6]};const lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){const objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against an allowlist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
if(_supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;}static findNode(root,nodeName){if(!nodeName||nodeName===''||nodeName==='.'||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
if(root.skeleton){const bone=root.skeleton.getBoneByName(nodeName);if(bone!==undefined){return bone;}}// search into node subtree.
if(root.children){const searchNodeSubtree=function(children){for(let i=0;i<children.length;i++){const childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}const result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};const subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}// these are used to "bind" a nonexistent property
_getValue_unavailable(){}_setValue_unavailable(){}// Getters
_getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];}_getValue_array(buffer,offset){const source=this.resolvedProperty;for(let i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}}_getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];}_getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}// Direct
_setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];}_setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;}_setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// EntireArray
_setValue_array(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}}_setValue_array_setNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;}_setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}// ArrayElement
_setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];}_setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;}_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// HasToFromArray
_setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);}_setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;}_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}_getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);}_setValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);}// create getter / setter pair for a property in the scene graph
bind(){let targetObject=this.node;const parsedPath=this.parsedPath;const objectName=parsedPath.objectName;const propertyName=parsedPath.propertyName;let propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){let objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
for(let i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
const nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){const nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
let versioning=this.Versioning.None;this.targetObject=targetObject;if(targetObject.needsUpdate!==undefined){// material
versioning=this.Versioning.NeedsUpdate;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
versioning=this.Versioning.MatrixWorldNeedsUpdate;}// determine how the property gets bound
let bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
if(propertyName==='morphTargetInfluences'){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}if(targetObject.morphTargetDictionary[propertyIndex]!==undefined){propertyIndex=targetObject.morphTargetDictionary[propertyIndex];}}else{console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',this);return;}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];}unbind(){this.node=null;// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[// Direct
PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */class AnimationObjectGroup{constructor(){this.uuid=generateUUID();// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite
const indices={};this._indicesByUUID=indices;// for bookkeeping
for(let i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays
const scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}add(){const objects=this._objects,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;let knownObject=undefined,nObjects=objects.length,nCachedObjects=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i],uuid=object.uuid;let index=indicesByUUID[uuid];if(index===undefined){// unknown object -> add it to the ACTIVE region
index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
for(let j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex];let binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist
binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+'detected. Clean the caches or recreate your infrastructure when reloading scenes.');}// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=nCachedObjects;}remove(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
const lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
this.nCachedObjects_=nCachedObjects;}// remove & forget
uncache(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_,nObjects=objects.length;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
const lastIndex=--nObjects,lastObject=objects[lastIndex];if(lastIndex>0){indicesByUUID[lastObject.uuid]=index;}objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=nCachedObjects;}// Internal interface used by befriended PropertyBinding.Composite:
subscribe_(path,parsedPath){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
const indicesByPath=this._bindingsIndicesByPath;let index=indicesByPath[path];const bindings=this._bindings;if(index!==undefined)return bindings[index];const paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(let i=nCachedObjects,n=objects.length;i!==n;++i){const object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;}unsubscribe_(path){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
const indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){const paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}}AnimationObjectGroup.prototype.isAnimationObjectGroup=true;class AnimationAction{constructor(mixer,clip,localRoot=null,blendMode=clip.blendMode){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot;this.blendMode=blendMode;const tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);const interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let i=0;i!==nTracks;++i){const interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager
this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
this.paused=false;// true -> zero effective time scale
this.enabled=true;// false -> zero effective weight
this.clampWhenFinished=false;// keep feeding the last frame?
this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end
}// State & Scheduling
play(){this._mixer._activateAction(this);return this;}stop(){this._mixer._deactivateAction(this);return this.reset();}reset(){this.paused=false;this.enabled=true;this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling
return this.stopFading().stopWarping();}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);}// return true when play has been called
isScheduled(){return this._mixer._isActiveAction(this);}startAt(time){this._startTime=time;return this;}setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;}// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight(weight){this.weight=weight;// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;return this.stopFading();}// return the weight considering fading and .enabled
getEffectiveWeight(){return this._effectiveWeight;}fadeIn(duration){return this._scheduleFading(duration,0,1);}fadeOut(duration){return this._scheduleFading(duration,1,0);}crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){const fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;}crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);}stopFading(){const weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;}// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();}// return the time scale considering warping and .paused
getEffectiveTimeScale(){return this._effectiveTimeScale;}setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();}syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();}halt(duration){return this.warp(this._effectiveTimeScale,0,duration);}warp(startTimeScale,endTimeScale,duration){const mixer=this._mixer,now=mixer.time,timeScale=this.timeScale;let interpolant=this._timeScaleInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}const times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;}stopWarping(){const timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;}// Object Accessors
getMixer(){return this._mixer;}getClip(){return this._clip;}getRoot(){return this._localRoot||this._mixer._root;}// Interna
_update(time,deltaTime,timeDirection,accuIndex){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(time);return;}const startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
const timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
}// start
this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
deltaTime*=this._updateTimeScale(time);const clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
// an effective weight of 0
const weight=this._updateWeight(time);if(weight>0){const interpolants=this._interpolants;const propertyMixers=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulateAdditive(weight);}break;case NormalAnimationBlendMode:default:for(let j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}}}_updateWeight(time){let weight=0;if(this.enabled){weight=this.weight;const interpolant=this._weightInterpolant;if(interpolant!==null){const interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
this.enabled=false;}}}}this._effectiveWeight=weight;return weight;}_updateTimeScale(time){let timeScale=0;if(!this.paused){timeScale=this.timeScale;const interpolant=this._timeScaleInterpolant;if(interpolant!==null){const interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
this.paused=true;}else{// warp done - apply final time scale
this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;}_updateTime(deltaTime){const duration=this._clip.duration;const loop=this.loop;let time=this.time+deltaTime;let loopCount=this._loopCount;const pingPong=loop===LoopPingPong;if(deltaTime===0){if(loopCount===-1)return time;return pingPong&&(loopCount&1)===1?duration-time:time;}if(loop===LoopOnce){if(loopCount===-1){// just started
this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else{this.time=time;break handle_stop;}if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
if(loopCount===-1){// just started
if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
const loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);const pending=this.repetitions-loopCount;if(pending<=0){// have to stop (switch state, clamp time, fire event)
if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
if(pending===1){// entering the last round
const atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this.time=time;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}else{this.time=time;}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
return duration-time;}}return time;}_setEndings(atStart,atEnd,pingPong){const settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}}_scheduleFading(duration,weightNow,weightThen){const mixer=this._mixer,now=mixer.time;let interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}const times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}}class AnimationMixer extends EventDispatcher{constructor(root){super();this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}_bindAction(action,prototypeAction){const root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName;let bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(let i=0;i!==nTracks;++i){const track=tracks[i],trackName=track.name;let binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}const path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}}_activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
const rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}const bindings=action._propertyBindings;// increment reference counts / sort out state
for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}}_deactivateAction(action){if(this._isActiveAction(action)){const bindings=action._propertyBindings;// decrement reference counts / sort out state
for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}}// Memory manager
_initMemoryManager(){this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;this._actionsByClip={};// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }
this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;const scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};}// Memory management for AnimationAction objects
_isActiveAction(action){const index=action._cacheIndex;return index!==null&&index<this._nActiveActions;}_addInactiveAction(action,clipUuid,rootUuid){const actions=this._actions,actionsByClip=this._actionsByClip;let actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{const knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;}_removeInactiveAction(action){const actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;const clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;const actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);}_removeInactiveBindingsForAction(action){const bindings=action._propertyBindings;for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}}_lendAction(action){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
const actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;}_takeBackAction(action){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
const actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;}// Memory management for PropertyMixer objects
_addInactiveBinding(binding,rootUuid,trackName){const bindingsByRoot=this._bindingsByRootAndName,bindings=this._bindings;let bindingByName=bindingsByRoot[rootUuid];if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);}_removeInactiveBinding(binding){const bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];if(Object.keys(bindingByName).length===0){delete bindingsByRoot[rootUuid];}}_lendBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;}_takeBackBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;}// Memory management of Interpolants for weight and time scale
_lendControlInterpolant(){const interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++;let interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;}_takeBackControlInterpolant(interpolant){const interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;}// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction(clip,optionalRoot,blendMode){const root=optionalRoot||this._root,rootUuid=root.uuid;let clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip;const clipUuid=clipObject!==null?clipObject.uuid:clip;const actionsForClip=this._actionsByClip[clipUuid];let prototypeAction=null;if(blendMode===undefined){if(clipObject!==null){blendMode=clipObject.blendMode;}else{blendMode=NormalAnimationBlendMode;}}if(actionsForClip!==undefined){const existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined&&existingAction.blendMode===blendMode){return existingAction;}// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
if(clipObject===null)return null;// allocate all resources required to run it
const newAction=new AnimationAction(this,clipObject,optionalRoot,blendMode);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;}// get an existing action
existingAction(clip,optionalRoot){const root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;}// deactivates all previously scheduled actions
stopAllAction(){const actions=this._actions,nActions=this._nActiveActions;for(let i=nActions-1;i>=0;--i){actions[i].stop();}return this;}// advance the time and update apply the animation
update(deltaTime){deltaTime*=this.timeScale;const actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
for(let i=0;i!==nActions;++i){const action=actions[i];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
const bindings=this._bindings,nBindings=this._nActiveBindings;for(let i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;}// Allows you to seek to a specific time in an animation.
setTime(timeInSeconds){this.time=0;// Zero out time attribute for AnimationMixer object;
for(let i=0;i<this._actions.length;i++){this._actions[i].time=0;// Zero out time attribute for all associated AnimationAction objects.
}return this.update(timeInSeconds);// Update used to set exact time. Returns "this" AnimationMixer object.
}// return this mixer's root target object
getRoot(){return this._root;}// free all resources specific to a particular clip
uncacheClip(clip){const actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
const actionsToRemove=actionsForClip.knownActions;for(let i=0,n=actionsToRemove.length;i!==n;++i){const action=actionsToRemove[i];this._deactivateAction(action);const cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}}// free all resources specific to a particular root target object
uncacheRoot(root){const rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(const clipUuid in actionsByClip){const actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}const bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(const trackName in bindingByName){const binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}}// remove a targeted clip from the cache
uncacheAction(clip,optionalRoot){const action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}}AnimationMixer.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Uniform{constructor(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}clone(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(array,stride,meshPerAttribute=1){super(array,stride);this.meshPerAttribute=meshPerAttribute;}copy(source){super.copy(source);this.meshPerAttribute=source.meshPerAttribute;return this;}clone(data){const ib=super.clone(data);ib.meshPerAttribute=this.meshPerAttribute;return ib;}toJSON(data){const json=super.toJSON(data);json.isInstancedInterleavedBuffer=true;json.meshPerAttribute=this.meshPerAttribute;return json;}}InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer=true;class GLBufferAttribute{constructor(buffer,type,itemSize,elementSize,count){this.buffer=buffer;this.type=type;this.itemSize=itemSize;this.elementSize=elementSize;this.count=count;this.version=0;}set needsUpdate(value){if(value===true)this.version++;}setBuffer(buffer){this.buffer=buffer;return this;}setType(type,elementSize){this.type=type;this.elementSize=elementSize;return this;}setItemSize(itemSize){this.itemSize=itemSize;return this;}setCount(count){this.count=count;return this;}}GLBufferAttribute.prototype.isGLBufferAttribute=true;class Raycaster{constructor(origin,direction,near=0,far=Infinity){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
this.near=near;this.far=far;this.camera=null;this.layers=new Layers();this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}};}set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(origin,direction);}setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();this.camera=camera;}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);this.camera=camera;}else{console.error('THREE.Raycaster: Unsupported camera type: '+camera.type);}}intersectObject(object,recursive=false,intersects=[]){intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;}intersectObjects(objects,recursive=false,intersects=[]){for(let i=0,l=objects.length;i<l;i++){intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}}function ascSort(a,b){return a.distance-b.distance;}function intersectObject(object,raycaster,intersects,recursive){if(object.layers.test(raycaster.layers)){object.raycast(raycaster,intersects);}if(recursive===true){const children=object.children;for(let i=0,l=children.length;i<l;i++){intersectObject(children[i],raycaster,intersects,true);}}}/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */class Spherical{constructor(radius=1,phi=0,theta=0){this.radius=radius;this.phi=phi;// polar angle
this.theta=theta;// azimuthal angle
return this;}set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;}copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;}// restrict phi to be betwee EPS and PI-EPS
makeSafe(){const EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);}setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(x,z);this.phi=Math.acos(clamp(y/this.radius,-1,1));}return this;}clone(){return new this.constructor().copy(this);}}/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */class Cylindrical{constructor(radius=1,theta=0,y=0){this.radius=radius;// distance from the origin to a point in the x-z plane
this.theta=theta;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y;// height above the x-z plane
return this;}set(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;}copy(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);}setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+z*z);this.theta=Math.atan2(x,z);this.y=y;return this;}clone(){return new this.constructor().copy(this);}}const _vector$4=/*@__PURE__*/new Vector2();class Box2{constructor(min=new Vector2(+Infinity,+Infinity),max=new Vector2(-Infinity,-Infinity)){this.min=min;this.max=max;}set(min,max){this.min.copy(min);this.max.copy(max);return this;}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;}setFromCenterAndSize(center,size){const halfSize=_vector$4.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}clone(){return new this.constructor().copy(this);}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y;}getCenter(target){return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}getSize(target){return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min);}expandByPoint(point){this.min.min(point);this.max.max(point);return this;}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;}getParameter(point,target){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));}intersectsBox(box){// using 4 splitting planes to rule out intersections
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}distanceToPoint(point){const clampedPoint=_vector$4.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}intersect(box){this.min.max(box.min);this.max.min(box.max);return this;}union(box){this.min.min(box.min);this.max.max(box.max);return this;}translate(offset){this.min.add(offset);this.max.add(offset);return this;}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}Box2.prototype.isBox2=true;const _startP=/*@__PURE__*/new three_module_Vector3();const _startEnd=/*@__PURE__*/new three_module_Vector3();class Line3{constructor(start=new three_module_Vector3(),end=new three_module_Vector3()){this.start=start;this.end=end;}set(start,end){this.start.copy(start);this.end.copy(end);return this;}copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;}getCenter(target){return target.addVectors(this.start,this.end).multiplyScalar(0.5);}delta(target){return target.subVectors(this.end,this.start);}distanceSq(){return this.start.distanceToSquared(this.end);}distance(){return this.start.distanceTo(this.end);}at(t,target){return this.delta(target).multiplyScalar(t).add(this.start);}closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start);_startEnd.subVectors(this.end,this.start);const startEnd2=_startEnd.dot(_startEnd);const startEnd_startP=_startEnd.dot(_startP);let t=startEnd_startP/startEnd2;if(clampToLine){t=clamp(t,0,1);}return t;}closestPointToPoint(point,clampToLine,target){const t=this.closestPointToPointParameter(point,clampToLine);return this.delta(target).multiplyScalar(t).add(this.start);}applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;}equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}clone(){return new this.constructor().copy(this);}}class ImmediateRenderObject extends Object3D{constructor(material){super();this.material=material;this.render=function/* renderCallback */(){};this.hasPositions=false;this.hasNormals=false;this.hasColors=false;this.hasUvs=false;this.positionArray=null;this.normalArray=null;this.colorArray=null;this.uvArray=null;this.count=0;}}ImmediateRenderObject.prototype.isImmediateRenderObject=true;const _vector$3=/*@__PURE__*/new three_module_Vector3();class SpotLightHelper extends (/* unused pure expression or super */ null && (Object3D)){constructor(light,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;const geometry=new BufferGeometry();const positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let i=0,j=1,l=32;i<l;i++,j++){const p1=i/l*Math.PI*2;const p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.setAttribute('position',new Float32BufferAttribute(positions,3));const material=new LineBasicMaterial({fog:false,toneMapped:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}dispose(){this.cone.geometry.dispose();this.cone.material.dispose();}update(){this.light.updateMatrixWorld();const coneLength=this.light.distance?this.light.distance:1000;const coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(_vector$3);if(this.color!==undefined){this.cone.material.color.set(this.color);}else{this.cone.material.color.copy(this.light.color);}}}const _vector$2=/*@__PURE__*/new three_module_Vector3();const _boneMatrix=/*@__PURE__*/new Matrix4();const _matrixWorldInv=/*@__PURE__*/new Matrix4();class SkeletonHelper extends LineSegments{constructor(object){const bones=getBoneList(object);const geometry=new BufferGeometry();const vertices=[];const colors=[];const color1=new Color(0,0,1);const color2=new Color(0,1,0);for(let i=0;i<bones.length;i++){const bone=bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:true,depthTest:false,depthWrite:false,toneMapped:false,transparent:true});super(geometry,material);this.type='SkeletonHelper';this.isSkeletonHelper=true;this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;}updateMatrixWorld(force){const bones=this.bones;const geometry=this.geometry;const position=geometry.getAttribute('position');_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let i=0,j=0;i<bones.length;i++){const bone=bones[i];if(bone.parent&&bone.parent.isBone){_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.matrixWorld);_vector$2.setFromMatrixPosition(_boneMatrix);position.setXYZ(j,_vector$2.x,_vector$2.y,_vector$2.z);_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.parent.matrixWorld);_vector$2.setFromMatrixPosition(_boneMatrix);position.setXYZ(j+1,_vector$2.x,_vector$2.y,_vector$2.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;super.updateMatrixWorld(force);}}function getBoneList(object){const boneList=[];if(object&&object.isBone){boneList.push(object);}for(let i=0;i<object.children.length;i++){boneList.push.apply(boneList,getBoneList(object.children[i]));}return boneList;}class PointLightHelper extends (/* unused pure expression or super */ null && (three_module_Mesh)){constructor(light,sphereSize,color){const geometry=new SphereGeometry(sphereSize,4,2);const material=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});super(geometry,material);this.light=light;this.light.updateMatrixWorld();this.color=color;this.type='PointLightHelper';this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;this.update();/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/}dispose(){this.geometry.dispose();this.material.dispose();}update(){if(this.color!==undefined){this.material.color.set(this.color);}else{this.material.color.copy(this.light.color);}/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/}}const _vector$1=/*@__PURE__*/new three_module_Vector3();const _color1=/*@__PURE__*/new Color();const _color2=/*@__PURE__*/new Color();class HemisphereLightHelper extends (/* unused pure expression or super */ null && (Object3D)){constructor(light,size,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;const geometry=new OctahedronGeometry(size);geometry.rotateY(Math.PI*0.5);this.material=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});if(this.color===undefined)this.material.vertexColors=true;const position=geometry.getAttribute('position');const colors=new Float32Array(position.count*3);geometry.setAttribute('color',new BufferAttribute(colors,3));this.add(new three_module_Mesh(geometry,this.material));this.update();}dispose(){this.children[0].geometry.dispose();this.children[0].material.dispose();}update(){const mesh=this.children[0];if(this.color!==undefined){this.material.color.set(this.color);}else{const colors=mesh.geometry.getAttribute('color');_color1.copy(this.light.color);_color2.copy(this.light.groundColor);for(let i=0,l=colors.count;i<l;i++){const color=i<l/2?_color1:_color2;colors.setXYZ(i,color.r,color.g,color.b);}colors.needsUpdate=true;}mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());}}class GridHelper extends LineSegments{constructor(size=10,divisions=10,color1=0x444444,color2=0x888888){color1=new Color(color1);color2=new Color(color2);const center=divisions/2;const step=size/divisions;const halfSize=size/2;const vertices=[],colors=[];for(let i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);const color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}const geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(geometry,material);this.type='GridHelper';}}class PolarGridHelper extends (/* unused pure expression or super */ null && (LineSegments)){constructor(radius=10,radials=16,circles=8,divisions=64,color1=0x444444,color2=0x888888){color1=new Color(color1);color2=new Color(color2);const vertices=[];const colors=[];// create the radials
for(let i=0;i<=radials;i++){const v=i/radials*(Math.PI*2);const x=Math.sin(v)*radius;const z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);const color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
for(let i=0;i<=circles;i++){const color=i&1?color1:color2;const r=radius-radius/circles*i;for(let j=0;j<divisions;j++){// first vertex
let v=j/divisions*(Math.PI*2);let x=Math.sin(v)*r;let z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}const geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(geometry,material);this.type='PolarGridHelper';}}const _v1=/*@__PURE__*/new three_module_Vector3();const _v2=/*@__PURE__*/new three_module_Vector3();const _v3=/*@__PURE__*/new three_module_Vector3();class DirectionalLightHelper extends (/* unused pure expression or super */ null && (Object3D)){constructor(light,size,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;if(size===undefined)size=1;let geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));const material=new LineBasicMaterial({fog:false,toneMapped:false});this.lightPlane=new Line(geometry,material);this.add(this.lightPlane);geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(geometry,material);this.add(this.targetLine);this.update();}dispose(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose();}update(){_v1.setFromMatrixPosition(this.light.matrixWorld);_v2.setFromMatrixPosition(this.light.target.matrixWorld);_v3.subVectors(_v2,_v1);this.lightPlane.lookAt(_v2);if(this.color!==undefined){this.lightPlane.material.color.set(this.color);this.targetLine.material.color.set(this.color);}else{this.lightPlane.material.color.copy(this.light.color);this.targetLine.material.color.copy(this.light.color);}this.targetLine.lookAt(_v2);this.targetLine.scale.z=_v3.length();}}const _vector=/*@__PURE__*/new three_module_Vector3();const _camera=/*@__PURE__*/new Camera();/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */class CameraHelper extends (/* unused pure expression or super */ null && (LineSegments)){constructor(camera){const geometry=new BufferGeometry();const material=new LineBasicMaterial({color:0xffffff,vertexColors:true,toneMapped:false});const vertices=[];const colors=[];const pointMap={};// colors
const colorFrustum=new Color(0xffaa00);const colorCone=new Color(0xff0000);const colorUp=new Color(0x00aaff);const colorTarget=new Color(0xffffff);const colorCross=new Color(0x333333);// near
addLine('n1','n2',colorFrustum);addLine('n2','n4',colorFrustum);addLine('n4','n3',colorFrustum);addLine('n3','n1',colorFrustum);// far
addLine('f1','f2',colorFrustum);addLine('f2','f4',colorFrustum);addLine('f4','f3',colorFrustum);addLine('f3','f1',colorFrustum);// sides
addLine('n1','f1',colorFrustum);addLine('n2','f2',colorFrustum);addLine('n3','f3',colorFrustum);addLine('n4','f4',colorFrustum);// cone
addLine('p','n1',colorCone);addLine('p','n2',colorCone);addLine('p','n3',colorCone);addLine('p','n4',colorCone);// up
addLine('u1','u2',colorUp);addLine('u2','u3',colorUp);addLine('u3','u1',colorUp);// target
addLine('c','t',colorTarget);addLine('p','c',colorCross);// cross
addLine('cn1','cn2',colorCross);addLine('cn3','cn4',colorCross);addLine('cf1','cf2',colorCross);addLine('cf3','cf4',colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));super(geometry,material);this.type='CameraHelper';this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}update(){const geometry=this.geometry;const pointMap=this.pointMap;const w=1,h=1;// we need just camera projection matrix inverse
// world matrix must be identity
_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);// center / target
setPoint('c',pointMap,geometry,_camera,0,0,-1);setPoint('t',pointMap,geometry,_camera,0,0,1);// near
setPoint('n1',pointMap,geometry,_camera,-w,-h,-1);setPoint('n2',pointMap,geometry,_camera,w,-h,-1);setPoint('n3',pointMap,geometry,_camera,-w,h,-1);setPoint('n4',pointMap,geometry,_camera,w,h,-1);// far
setPoint('f1',pointMap,geometry,_camera,-w,-h,1);setPoint('f2',pointMap,geometry,_camera,w,-h,1);setPoint('f3',pointMap,geometry,_camera,-w,h,1);setPoint('f4',pointMap,geometry,_camera,w,h,1);// up
setPoint('u1',pointMap,geometry,_camera,w*0.7,h*1.1,-1);setPoint('u2',pointMap,geometry,_camera,-w*0.7,h*1.1,-1);setPoint('u3',pointMap,geometry,_camera,0,h*2,-1);// cross
setPoint('cf1',pointMap,geometry,_camera,-w,0,1);setPoint('cf2',pointMap,geometry,_camera,w,0,1);setPoint('cf3',pointMap,geometry,_camera,0,-h,1);setPoint('cf4',pointMap,geometry,_camera,0,h,1);setPoint('cn1',pointMap,geometry,_camera,-w,0,-1);setPoint('cn2',pointMap,geometry,_camera,w,0,-1);setPoint('cn3',pointMap,geometry,_camera,0,-h,-1);setPoint('cn4',pointMap,geometry,_camera,0,h,-1);geometry.getAttribute('position').needsUpdate=true;}dispose(){this.geometry.dispose();this.material.dispose();}}function setPoint(point,pointMap,geometry,camera,x,y,z){_vector.set(x,y,z).unproject(camera);const points=pointMap[point];if(points!==undefined){const position=geometry.getAttribute('position');for(let i=0,l=points.length;i<l;i++){position.setXYZ(points[i],_vector.x,_vector.y,_vector.z);}}}const _box=/*@__PURE__*/new Box3();class BoxHelper extends (/* unused pure expression or super */ null && (LineSegments)){constructor(object,color=0xffff00){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);const positions=new Float32Array(8*3);const geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute('position',new BufferAttribute(positions,3));super(geometry,new LineBasicMaterial({color:color,toneMapped:false}));this.object=object;this.type='BoxHelper';this.matrixAutoUpdate=false;this.update();}update(object){if(object!==undefined){console.warn('THREE.BoxHelper: .update() has no longer arguments.');}if(this.object!==undefined){_box.setFromObject(this.object);}if(_box.isEmpty())return;const min=_box.min;const max=_box.max;/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/const position=this.geometry.attributes.position;const array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();}setFromObject(object){this.object=object;this.update();return this;}copy(source){LineSegments.prototype.copy.call(this,source);this.object=source.object;return this;}}class Box3Helper extends (/* unused pure expression or super */ null && (LineSegments)){constructor(box,color=0xffff00){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);const positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];const geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute('position',new Float32BufferAttribute(positions,3));super(geometry,new LineBasicMaterial({color:color,toneMapped:false}));this.box=box;this.type='Box3Helper';this.geometry.computeBoundingSphere();}updateMatrixWorld(force){const box=this.box;if(box.isEmpty())return;box.getCenter(this.position);box.getSize(this.scale);this.scale.multiplyScalar(0.5);super.updateMatrixWorld(force);}}class PlaneHelper extends (/* unused pure expression or super */ null && (Line)){constructor(plane,size=1,hex=0xffff00){const color=hex;const positions=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];const geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(positions,3));geometry.computeBoundingSphere();super(geometry,new LineBasicMaterial({color:color,toneMapped:false}));this.type='PlaneHelper';this.plane=plane;this.size=size;const positions2=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];const geometry2=new BufferGeometry();geometry2.setAttribute('position',new Float32BufferAttribute(positions2,3));geometry2.computeBoundingSphere();this.add(new three_module_Mesh(geometry2,new MeshBasicMaterial({color:color,opacity:0.2,transparent:true,depthWrite:false,toneMapped:false})));}updateMatrixWorld(force){let scale=-this.plane.constant;if(Math.abs(scale)<1e-8)scale=1e-8;// sign does not matter
this.scale.set(0.5*this.size,0.5*this.size,scale);this.children[0].material.side=scale<0?BackSide:FrontSide;// renderer flips side when determinant < 0; flipping not wanted here
this.lookAt(this.plane.normal);super.updateMatrixWorld(force);}}const _axis=/*@__PURE__*/new three_module_Vector3();let _lineGeometry,_coneGeometry;class ArrowHelper extends (/* unused pure expression or super */ null && (Object3D)){// dir is assumed to be normalized
constructor(dir=new three_module_Vector3(0,0,1),origin=new three_module_Vector3(0,0,0),length=1,color=0xffff00,headLength=length*0.2,headWidth=headLength*0.2){super();this.type='ArrowHelper';if(_lineGeometry===undefined){_lineGeometry=new BufferGeometry();_lineGeometry.setAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));_coneGeometry=new CylinderGeometry(0,0.5,1,5,1);_coneGeometry.translate(0,-0.5,0);}this.position.copy(origin);this.line=new Line(_lineGeometry,new LineBasicMaterial({color:color,toneMapped:false}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new three_module_Mesh(_coneGeometry,new MeshBasicMaterial({color:color,toneMapped:false}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}setDirection(dir){// dir is assumed to be normalized
if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{_axis.set(dir.z,0,-dir.x).normalize();const radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(_axis,radians);}}setLength(length,headLength=length*0.2,headWidth=headLength*0.2){this.line.scale.set(1,Math.max(0.0001,length-headLength),1);// see #17458
this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();}setColor(color){this.line.material.color.set(color);this.cone.material.color.set(color);}copy(source){super.copy(source,false);this.line.copy(source.line);this.cone.copy(source.cone);return this;}}class AxesHelper extends (/* unused pure expression or super */ null && (LineSegments)){constructor(size=1){const vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];const colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];const geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(geometry,material);this.type='AxesHelper';}setColors(xAxisColor,yAxisColor,zAxisColor){const color=new Color();const array=this.geometry.attributes.color.array;color.set(xAxisColor);color.toArray(array,0);color.toArray(array,3);color.set(yAxisColor);color.toArray(array,6);color.toArray(array,9);color.set(zAxisColor);color.toArray(array,12);color.toArray(array,15);this.geometry.attributes.color.needsUpdate=true;return this;}dispose(){this.geometry.dispose();this.material.dispose();}}const _floatView=new Float32Array(1);const _int32View=new Int32Array(_floatView.buffer);class DataUtils{// Converts float32 to float16 (stored as uint16 value).
static toHalfFloat(val){// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */_floatView[0]=val;const x=_int32View[0];let bits=x>>16&0x8000;/* Get the sign */let m=x>>12&0x07ff;/* Keep one extra bit for rounding */const e=x>>23&0xff;/* Using int is faster here */ /* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */if(e<103)return bits;/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */if(e>142){bits|=0x7c00;/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */bits|=(e==255?0:1)&&x&0x007fffff;return bits;}/* If exponent underflows but not too much, return a denormal */if(e<113){m|=0x0800;/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */bits|=(m>>114-e)+(m>>113-e&1);return bits;}bits|=e-112<<10|m>>1;/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */bits+=m&1;return bits;}}const LineStrip=0;const LinePieces=1;const NoColors=0;const FaceColors=1;const VertexColors=2;function MeshFaceMaterial(materials){console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');return materials;}function MultiMaterial(materials=[]){console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');materials.isMultiMaterial=true;materials.materials=materials;materials.clone=function(){return materials.slice();};return materials;}function PointCloud(geometry,material){console.warn('THREE.PointCloud has been renamed to THREE.Points.');return new Points(geometry,material);}function Particle(material){console.warn('THREE.Particle has been renamed to THREE.Sprite.');return new Sprite(material);}function ParticleSystem(geometry,material){console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');return new Points(geometry,material);}function PointCloudMaterial(parameters){console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleBasicMaterial(parameters){console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleSystemMaterial(parameters){console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function Vertex(x,y,z){console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');return new three_module_Vector3(x,y,z);}//
function DynamicBufferAttribute(array,itemSize){console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');return new BufferAttribute(array,itemSize).setUsage(DynamicDrawUsage);}function Int8Attribute(array,itemSize){console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');return new Int8BufferAttribute(array,itemSize);}function Uint8Attribute(array,itemSize){console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');return new Uint8BufferAttribute(array,itemSize);}function Uint8ClampedAttribute(array,itemSize){console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');return new Uint8ClampedBufferAttribute(array,itemSize);}function Int16Attribute(array,itemSize){console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');return new Int16BufferAttribute(array,itemSize);}function Uint16Attribute(array,itemSize){console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');return new Uint16BufferAttribute(array,itemSize);}function Int32Attribute(array,itemSize){console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');return new Int32BufferAttribute(array,itemSize);}function Uint32Attribute(array,itemSize){console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');return new Uint32BufferAttribute(array,itemSize);}function Float32Attribute(array,itemSize){console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');return new Float32BufferAttribute(array,itemSize);}function Float64Attribute(array,itemSize){console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');return new Float64BufferAttribute(array,itemSize);}//
Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
Path.prototype.fromPoints=function(points){console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');return this.setFromPoints(points);};//
function AxisHelper(size){console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');return new AxesHelper(size);}function BoundingBoxHelper(object,color){console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');return new BoxHelper(object,color);}function EdgesHelper(object,hex){console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};SkeletonHelper.prototype.update=function(){console.error('THREE.SkeletonHelper: update() no longer needs to be called.');};function WireframeHelper(object,hex){console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}//
Loader.prototype.extractUrlBase=function(url){console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');return LoaderUtils.extractUrlBase(url);};Loader.Handlers={add:function/* regex, loader */(){console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');},get:function/* file */(){console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');}};function XHRLoader(manager){console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');return new FileLoader(manager);}function BinaryTextureLoader(manager){console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');return new DataTextureLoader(manager);}//
Box2.prototype.center=function(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Box2.prototype.empty=function(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();};Box2.prototype.isIntersectionBox=function(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Box2.prototype.size=function(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);};//
Box3.prototype.center=function(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Box3.prototype.empty=function(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();};Box3.prototype.isIntersectionBox=function(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Box3.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};Box3.prototype.size=function(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);};//
Sphere.prototype.empty=function(){console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');return this.isEmpty();};//
Frustum.prototype.setFromMatrix=function(m){console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');return this.setFromProjectionMatrix(m);};//
Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};//
Matrix3.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix3.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);};Matrix3.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');};Matrix3.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');return attribute.applyMatrix3(this);};Matrix3.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');};Matrix3.prototype.getInverse=function(matrix){console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
Matrix4.prototype.extractPosition=function(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);};Matrix4.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix4.prototype.getPosition=function(){console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return new three_module_Vector3().setFromMatrixColumn(this,3);};Matrix4.prototype.setRotationFromQuaternion=function(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);};Matrix4.prototype.multiplyToArray=function(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');};Matrix4.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.multiplyVector4=function(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');};Matrix4.prototype.rotateAxis=function(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);};Matrix4.prototype.crossVector=function(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.translate=function(){console.error('THREE.Matrix4: .translate() has been removed.');};Matrix4.prototype.rotateX=function(){console.error('THREE.Matrix4: .rotateX() has been removed.');};Matrix4.prototype.rotateY=function(){console.error('THREE.Matrix4: .rotateY() has been removed.');};Matrix4.prototype.rotateZ=function(){console.error('THREE.Matrix4: .rotateZ() has been removed.');};Matrix4.prototype.rotateByAxis=function(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');};Matrix4.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');return attribute.applyMatrix4(this);};Matrix4.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');};Matrix4.prototype.makeFrustum=function(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);};Matrix4.prototype.getInverse=function(matrix){console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};//
Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Quaternion.prototype.inverse=function(){console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');return this.invert();};//
Ray.prototype.isIntersectionBox=function(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Ray.prototype.isIntersectionPlane=function(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);};Ray.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};//
Triangle.prototype.area=function(){console.warn('THREE.Triangle: .area() has been renamed to .getArea().');return this.getArea();};Triangle.prototype.barycoordFromPoint=function(point,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return this.getBarycoord(point,target);};Triangle.prototype.midpoint=function(target){console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');return this.getMidpoint(target);};Triangle.prototypenormal=function(target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return this.getNormal(target);};Triangle.prototype.plane=function(target){console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');return this.getPlane(target);};Triangle.barycoordFromPoint=function(point,a,b,c,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return Triangle.getBarycoord(point,a,b,c,target);};Triangle.normal=function(a,b,c,target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return Triangle.getNormal(a,b,c,target);};//
Shape.prototype.extractAllPoints=function(divisions){console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');return this.extractPoints(divisions);};Shape.prototype.extrude=function(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);};Shape.prototype.makeGeometry=function(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);};//
Vector2.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector2.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};Vector2.prototype.lengthManhattan=function(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
three_module_Vector3.prototype.setEulerFromRotationMatrix=function(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');};three_module_Vector3.prototype.setEulerFromQuaternion=function(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');};three_module_Vector3.prototype.getPositionFromMatrix=function(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);};three_module_Vector3.prototype.getScaleFromMatrix=function(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);};three_module_Vector3.prototype.getColumnFromMatrix=function(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);};three_module_Vector3.prototype.applyProjection=function(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);};three_module_Vector3.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};three_module_Vector3.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};three_module_Vector3.prototype.lengthManhattan=function(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
Vector4.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector4.prototype.lengthManhattan=function(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
Object3D.prototype.getChildByName=function(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);};Object3D.prototype.renderDepth=function(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');};Object3D.prototype.translate=function(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);};Object3D.prototype.getWorldRotation=function(){console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');};Object3D.prototype.applyMatrix=function(matrix){console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});three_module_Mesh.prototype.setDrawMode=function(){console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');};Object.defineProperties(three_module_Mesh.prototype,{drawMode:{get:function(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');return TrianglesDrawMode;},set:function(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');}}});SkinnedMesh.prototype.initBones=function(){console.error('THREE.SkinnedMesh: initBones() has been removed.');};//
PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn('THREE.PerspectiveCamera.setLens is deprecated. '+'Use .setFocalLength and .filmGauge for a photographic setup.');if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}},dynamic:{get:function(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');return this.usage===DynamicDrawUsage;},set:function/* value */(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');this.setUsage(DynamicDrawUsage);}}});BufferAttribute.prototype.setDynamic=function(value){console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};BufferAttribute.prototype.copyIndicesArray=function/* indices */(){console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');},BufferAttribute.prototype.setArray=function/* array */(){console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
BufferGeometry.prototype.addIndex=function(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);};BufferGeometry.prototype.addAttribute=function(name,attribute){console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');return this.setAttribute(name,new BufferAttribute(arguments[1],arguments[2]));}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return this;}return this.setAttribute(name,attribute);};BufferGeometry.prototype.addDrawCall=function(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);};BufferGeometry.prototype.clearDrawCalls=function(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();};BufferGeometry.prototype.computeOffsets=function(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');};BufferGeometry.prototype.removeAttribute=function(name){console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');return this.deleteAttribute(name);};BufferGeometry.prototype.applyMatrix=function(matrix){console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});InterleavedBuffer.prototype.setDynamic=function(value){console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};InterleavedBuffer.prototype.setArray=function/* array */(){console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
ExtrudeGeometry.prototype.getArrays=function(){console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');};ExtrudeGeometry.prototype.addShapeList=function(){console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');};ExtrudeGeometry.prototype.addShape=function(){console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');};//
Scene.prototype.dispose=function(){console.error('THREE.Scene: .dispose() has been removed.');};//
Uniform.prototype.onUpdate=function(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;};//
Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function(){console.warn('THREE.Material: .wrapAround has been removed.');}},overdraw:{get:function(){console.warn('THREE.Material: .overdraw has been removed.');},set:function(){console.warn('THREE.Material: .overdraw has been removed.');}},wrapRGB:{get:function(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}},shading:{get:function(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}},stencilMask:{get:function(){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');return this.stencilFuncMask;},set:function(value){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');this.stencilFuncMask=value;}},vertexTangents:{get:function(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');},set:function(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
WebGLRenderer.prototype.clearTarget=function(renderTarget,color,depth,stencil){console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};WebGLRenderer.prototype.animate=function(callback){console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');this.setAnimationLoop(callback);};WebGLRenderer.prototype.getCurrentRenderTarget=function(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();};WebGLRenderer.prototype.getMaxAnisotropy=function(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();};WebGLRenderer.prototype.getPrecision=function(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;};WebGLRenderer.prototype.resetGLState=function(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();};WebGLRenderer.prototype.supportsFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');};WebGLRenderer.prototype.supportsHalfFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');};WebGLRenderer.prototype.supportsStandardDerivatives=function(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');};WebGLRenderer.prototype.supportsCompressedTextureS3TC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');};WebGLRenderer.prototype.supportsCompressedTexturePVRTC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');};WebGLRenderer.prototype.supportsBlendMinMax=function(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');};WebGLRenderer.prototype.supportsVertexTextures=function(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;};WebGLRenderer.prototype.supportsInstancedArrays=function(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');};WebGLRenderer.prototype.enableScissorTest=function(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);};WebGLRenderer.prototype.initMaterial=function(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');};WebGLRenderer.prototype.addPrePlugin=function(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');};WebGLRenderer.prototype.addPostPlugin=function(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');};WebGLRenderer.prototype.updateShadowMap=function(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');};WebGLRenderer.prototype.setFaceCulling=function(){console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');};WebGLRenderer.prototype.allocTextureUnit=function(){console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');};WebGLRenderer.prototype.setTexture=function(){console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');};WebGLRenderer.prototype.setTexture2D=function(){console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');};WebGLRenderer.prototype.setTextureCube=function(){console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');};WebGLRenderer.prototype.getActiveMipMapLevel=function(){console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');return this.getActiveMipmapLevel();};Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function(){return this.shadowMap.type;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function/* value */(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');}},context:{get:function(){console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');return this.getContext();}},vr:{get:function(){console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');return this.xr;}},gammaInput:{get:function(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');return false;},set:function(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');}},gammaOutput:{get:function(){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');return false;},set:function(value){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');this.outputEncoding=value===true?sRGBEncoding:LinearEncoding;}},toneMappingWhitePoint:{get:function(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');return 1.0;},set:function(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function/* cullFace */(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');}},renderReverseSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');}},renderSingleSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');}}});function WebGLRenderTargetCube(width,height,options){console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');return new WebGLCubeRenderTarget(width,options);}//
Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');const scope=this;const audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
CubeCamera.prototype.updateCubeMap=function(renderer,scene){console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');return this.update(renderer,scene);};CubeCamera.prototype.clear=function(renderer,color,depth,stencil){console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');return this.renderTarget.clear(renderer,color,depth,stencil);};ImageUtils.crossOrigin=undefined;ImageUtils.loadTexture=function(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');const loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);const texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadTextureCube=function(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');const loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);const texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadCompressedTexture=function(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');};ImageUtils.loadCompressedTextureCube=function(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');};//
function CanvasRenderer(){console.error('THREE.CanvasRenderer has been removed');}//
function JSONLoader(){console.error('THREE.JSONLoader has been removed.');}//
const SceneUtils={createMultiMaterialObject:function/* geometry, materials */(){console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');},detach:function/* child, parent, scene */(){console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');},attach:function/* child, scene, parent */(){console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');}};//
function LensFlare(){console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');}if(typeof __THREE_DEVTOOLS__!=='undefined'){/* eslint-disable no-undef */__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));/* eslint-enable no-undef */}if(typeof window!=='undefined'){if(window.__THREE__){console.warn('WARNING: Multiple instances of Three.js being imported.');}else{window.__THREE__=REVISION;}}
;// CONCATENATED MODULE: ./Math/Vector3.js


/**
 * 3차원 벡터 클래스
 * */
class Vector3 {
  /**
   * 두 벡터의 거리를 계산한다.
   * @param {Vector3} vector1
   * @param {Vector3} vector2
   * @returns {Number} 두 벡터의 거리 값
   */
  static distance(vector1, vector2) {
    let vv = vector1.clone().sub(vector2);
    return vv.length();
  }

  /**
   * 클래스 생성자
   * @param {Number} x 벡터 x값
   * @param {Number} y 벡터 y값
   * @param {Number} z 벡터 z값
   */
  constructor(x, y, z) {
    this.set(x, y, z);
    return this;
  }
  createTHREE() {
    let v = new three_module_Vector3(this._x, this._y, this._z);
    return v;
  }

  /**
   * 벡터의 요소 값을 설정한다.
   * @param {Number} x 벡터 x값
   * @param {Number} y 벡터 y값
   * @param {Number} z 벡터 z값
   */
  set(x, y, z) {
    if (x instanceof Vector3) {
      this._x = x._x;
      this._y = x._y;
      this._z = x._z;
    } else if (x === undefined) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
    } else {
      this._x = x;
      this._y = y;
      this._z = z;
    }
    return this;
  }

  /**
   * number array 에서 값을 가져와 벡터 요소 값을 설정한다.
   * @param {Array} array number array
   */
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    return this;
  }

  /**
   * 벡터 각 요소의 값을 더한다.
   * @param {Number} x 벡터 x 증가값
   * @param {Number} y 벡터 y 증가값
   * @param {Number} z 벡터 z 증가값
   * @returns {Vector3} 계산 결과 벡터 데이터
   */
  add(x, y, z) {
    if (x instanceof Vector3) {
      this._x += x._x;
      this._y += x._y;
      this._z += x._z;
    } else {
      this._x += x;
      this._y += y;
      this._z += z;
    }
    return this;
  }

  /**
   * 벡터 각 요소의 값을 감소시킨다.
   * @param {Number} x 벡터 x 감소값
   * @param {Number} y 벡터 y 감소값
   * @param {Number} z 벡터 z 감소값
   * @returns {Vector3} 계산 결과 벡터 데이터
   */
  sub(x, y, z) {
    if (x instanceof Vector3) {
      this._x -= x._x;
      this._y -= x._y;
      this._z -= x._z;
    } else {
      this._x -= x;
      this._y -= y;
      this._z -= z;
    }
    return this;
  }

  /**
   * 벡터의 각 요소에 스칼라 값을 곱한다.
   * @param {Number} a 곱할 값
   * @returns {Vector3} 계산 결과 벡터 데이터
   */
  mulScalar(a) {
    this._x *= a;
    this._y *= a;
    this._z *= a;
    return this;
  }

  /**
   * 벡터 각 요소에 값을 각각 곱한다.
   * @param {Number} x 벡터 x 곱할 값
   * @param {Number} y 벡터 y 곱할 값
   * @param {Number} z 벡터 z 곱할 값
   * @returns {Vector3} 계산 결과 벡터 데이터
   */
  mul(x, y, z) {
    if (x instanceof Vector3) {
      this._x *= x._x;
      this._y *= x._y;
      this._z *= x._z;
    } else {
      this._x *= x;
      this._y *= y;
      this._z *= z;
    }
    ;
    return this;
  }

  /**
   * 벡터 각 요소에 값을 각각 나눈다.
   * @param {Number} x 벡터 x 나눌 값
   * @param {Number} y 벡터 y 나눌 값
   * @param {Number} z 벡터 z 나눌 값
   * @returns {Vector3} 계산 결과 벡터 데이터
   */
  div(x, y, z) {
    if (x instanceof Vector3) {
      this._x /= x._x;
      this._y /= x._y;
      this._z /= x._z;
    } else {
      this._x /= x;
      this._y /= y;
      this._z /= z;
    }
    ;
    return this;
  }

  /**
   * 다른 벡터와 dot product 를 계산한다.
   * @param {Vector3} v dot product를 계산할 벡터
   * @returns {Number} 계산된 dot product 값
   */
  dot(v) {
    let value = this._x * v._x + this._y * v._y + this._z * v._z;
    return value;
  }

  /**
   * 벡터의 길이 값을 계산한다.
   * @returns {Number} 벡터 길이 값
   * */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }

  /**
   * 다른 벡터와 cross product 를 계산한다.
   * @param {Vector3} v cross product를 계산할 벡터
   * @returns {Vector3} 계산된 cross product 벡터
   */
  cross(vector) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    let cv = new Vector3();
    cv.x = y * vector.z - z * vector.y;
    cv.y = z * vector.x - x * vector.z;
    cv.z = x * vector.y - y * vector.x;
    return cv;
  }

  /**
   * 벡터를 정규화시킨다.
   * @returns {Vector3} 정규화 된 벡터 데이터
   * */
  normalize() {
    let len = this.length();
    this.div(len, len, len);
    return this;
  }

  /**
   * 다른 벡터와 이루는 각도를 계산한다.
   * @param {Vector3} vector 각도를 계산할 벡터
   * @returns {Number} 계산된 각도
   */
  angle(vector) {
    return Math.acos(this.dot(vector) / (this.length() * vector.length()));
  }
  /**
   * 벡터 데이터를 복제한다.
   * @returns {Vector3} 복제된 벡터 데이터
   * */
  clone() {
    let v = new Vector3(this);
    return v;
  }
}
;// CONCATENATED MODULE: ./Renderer/ptMesh.js


/**
 * 포인트 메쉬 클래스
 * */
class ptMesh {
  /**
   * 클래스 생성자
   * */
  constructor() {}

  /**
   * 초기화한다.
   * */
  reset() {
    this._3geom = new BufferGeometry();
    this._ringIdx = []; // store index list of previous ring
    this._vertexIdx = 0;
    this._lastRing = null;
    this._vertices = [];
    this._indices = [];
  }

  /**
   * 링 버텍스를 추가한다.
   * @param {Point} pos 버텍스 위치
   * @param {any} normal 노말 벡터
   * @param {any} binormal 바이노말 벡터
   * @param {any} ring 링
   */
  addRingVertex(pos, normal, binormal, ring) {
    this._lastRing = ring;
    for (var i = 0; i < ring._ring.length; i++) {
      var rr = ring._ring[i];
      var pp = pos.clone();
      pp.addScaledVector(normal, rr.x);
      pp.addScaledVector(binormal, rr.y);
      this._vertices.push(pp.x, pp.y, pp.z);
      //this._3geom.vertices.push(pp);
      this._ringIdx[i] = this._vertexIdx;
      this._vertexIdx++;
    }
  }

  /**
   * 링 인덱스를 추가한다.
   * */
  addRingIndex() {
    const len = this._lastRing._ring.length;
    {
      var i = 0;
      const t1 = this._ringIdx[i];
      const t2 = this._ringIdx[i] + len - 1;
      const t3 = this._ringIdx[i] - 1;
      this._indices.push(t1, t2, t3);
      const t4 = this._ringIdx[i];
      const t5 = this._ringIdx[i] - 1;
      const t6 = this._ringIdx[i] - len;
      this._indices.push(t4, t5, t6);
    }
    for (var i = 1; i < len; i++) {
      const t1 = this._ringIdx[i];
      const t2 = this._ringIdx[i] - 1;
      const t3 = this._ringIdx[i] - len - 1;
      this._indices.push(t1, t2, t3);
      const t4 = this._ringIdx[i];
      const t5 = this._ringIdx[i] - len - 1;
      const t6 = this._ringIdx[i] - len;
      this._indices.push(t4, t5, t6);
    }
  }

  /**
   * 메쉬를 생성한다.
   * @param {any} material
   */
  generateGeometry() {
    this._3geom.setIndex(this._indices);
    this._3geom.setAttribute('position', new Float32BufferAttribute(this._vertices, 3));
    let vertex_color = [];
    for (let i = 0; i < this._vertices.length; i++) {
      vertex_color.push(1);
    }
    this._3geom.setAttribute('color', new Float32BufferAttribute(vertex_color, 3));
    this._3geom.computeVertexNormals();
    return this._3geom;
  }

  /**
   * 메쉬를 생성한다.
   * @param {any} material
   */
  generateMesh(material) {
    let geometry = this.generateGeometry();
    var obj = new three_module_Mesh(geometry, material);
    return obj;
  }
}
;// CONCATENATED MODULE: ./Renderer/ptRing.js

var _coil1;
var _strand1;
var _strand2;
var _strand3;
var _helix1;
var _dna;
var ptRing_end;
var _inited = false;
var _num_faces = 40;

/**
 * 단백질 링을 초기화한다.
 * */
function ptRing_init() {
  if (_inited) return;
  _inited = true;
  _coil1 = new ptRing(_num_faces);
  _coil1.setCircle(0.2, 0.2);
  _strand1 = new ptRing(_num_faces);
  _strand1.setBox(0.1, 1);
  _strand2 = new ptRing(_num_faces);
  _strand2.setBox(0.1, 2);
  _strand3 = new ptRing(_num_faces);
  _strand3.setBox(0.1, 0.1);
  _helix1 = new ptRing(_num_faces);
  _helix1.setCircle(0.15, 1);
  _dna = new ptRing(_num_faces);
  _dna.setCircle(0.2, 0.7);
}

/**
 * 단백질 링 데이터 클래스
 * */
class ptRing {
  static setQuality(quality) {
    switch (quality) {
      case 0:
        _num_faces = 10;
        break;
      case 1:
        _num_faces = 40;
        break;
      case 2:
        _num_faces = 80;
        break;
      case 3:
        _num_faces = 120;
        break;
    }
    _inited = false;
    ptRing_init();
  }

  /**
   * 클래스 생성자
   * */
  constructor() {
    this._point = null;
    this._type = 0;
    this._numFaces = _num_faces;
    this._ring = [];
    ptRing_init();
  }

  /**
   * 데이터를 복사해 온다
   * @param {any} src 원본 데이터
   */
  copyFrom(src) {
    for (var i = 0; i < this._numFaces; i++) {
      this._ring[i] = src._ring[i];
    }
  }

  /**
   * 끝 점을 지정한다.
   * */
  setEnd() {
    var vz = new three_module_Vector3(0, 0, 0);
    for (var i = 0; i < this._numFaces; i++) {
      this._ring[i] = vz;
    }
  }

  /**
   * 박스 데이터를 설정한다.
   * @param {any} dx x 크기
   * @param {any} dy y 크기
   */
  setBox(dx, dy) {
    const dd = this._numFaces / 8;
    var p1;
    for (var i = 0; i < this._numFaces; i++) {
      var ii = i / this._numFaces;
      if (ii < 1 / 8) {
        const it = ii * 8;
        p1 = new Vector2(dx, dy * it);
        this._ring[i] = p1;
        continue;
      }
      if (ii < 3 / 8) {
        const it = (ii - 1 / 8) * 8; // 0~2

        p1 = new Vector2(dx - dx * it, dy);
        this._ring[i] = p1;
        continue;
      }
      if (ii < 5 / 8) {
        const it = (ii - 3 / 8) * 8; // 0~2

        p1 = new Vector2(-dx, dy - dy * it);
        this._ring[i] = p1;
        continue;
      }
      if (ii < 7 / 8) {
        const it = (ii - 5 / 8) * 8; // 0~2

        p1 = new Vector2(-dx + dx * it, -dy);
        this._ring[i] = p1;
        continue;
      }
      {
        const it = (ii - 7 / 8) * 8; // 0~1

        p1 = new Vector2(dx, -dy + dy * it);
        this._ring[i] = p1;
        continue;
      }
    }
  }

  /*
  setBox(dx, dy) {
      for (var i = 0; i < this._numFaces; i++) {
          var a = Math.PI * 2 / this._numFaces * i;
            var ax = Math.cos(a) ;
          var ay = Math.sin(a);
            var p1;
          var p2; 
          if (ax == 0) {
              if (ay > 0) {
                  p2 = new THREE.Vector2(dy * (ax / ay), dy);
                  this._ring[i] = p2;
              } else {
                  p2 = new THREE.Vector2(-dy * (ax / ay), -dy);
                  this._ring[i] = p2;
                }
              continue;
          }
            if (ax > 0) {
              if (ay == 0) {
                  p1 = new THREE.Vector2(dx, dx * (ay / ax));
                  this._ring[i] = p1;
                    continue;
              } else if (ay > 0) {
                  // ++
                  p1 = new THREE.Vector2(dx, dx * (ay / ax));
                  p2 = new THREE.Vector2(dy * (ax/ay), dy);
              } else {
                  // +-
                  p1 = new THREE.Vector2(dx, dx * (ay / ax));
                  p2 = new THREE.Vector2(-dy * (ax / ay), -dy);
              }
          } else {
              if (ay == 0) {
                  p1 = new THREE.Vector2(-dx, -dx * (ay / ax));
                  this._ring[i] = p1;
                  continue;
              } else if (ay > 0) {
                  // -+
                  p1 = new THREE.Vector2(-dx, -dx * (ay / ax));
                  p2 = new THREE.Vector2(dy * (ax / ay), dy);
                } else {
                  // --
                  p1 = new THREE.Vector2(-dx, -dx * (ay / ax));
                  p2 = new THREE.Vector2(-dy * (ax / ay), -dy);
                }
          }
            const l1 = p1.length();
          const l2 = p2.length();
            if (l1 > l2) {
              this._ring[i] = p2;
          } else {
              this._ring[i] = p1;
          }
              //this._ring[i] = new THREE.Vector3(ax, ay, 0);
      }
    }
  */

  /**
   * 원형 데이터를 설정한다.
   * @param {any} rx x 반지름
   * @param {any} ry y 반지름
   */
  setCircle(rx, ry) {
    for (var i = 0; i < this._numFaces; i++) {
      var a = Math.PI * 2 / this._numFaces * i;
      var ax = Math.cos(a) * rx;
      var ay = Math.sin(a) * ry;
      this._ring[i] = new three_module_Vector3(ax, ay, 0);
    }
  }

  /**
   * Coil 데이터를 설정한다.
   * @param {any} t 매개변수
   */
  setCoil(t) {
    this.copyFrom(_coil1);
    //this.interpolate(_strand1, _strand2, t);
  }

  /**
   * Strand 데이터를 설정한다.
   * @param {any} t 매개변수
   */
  setStrand(t) {
    this.copyFrom(_strand1);
  }

  /**
   * Strand Arrow 데이터를 설정한다.
   * @param {any} t 매개변수
   */
  setStrandArrow(t) {
    this.interpolate(_strand2, _strand3, t);
  }

  /**
   * Helix 데이터를 설정한다.
   * @param {any} t 매개변수
   */
  setHelix(t) {
    this.copyFrom(_helix1);
  }
  setDNA(t) {
    this.copyFrom(_dna);
  }

  /**
   * 타입 및 매개변수를 사용하여 초기화한다.
   * @param {any} type 타입
   * @param {any} t 매개변수
   */
  set(type, t) {
    this._type = type;
    var da = Math.PI * 2 / this._numFaces;
    switch (type) {
      case 'd': // DNA
      case 'D':
        // DNA
        return this.setDNA(t);
      case 'c': // coil
      case 'C':
        // coil
        return this.setCoil(t);
      case 'H': // helix
      case 'h':
        // helix
        return this.setHelix(t);
      case 'S': // strand
      case 's':
        // strand
        return this.setStrand(t);
      case 'A':
        // strand , arrow
        return this.setStrandArrow(t);
    }
  }

  /**
   * 두개의 링 데이터를 인터폴레이션한다.
   * @param {any} ring1 링 1
   * @param {any} ring2 링 2
   * @param {any} t 매개변수
   */
  interpolate(ring1, ring2, t) {
    var len = ring1._numFaces;
    var _t = 1 - t;
    this._ring = [];
    for (var i = 0; i < len; i++) {
      var a1 = ring1._ring[i];
      var a2 = ring2._ring[i];
      var aa = new three_module_Vector3(0, 0, 0);
      aa.addScaledVector(a1, _t);
      aa.addScaledVector(a2, t);
      this._ring.push(aa);
    }
  }
}
;// CONCATENATED MODULE: ./Renderer/cubic_spline.js
/**
 * Cubic Spline 곡선 생성 도구 클래스
 */
class cubic_spline_Spline {
  /**
   * 클래스 생성자
   * @param {Array} xs 샘플 점 x 좌표 리스트
   * @param {Array} ys 샘플 점 y 좌표 리스트
   */
  constructor(xs, ys) {
    this.xs = xs;
    this.ys = ys;
    this.ks = this.getNaturalKs(new Float64Array(this.xs.length));
  }

  /**
   * Natural Knot Array를 계산한다,
   * @param {Array} ks Source Knot's
   * @return {Array} Natural Knot's
   */
  getNaturalKs(ks) {
    const n = this.xs.length - 1;
    const A = zerosMat(n + 1, n + 2);
    for (let i = 1; i < n; i++ // rows
    ) {
      A[i][i - 1] = 1 / (this.xs[i] - this.xs[i - 1]);
      A[i][i] = 2 * (1 / (this.xs[i] - this.xs[i - 1]) + 1 / (this.xs[i + 1] - this.xs[i]));
      A[i][i + 1] = 1 / (this.xs[i + 1] - this.xs[i]);
      A[i][n + 1] = 3 * ((this.ys[i] - this.ys[i - 1]) / ((this.xs[i] - this.xs[i - 1]) * (this.xs[i] - this.xs[i - 1])) + (this.ys[i + 1] - this.ys[i]) / ((this.xs[i + 1] - this.xs[i]) * (this.xs[i + 1] - this.xs[i])));
    }
    A[0][0] = 2 / (this.xs[1] - this.xs[0]);
    A[0][1] = 1 / (this.xs[1] - this.xs[0]);
    A[0][n + 1] = 3 * (this.ys[1] - this.ys[0]) / ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0]));
    A[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]);
    A[n][n] = 2 / (this.xs[n] - this.xs[n - 1]);
    A[n][n + 1] = 3 * (this.ys[n] - this.ys[n - 1]) / ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1]));
    return solve(A, ks);
  }

  /**
   * inspired by https://stackoverflow.com/a/40850313/4417327
   */
  /**
   * 인덱스를 구한다.
   * @param {*} target 계산 값
   * @return {*} 인덱스
   */
  getIndexBefore(target) {
    let low = 0;
    let high = this.xs.length;
    let mid = 0;
    while (low < high) {
      mid = Math.floor((low + high) / 2);
      if (this.xs[mid] < target && mid !== low) {
        low = mid;
      } else if (this.xs[mid] >= target && mid !== high) {
        high = mid;
      } else {
        high = low;
      }
    }
    return low + 1;
  }
  /**
   * x 위치에서의 계산값을 구한다.
   *
   * @param {*} x x값
   * @return {*} 계산값
   */
  at(x) {
    let i = this.getIndexBefore(x);
    const t = (x - this.xs[i - 1]) / (this.xs[i] - this.xs[i - 1]);
    const a = this.ks[i - 1] * (this.xs[i] - this.xs[i - 1]) - (this.ys[i] - this.ys[i - 1]);
    const b = -this.ks[i] * (this.xs[i] - this.xs[i - 1]) + (this.ys[i] - this.ys[i - 1]);
    const q = (1 - t) * this.ys[i - 1] + t * this.ys[i] + t * (1 - t) * (a * (1 - t) + b * t);
    return q;
  }
}
;

/**
 * Knot's 값에 대한 방정식을 계산한다.
 * @param {*} A Linear Matrix
 * @param {*} ks Knot's
 * @return {*} 계산 결과 Knot's
 */
function solve(A, ks) {
  const m = A.length;
  let h = 0;
  let k = 0;
  while (h < m && k <= m) {
    let i_max = 0;
    let max = -Infinity;
    for (let i = h; i < m; i++) {
      const v = Math.abs(A[i][k]);
      if (v > max) {
        i_max = i;
        max = v;
      }
    }
    if (A[i_max][k] === 0) {
      k++;
    } else {
      swapRows(A, h, i_max);
      for (let i = h + 1; i < m; i++) {
        const f = A[i][k] / A[h][k];
        A[i][k] = 0;
        for (let j = k + 1; j <= m; j++) A[i][j] -= A[h][j] * f;
      }
      h++;
      k++;
    }
  }
  for (let i = m - 1; i >= 0; i-- // rows = columns
  ) {
    var v = 0;
    if (A[i][i]) {
      v = A[i][m] / A[i][i];
    }
    ks[i] = v;
    for (let j = i - 1; j >= 0; j-- // rows
    ) {
      A[j][m] -= A[j][i] * v;
      A[j][i] = 0;
    }
  }
  return ks;
}

/**
 * 제로 Matrix Array를 생성한다.
 * @param {Number} r 행 수
 * @param {Number} c 열 수
 * @return {Array} Martix Array
 */
function zerosMat(r, c) {
  const A = [];
  for (let i = 0; i < r; i++) A.push(new Float64Array(c));
  return A;
}

/**
 * 매트릭스의 행을 교환한다.
 * @param {Matrix4} m 매트릭스
 * @param {Number} k 교환할 행 번호
 * @param {Number} l 교환할 행 번호
 */
function swapRows(m, k, l) {
  let p = m[k];
  m[k] = m[l];
  m[l] = p;
}
;// CONCATENATED MODULE: ./Renderer/BSpline.js
/**
 * BSpline을 생성한다
 * @param {any} t
 * @param {any} degree 
 * @param {any} points
 * @param {any} knots
 * @param {any} weights
 * @param {any} result
 */
function BSpline(t, degree, points, knots, weights, result) {
  var i, j, s, l; // function-scoped iteration variables
  var n = points.length; // points count
  var d = points[0].length; // point dimensionality

  if (degree < 1) throw new Error('degree must be at least 1 (linear)');
  if (degree > n - 1) throw new Error('degree must be less than or equal to point count - 1');
  if (!weights) {
    // build weight vector of length [n]
    weights = [];
    for (i = 0; i < n; i++) {
      weights[i] = 1;
    }
  }
  if (!knots) {
    // build knot vector of length [n + degree + 1]
    var knots = [];
    for (i = 0; i < n + degree + 1; i++) {
      knots[i] = i;
    }
  } else {
    if (knots.length !== n + degree + 1) throw new Error('bad knot vector length');
  }
  var domain = [degree, knots.length - 1 - degree];

  // remap t to the domain where the spline is defined
  var low = knots[domain[0]];
  var high = knots[domain[1]];
  t = t * (high - low) + low;
  if (t < low || t > high) throw new Error('out of bounds');

  // find s (the spline segment) for the [t] value provided
  for (s = domain[0]; s < domain[1]; s++) {
    if (t >= knots[s] && t <= knots[s + 1]) {
      break;
    }
  }

  // convert points to homogeneous coordinates
  var v = [];
  for (i = 0; i < n; i++) {
    v[i] = [];
    for (j = 0; j < d; j++) {
      v[i][j] = points[i][j] * weights[i];
    }
    v[i][d] = weights[i];
  }

  // l (level) goes from 1 to the curve degree + 1
  var alpha;
  for (l = 1; l <= degree + 1; l++) {
    // build level l of the pyramid
    for (i = s; i > s - degree - 1 + l; i--) {
      alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i]);

      // interpolate each component
      for (j = 0; j < d + 1; j++) {
        v[i][j] = (1 - alpha) * v[i - 1][j] + alpha * v[i][j];
      }
    }
  }

  // convert back to cartesian and return
  var result = result || [];
  for (i = 0; i < d; i++) {
    result[i] = v[s][i] / v[s][d];
  }
  return result;
}
;// CONCATENATED MODULE: ./Renderer/jsm/utils/BufferGeometryUtils.js

class BufferGeometryUtils {
  static computeTangents(geometry) {
    geometry.computeTangents();
    console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');
  }

  /**
   * @param  {Array<BufferGeometry>} geometries
   * @param  {Boolean} useGroups
   * @return {BufferGeometry}
   */
  static mergeBufferGeometries(geometries, useGroups = false) {
    const isIndexed = geometries[0].index !== null;
    const attributesUsed = new Set(Object.keys(geometries[0].attributes));
    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    const attributes = {};
    const morphAttributes = {};
    const morphTargetsRelative = geometries[0].morphTargetsRelative;
    const mergedGeometry = new BufferGeometry();
    let offset = 0;
    for (let i = 0; i < geometries.length; ++i) {
      const geometry = geometries[i];
      let attributesCount = 0;

      // ensure that all geometries are indexed, or none

      if (isIndexed !== (geometry.index !== null)) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');
        return null;
      }

      // gather attributes, exit early if they're different

      for (const name in geometry.attributes) {
        if (!attributesUsed.has(name)) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
          return null;
        }
        if (attributes[name] === undefined) attributes[name] = [];
        attributes[name].push(geometry.attributes[name]);
        attributesCount++;
      }

      // ensure geometries have the same number of attributes

      if (attributesCount !== attributesUsed.size) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');
        return null;
      }

      // gather morph attributes, exit early if they're different

      if (morphTargetsRelative !== geometry.morphTargetsRelative) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');
        return null;
      }
      for (const name in geometry.morphAttributes) {
        if (!morphAttributesUsed.has(name)) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');
          return null;
        }
        if (morphAttributes[name] === undefined) morphAttributes[name] = [];
        morphAttributes[name].push(geometry.morphAttributes[name]);
      }

      // gather .userData

      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
      mergedGeometry.userData.mergedUserData.push(geometry.userData);
      if (useGroups) {
        let count;
        if (isIndexed) {
          count = geometry.index.count;
        } else if (geometry.attributes.position !== undefined) {
          count = geometry.attributes.position.count;
        } else {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');
          return null;
        }
        mergedGeometry.addGroup(offset, count, i);
        offset += count;
      }
    }

    // merge indices

    if (isIndexed) {
      let indexOffset = 0;
      const mergedIndex = [];
      for (let i = 0; i < geometries.length; ++i) {
        const index = geometries[i].index;
        for (let j = 0; j < index.count; ++j) {
          mergedIndex.push(index.getX(j) + indexOffset);
        }
        indexOffset += geometries[i].attributes.position.count;
      }
      mergedGeometry.setIndex(mergedIndex);
    }

    // merge attributes

    for (const name in attributes) {
      const mergedAttribute = this.mergeBufferAttributes(attributes[name]);
      if (!mergedAttribute) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');
        return null;
      }
      mergedGeometry.setAttribute(name, mergedAttribute);
    }

    // merge morph attributes

    for (const name in morphAttributes) {
      const numMorphTargets = morphAttributes[name][0].length;
      if (numMorphTargets === 0) break;
      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
      mergedGeometry.morphAttributes[name] = [];
      for (let i = 0; i < numMorphTargets; ++i) {
        const morphAttributesToMerge = [];
        for (let j = 0; j < morphAttributes[name].length; ++j) {
          morphAttributesToMerge.push(morphAttributes[name][j][i]);
        }
        const mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);
        if (!mergedMorphAttribute) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');
          return null;
        }
        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
      }
    }
    return mergedGeometry;
  }

  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {BufferAttribute}
   */
  static mergeBufferAttributes(attributes) {
    let TypedArray;
    let itemSize;
    let normalized;
    let arrayLength = 0;
    for (let i = 0; i < attributes.length; ++i) {
      const attribute = attributes[i];
      if (attribute.isInterleavedBufferAttribute) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');
        return null;
      }
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');
        return null;
      }
      if (itemSize === undefined) itemSize = attribute.itemSize;
      if (itemSize !== attribute.itemSize) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');
        return null;
      }
      if (normalized === undefined) normalized = attribute.normalized;
      if (normalized !== attribute.normalized) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');
        return null;
      }
      arrayLength += attribute.array.length;
    }
    const array = new TypedArray(arrayLength);
    let offset = 0;
    for (let i = 0; i < attributes.length; ++i) {
      array.set(attributes[i].array, offset);
      offset += attributes[i].array.length;
    }
    return new BufferAttribute(array, itemSize, normalized);
  }

  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {Array<InterleavedBufferAttribute>}
   */
  static interleaveAttributes(attributes) {
    // Interleaves the provided attributes into an InterleavedBuffer and returns
    // a set of InterleavedBufferAttributes for each attribute
    let TypedArray;
    let arrayLength = 0;
    let stride = 0;

    // calculate the the length and type of the interleavedBuffer
    for (let i = 0, l = attributes.length; i < l; ++i) {
      const attribute = attributes[i];
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('AttributeBuffers of different types cannot be interleaved');
        return null;
      }
      arrayLength += attribute.array.length;
      stride += attribute.itemSize;
    }

    // Create the set of buffer attributes
    const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);
    let offset = 0;
    const res = [];
    const getters = ['getX', 'getY', 'getZ', 'getW'];
    const setters = ['setX', 'setY', 'setZ', 'setW'];
    for (let j = 0, l = attributes.length; j < l; j++) {
      const attribute = attributes[j];
      const itemSize = attribute.itemSize;
      const count = attribute.count;
      const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
      res.push(iba);
      offset += itemSize;

      // Move the data for each attribute into the new interleavedBuffer
      // at the appropriate offset
      for (let c = 0; c < count; c++) {
        for (let k = 0; k < itemSize; k++) {
          iba[setters[k]](c, attribute[getters[k]](c));
        }
      }
    }
    return res;
  }

  /**
   * @param {Array<BufferGeometry>} geometry
   * @return {number}
   */
  static estimateBytesUsed(geometry) {
    // Return the estimated memory used by this geometry in bytes
    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
    // for InterleavedBufferAttributes.
    let mem = 0;
    for (const name in geometry.attributes) {
      const attr = geometry.getAttribute(name);
      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    const indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {number} tolerance
   * @return {BufferGeometry>}
   */
  static mergeVertices(geometry, tolerance = 1e-4) {
    tolerance = Math.max(tolerance, Number.EPSILON);

    // Generate an index buffer if the geometry doesn't have one, or optimize it
    // if it's already available.
    const hashToIndex = {};
    const indices = geometry.getIndex();
    const positions = geometry.getAttribute('position');
    const vertexCount = indices ? indices.count : positions.count;

    // next value for triangle indices
    let nextIndex = 0;

    // attributes and new attribute arrays
    const attributeNames = Object.keys(geometry.attributes);
    const attrArrays = {};
    const morphAttrsArrays = {};
    const newIndices = [];
    const getters = ['getX', 'getY', 'getZ', 'getW'];

    // initialize the arrays
    for (let i = 0, l = attributeNames.length; i < l; i++) {
      const name = attributeNames[i];
      attrArrays[name] = [];
      const morphAttr = geometry.morphAttributes[name];
      if (morphAttr) {
        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);
      }
    }

    // convert the error tolerance to an amount of decimal places to truncate to
    const decimalShift = Math.log10(1 / tolerance);
    const shiftMultiplier = Math.pow(10, decimalShift);
    for (let i = 0; i < vertexCount; i++) {
      const index = indices ? indices.getX(i) : i;

      // Generate a hash for the vertex attributes at the current index 'i'
      let hash = '';
      for (let j = 0, l = attributeNames.length; j < l; j++) {
        const name = attributeNames[j];
        const attribute = geometry.getAttribute(name);
        const itemSize = attribute.itemSize;
        for (let k = 0; k < itemSize; k++) {
          // double tilde truncates the decimal value
          hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;
        }
      }

      // Add another reference to the vertex if it's already
      // used by another index
      if (hash in hashToIndex) {
        newIndices.push(hashToIndex[hash]);
      } else {
        // copy data to the new index in the attribute arrays
        for (let j = 0, l = attributeNames.length; j < l; j++) {
          const name = attributeNames[j];
          const attribute = geometry.getAttribute(name);
          const morphAttr = geometry.morphAttributes[name];
          const itemSize = attribute.itemSize;
          const newarray = attrArrays[name];
          const newMorphArrays = morphAttrsArrays[name];
          for (let k = 0; k < itemSize; k++) {
            const getterFunc = getters[k];
            newarray.push(attribute[getterFunc](index));
            if (morphAttr) {
              for (let m = 0, ml = morphAttr.length; m < ml; m++) {
                newMorphArrays[m].push(morphAttr[m][getterFunc](index));
              }
            }
          }
        }
        hashToIndex[hash] = nextIndex;
        newIndices.push(nextIndex);
        nextIndex++;
      }
    }

    // Generate typed arrays from new attribute arrays and update
    // the attributeBuffers
    const result = geometry.clone();
    for (let i = 0, l = attributeNames.length; i < l; i++) {
      const name = attributeNames[i];
      const oldAttribute = geometry.getAttribute(name);
      const buffer = new oldAttribute.array.constructor(attrArrays[name]);
      const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);
      result.setAttribute(name, attribute);

      // Update the attribute arrays
      if (name in morphAttrsArrays) {
        for (let j = 0; j < morphAttrsArrays[name].length; j++) {
          const oldMorphAttribute = geometry.morphAttributes[name][j];
          const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);
          const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
          result.morphAttributes[name][j] = morphAttribute;
        }
      }
    }

    // indices

    result.setIndex(newIndices);
    return result;
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {number} drawMode
   * @return {BufferGeometry>}
   */
  static toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === TrianglesDrawMode) {
      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');
      return geometry;
    }
    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
      let index = geometry.getIndex();

      // generate index if not present

      if (index === null) {
        const indices = [];
        const position = geometry.getAttribute('position');
        if (position !== undefined) {
          for (let i = 0; i < position.count; i++) {
            indices.push(i);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
          return geometry;
        }
      }

      //

      const numberOfTriangles = index.count - 2;
      const newIndices = [];
      if (drawMode === TriangleFanDrawMode) {
        // gl.TRIANGLE_FAN

        for (let i = 1; i <= numberOfTriangles; i++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
        }
      } else {
        // gl.TRIANGLE_STRIP

        for (let i = 0; i < numberOfTriangles; i++) {
          if (i % 2 === 0) {
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i + 2));
          } else {
            newIndices.push(index.getX(i + 2));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
      }

      // build final geometry

      const newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);
      return geometry;
    }
  }

  /**
   * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
   * Helpful for Raytracing or Decals.
   * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
   * @return {Object} An Object with original position/normal attributes and morphed ones.
   */
  static computeMorphedAttributes(object) {
    if (object.geometry.isBufferGeometry !== true) {
      console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');
      return null;
    }
    const _vA = new three_module_Vector3();
    const _vB = new three_module_Vector3();
    const _vC = new three_module_Vector3();
    const _tempA = new three_module_Vector3();
    const _tempB = new three_module_Vector3();
    const _tempC = new three_module_Vector3();
    const _morphA = new three_module_Vector3();
    const _morphB = new three_module_Vector3();
    const _morphC = new three_module_Vector3();
    function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {
      _vA.fromBufferAttribute(attribute, a);
      _vB.fromBufferAttribute(attribute, b);
      _vC.fromBufferAttribute(attribute, c);
      const morphInfluences = object.morphTargetInfluences;
      if (material.morphTargets && morphAttribute && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const influence = morphInfluences[i];
          const morph = morphAttribute[i];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morph, a);
          _tempB.fromBufferAttribute(morph, b);
          _tempC.fromBufferAttribute(morph, c);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
            _morphB.addScaledVector(_tempB, influence);
            _morphC.addScaledVector(_tempC, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(_vA), influence);
            _morphB.addScaledVector(_tempB.sub(_vB), influence);
            _morphC.addScaledVector(_tempC.sub(_vC), influence);
          }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
      }
      if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA);
        object.boneTransform(b, _vB);
        object.boneTransform(c, _vC);
      }
      modifiedAttributeArray[a * 3 + 0] = _vA.x;
      modifiedAttributeArray[a * 3 + 1] = _vA.y;
      modifiedAttributeArray[a * 3 + 2] = _vA.z;
      modifiedAttributeArray[b * 3 + 0] = _vB.x;
      modifiedAttributeArray[b * 3 + 1] = _vB.y;
      modifiedAttributeArray[b * 3 + 2] = _vB.z;
      modifiedAttributeArray[c * 3 + 0] = _vC.x;
      modifiedAttributeArray[c * 3 + 1] = _vC.y;
      modifiedAttributeArray[c * 3 + 2] = _vC.z;
    }
    const geometry = object.geometry;
    const material = object.material;
    let a, b, c;
    const index = geometry.index;
    const positionAttribute = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    const normalAttribute = geometry.attributes.normal;
    const morphNormal = geometry.morphAttributes.position;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    let i, j, il, jl;
    let group, groupMaterial;
    let start, end;
    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
      // indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = index.getX(j);
            b = index.getX(j + 1);
            c = index.getX(j + 2);
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(index.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = index.getX(i);
          b = index.getX(i + 1);
          c = index.getX(i + 2);
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    } else if (positionAttribute !== undefined) {
      // non-indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = j;
            b = j + 1;
            c = j + 2;
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = i;
          b = i + 1;
          c = i + 2;
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    }
    const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);
    const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);
    return {
      positionAttribute: positionAttribute,
      normalAttribute: normalAttribute,
      morphedPositionAttribute: morphedPositionAttribute,
      morphedNormalAttribute: morphedNormalAttribute
    };
  }
}

;// CONCATENATED MODULE: ./Renderer/ptSpline.js








/**
 * 단백질 Spline 포인트 클래스
 * */
class ptSplinePoint {
  /**
   * 클래스 생성자
   * */
  constructor() {
    this._pos = new three_module_Vector3(0, 0, 0);
    this._normal = new three_module_Vector3(0, 0, 0);
    this._forward = new three_module_Vector3(0, 0, 0);
    this._binormal = new three_module_Vector3(0, 0, 0);
    this._type = 0;
    this._flipped = false;
    this._id = 0;
  }

  /**
   * 타입을 지정한다.
   * @param {any} type 타입
   */
  setType(type) {
    this._type = type;
  }

  /**
   * 위치를 지정한다.
   * @param {any} pos 위치 좌표
   */
  setPos(pos) {
    this._pos.copy(pos);
  }

  /**
   * 노말 벡터를 지정한다.
   * @param {any} normal 노말 벡터
   */
  setNormal(normal) {
    this._normal.copy(normal);
    this._normal.normalize();
  }

  /**
   * forward 벡터를 지정한다.
   * @param {any} forward forward 벡터
   */
  setForward(forward) {
    this._forward.copy(forward);
    this._forward.normalize();
    this._binormal.copy(this._forward);
    this._binormal.cross(this._normal);
    this._binormal.normalize();
  }

  /**
   * flip 상태를 체크한다.
   * @param {any} prev_point flip 기준점
   */
  checkFlip(prev_point) {
    const dot = this._binormal.dot(prev_point._binormal);
    if (dot < 0) {
      this._normal.multiplyScalar(-1);
      this._binormal.multiplyScalar(-1);
      this._flipped = true;
    }
  }

  /**
   * 오브젝트를 복제한다.
   * @returns {ptSplinePoint} 복제된 오브젝트
   * */
  clone() {
    var npos = new ptSplinePoint();
    npos._pos = this._pos.clone();
    npos._normal = this._normal.clone();
    npos._forward = this._forward.clone();
    npos._binormal = this._binormal.clone();
    npos._type = this._type;
    npos._flipped = this._flipped;
    npos._id = this._id;
    return npos;
  }
}

/**
 * 단백질 Spline 벡터 데이터 클래스 
 * */
class ptSplineV3 {
  /**
   * 클래스 생성자
   * */
  constructor() {
    this._p0 = null;
    this._p1 = null;
    this._p2 = null;
    this._p3 = null;
  }

  /**
   * point list 로 초기화 설정한다.
   * @param {any} p0 point 0
   * @param {any} p1 point 1
   * @param {any} p2 point 2
   * @param {any} p3 point 3
   */
  setupWithArray(p0, p1, p2, p3) {
    const ts = [-1, 0, 1, 2];
    const pos_x = [p0[0], p1[0], p2[0], p3[0]];
    this._sp_pos_x = new Spline(ts, pos_x);
    const pos_y = [p0[1], p1[1], p2[1], p3[1]];
    this._sp_pos_y = new Spline(ts, pos_y);
    const pos_z = [p0[2], p1[2], p2[2], p3[2]];
    this._sp_pos_z = new Spline(ts, pos_z);
  }

  /**
   * point list 로 초기화 설정한다.
   * @param {any} p0
   * @param {any} p1
   * @param {any} p2
   * @param {any} p3
   */
  setup(p0, p1, p2, p3) {
    const ts = [-1, 0, 1, 2];
    const pos_x = [p0.x, p1.x, p2.x, p3.x];
    this._sp_pos_x = new Spline(ts, pos_x);
    const pos_y = [p0.y, p1.y, p2.y, p3.y];
    this._sp_pos_y = new Spline(ts, pos_y);
    const pos_z = [p0.z, p1.z, p2.z, p3.z];
    this._sp_pos_z = new Spline(ts, pos_z);
  }

  /**
   * 매개변수 t 에 대한 위치를 얻는다.
   * @param {any} t 매개변수
   */
  get(t) {
    var pos = new THREE.Vector3(this._sp_pos_x.at(t), this._sp_pos_y.at(t), this._sp_pos_z.at(t));
    return pos;
  }
}

/**
 * 단백질 Spline 데이터 클래스
 * */
class ptSpline {
  /**
   * 클래스 생성자
   * */
  constructor() {
    this._mesh = new ptMesh();
    this._prevRing = null;
    this._first = true;
  }

  /**
   * blank line 메쉬를 생성한다.
   * @param {any} gr 그룹 오브젝트
   * @param {any} p1 점 1
   * @param {any} p2 점 2
   * @param {any} cr 색상 red
   * @param {any} cg 색상 green
   * @param {any} cb 색상 blue
   */
  static generateBlankLineMesh(gr, p1, p2, cr, cg, cb) {
    var v1 = p2.clone();
    v1.sub(p1);
    const vlen = v1.length();
    const dt = 1 / vlen * 1.2;
    var up = new three_module_Vector3(0, 1, 0);
    var matTr = new Matrix4();
    var matSc = new Matrix4();
    var matLk = new Matrix4();
    var pos = new three_module_Vector3();
    var step = dt;
    var st = dt * 0.5;
    var ed = 1 - st;
    let geoms = [];
    for (var i = st; i <= ed; i += step) {
      pos.set(p1.x, p1.y, p1.z);
      pos.lerp(p2, i);
      matTr.makeTranslation(pos.x, pos.y, pos.z);
      matSc.makeScale(0.2, 0.2, 0.6);
      matLk.lookAt(pos, p2, up);
      matTr.multiply(matLk);
      matTr.multiply(matSc);
      let geom = gr._cylinder.clone();
      geom.applyMatrix4(matTr);
      geoms.push(geom);
      //mergedGeo.merge(gr._cylinder, matTr);
    }

    var mergedGeo = BufferGeometryUtils.mergeBufferGeometries(geoms);
    const material = new MeshLambertMaterial();
    material.color = new Color(cr, cg, cb);
    var mesh = new three_module_Mesh(mergedGeo, material);
    mesh._originalColorR = cr;
    mesh._originalColorG = cg;
    mesh._originalColorB = cb;
    mesh._mat = material;
    return mesh;
  }

  /**
   * 포인트 리스트를 사용하여 스플라인을 생성한다.
   * @param {any} sppoint_list 포인트 리스트
   * @param {any} cr 색상 red
   * @param {any} cg 색상 green
   * @param {any} cb 색상 blue
   * @param {any} multiple_mesh 여려개의 메쉬로 생성할지 여부
   */
  generate(sppoint_list, cr, cg, cb, multiple_mesh) {
    const qual = GeomMole.getQuality();
    // 이 두가지로 퀄리티 결정

    var step = 0.099999999;
    switch (qual) {
      case 0:
        step = 0.099999999 * 2;
        break;
      case 1:
        step = 0.099999999;
        break;
      case 2:
        step = 0.099999999 * 0.5;
        break;
      case 3:
        step = 0.099999999 * 0.25;
        break;
    }
    ptRing.setQuality(qual);
    var list = [];
    const len = sppoint_list.length;
    var sp_k = [];
    var sp_px = [];
    var sp_py = [];
    var sp_pz = [];
    var sp_n = [];
    var sp_f = [];
    var sp_b = [];
    for (let i = 0; i < len; i++) {
      let ii = i - 1;
      if (ii < 0) ii = 0;
      sp_k[i] = i;
      sp_px[i] = sppoint_list[ii]._pos.x;
      sp_py[i] = sppoint_list[ii]._pos.y;
      sp_pz[i] = sppoint_list[ii]._pos.z;
    }
    var b1;
    var b2;
    var a1;
    var a2;
    var spline_px = new cubic_spline_Spline(sp_k, sp_px);
    var spline_py = new cubic_spline_Spline(sp_k, sp_py);
    var spline_pz = new cubic_spline_Spline(sp_k, sp_pz);
    var ring = new ptRing();
    var ringNext = new ptRing();
    var ringEnd = new ptRing();
    var ringPrev = null;
    ringEnd.setEnd();
    if (!multiple_mesh) {
      this._mesh.reset();
    }
    const spline_degree = 3;
    var kk = [];
    var pos;
    var normal;
    var binormal;
    for (var j = 1; j < len - 1; j++) {
      kk[0] = j - 2;
      kk[1] = j - 1;
      kk[2] = j + 0;
      kk[3] = j + 1;
      kk[4] = j + 2;
      if (kk[0] < 0) kk[0] = 0;
      if (kk[1] < 0) kk[1] = 0;
      if (kk[4] > len - 1) kk[4] = len - 1;
      if (kk[5] > len - 1) kk[5] = len - 1;
      for (var k = 0; k < 4; k++) {
        const _k = k;
        sp_n[k] = [sppoint_list[kk[_k]]._normal.x, sppoint_list[kk[_k]]._normal.y, sppoint_list[kk[_k]]._normal.z];
        sp_b[k] = [sppoint_list[kk[_k]]._binormal.x, sppoint_list[kk[_k]]._binormal.y, sppoint_list[kk[_k]]._binormal.z];
        sp_f[k] = [sppoint_list[kk[_k]]._forward.x, sppoint_list[kk[_k]]._forward.y, sppoint_list[kk[_k]]._forward.z];
      }
      var prev_type = sppoint_list[kk[1]]._type;
      var cur_type = sppoint_list[kk[2]]._type;
      const next_type = sppoint_list[kk[3]]._type;
      const cur_id = sppoint_list[kk[2]]._id;

      //if (cur_type == 'S' && (next_type != 'S' || j == len -2)) { // arrow
      //    cur_type = 'A'; // arrow
      //}

      ringNext.set(next_type, 0);
      if (multiple_mesh) {
        this._mesh.reset();
      }
      var first = true;
      for (var i = 0; i <= 1; i += step) {
        //ring.interpolate(ring1, ring2, i);
        ring.set(cur_type, i);
        const ii = i + j;
        pos = new three_module_Vector3(spline_px.at(ii), spline_py.at(ii), spline_pz.at(ii));

        //var _pos = BSpline(i, spline_degree, sp_p);
        var _normal = BSpline(i, spline_degree, sp_n);
        var _forward = BSpline(i, spline_degree, sp_f);
        var _binormal = BSpline(i, spline_degree, sp_b);

        //var pos = new THREE.Vector3(_pos[0], _pos[1], _pos[2]);
        normal = new three_module_Vector3(_normal[0], _normal[1], _normal[2]);
        var forward = new three_module_Vector3(_forward[0], _forward[1], _forward[2]);
        binormal = new three_module_Vector3(_binormal[0], _binormal[1], _binormal[2]);
        normal.normalize();
        forward.normalize();
        binormal.normalize();

        //var binormal = forward.clone();
        //binormal.cross(normal);

        if (ii == 1) {
          this._mesh.addRingVertex(pos, normal, binormal, ringEnd);
          this._startPos = pos.clone();
          first = false;
        } else {
          if (multiple_mesh) {
            if (i == 0 && prev_type != cur_type) {
              this._mesh.addRingVertex(pos, normal, binormal, ringPrev);
              first = false;
            }
          }
        }
        this._mesh.addRingVertex(pos, normal, binormal, ring);
        if (!first) {
          this._mesh.addRingIndex(ring);
        }
        first = false;
        if (ringPrev == null) {
          ringPrev = new ptRing();
        }
        ringPrev.copyFrom(ring);
      }
      if (multiple_mesh) {
        if (j == len - 2) {
          this._mesh.addRingVertex(pos, normal, binormal, ringEnd);
          this._mesh.addRingIndex(ringEnd);
        }
        let geometry = this._mesh.generateGeometry();
        geometry._ptPoint = sppoint_list[kk[2]];
        list.push(geometry);
      }
    }
    this._endPos = pos.clone();
    if (multiple_mesh) {
      return list;
    } else {
      this._mesh.addRingVertex(pos, normal, binormal, ringEnd);
      this._mesh.addRingIndex(ringEnd);
      let geometry = this._mesh.generateGeometry();
      return geometry;
    }
  }
}
;// CONCATENATED MODULE: ./Renderer/AtomDef.js
/**
 * @file 원소의 정보를 정의한 클래스
 * @version 0.1
 */
var AtomDef_AtomDef = {};
AtomDef_AtomDef._atomDefList = [];
AtomDef_AtomDef._atomNumList = [];

/**
 * index에 해당하는 원자 정보를 반환한다
 * @param {Number} index 원자 인덱스
 */
AtomDef_AtomDef.GetDefWithNumber = function (index) {
  return AtomDef_AtomDef._atomNumList[index];
};

/**
 * id에 해당하는 원자 정보를 반환한다
 * @param {String} id 원자 아이디
 */
AtomDef_AtomDef.GetDefWithID = function (id) {
  return AtomDef_AtomDef._atomDefList[id.toUpperCase()];
};

/**
 * 한 원소의 특성을 정의한 클래스다. 이름, 반지름, 질량 등이 정의된다.
 * */
class AtomDef_CAtomDef {
  /**
   * 원소를 정의한다
   * @param {any} number 원소 번호
   * @param {any} atom 원소 기호
   * @param {any} kname 원소 이름 (한글)
   * @param {any} name 원소 이름 (영문)
   * @param {any} r 컬러 R
   * @param {any} g 컬러 G
   * @param {any} b 컬러 B
   * @param {any} radius 반지름
   * @param {any} metal 메탈
   * @param {any} group 그룹
   * @param {any} period 주기율
   */
  constructor(number, atom, kname, name, r, g, b, radius, metal, group, period) {
    /// AtomDef의 ID이다. string
    this._id = atom.toUpperCase();

    /// 원소의 이름. string
    this._atom_id = atom;

    /// 원소의 반지름. 
    this._radius = (radius + 100) / 500 * 1.;
    this._empirical_radius = radius;

    /// 원소의 이름. 영문
    this._name = name;

    /// 원소의 이름. 한글
    this._korean_name = kname;

    /// 원소의 컬러
    this._color = [0, 0, 0];

    /// 원소의 디퓨즈 컬러
    this._diffuseColor = [0, 0, 0];

    /// 원소의 emissive 컬러
    this._emissiveColor = [0, 0, 0];

    /// 원소의 specular 컬러
    this._specularColor = [1, 1, 1];
    this.setColor(r / 255, g / 255, b / 255);
    this.setDefaultColor(r / 255, g / 255, b / 255);

    /// 원소의 Ambient 컬러
    this._ambientColor = [0.0, 0.0, 0.0];

    /// 원소의 specular power
    this._specularPower = 15;

    /// 원소의 원자수
    this._atom_number = number;

    /// 메탈
    this._metal = metal;

    /// 원소의 주기
    this._period = period;

    /// 원소의 그룹
    this._group = group;

    /// 가질 수 있는 본드의 수
    this._vsepr_type = 0;

    /// lone pair 의 수
    this._vsepr_lpair = 0;

    /// 원소 결합시 각도
    this._vsepr_angle = 0;

    /// 원소 크기
    this._atom_vis_size = 1;

    /// 원소 가시화 여부
    this._visible = true;
  }

  /**
   * 색상을 정의한다
   * @param {any} r red
   * @param {any} g green
   * @param {any} b blue
   */
  setColor(r, g, b) {
    this._color = [r, g, b];
    this._diffuseColor = [r, g, b];
    this._emissiveColor = [r * 0.1, g * 0.1, b * 0.1];
    this._specularColor = [1, 1, 1];
  }
  /**
   * 기본 컬러를 정의한다
   * @param {Number} r red
   * @param {Number} g green
   * @param {Number} b blue
   */
  setDefaultColor(r, g, b) {
    this._defColor = [r, g, b];
  }
  /**
   * 기본 원소 문자 크기를 정의한다
   * @param {Number} size 크기
   */
  setNameSize(size) {
    this._atom_vis_size = size;
  }
}
;

/**
 * 원소의 VSEPR 값을 정의
 * @param {String} atom 원소 기호
 * @param {String} type 타입
 * @param {Function} lone_pair long pair
 * @param {Function} angle 각도
 */
function AtomDef_setAtomVSEPR(atom, type, lone_pair, angle) {
  var atom_def = AtomDef_AtomDef._atomDefList[atom.toUpperCase()];
  if (!atom_def) return;
  atom_def._vsepr_type = type;
  atom_def._vsepr_lpair = lone_pair;
  atom_def._vsepr_angle = angle;
}

/**
 * 원소의 메탈 값을 정의
 * @param {String} atom 원소
 * @param {Number} metal 메탈 값
 */
function AtomDef_setAtomMetal(atom, metal) {
  var atom_def = AtomDef_AtomDef._atomDefList[atom.toUpperCase()];
  if (!atom_def) return;
  atom_def._metal = metal;
}

/**
* 원소의 Isotope 값을 설정
* @param {String} isotope 원소의 isotope
* @param {String} atom
*/
function AtomDef_addIsotope(isotope, atom) {}

/**
 * 원소의 정보를 정의한다
 * @param {Number} number
 * @param {String} atom
 * @param {String} kname
 * @param {String} name
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} radius
 * @param {Number} metal
 * @param {String} group
 * @param {Number} period
 */
function AtomDef_setAtomData(number, atom, kname, name, r, g, b, radius, metal, group, period) {
  var atom_def = new AtomDef_CAtomDef(number, atom, kname, name, r, g, b, radius, metal, group, period);
  AtomDef_AtomDef._atomDefList[atom.toUpperCase()] = atom_def;
  AtomDef_AtomDef._atomNumList[number] = atom_def;
}

///////////////////
// setAtomData
///////////////////

AtomDef_setAtomData(1, "H", "수소", "Hydrogen", 255, 255, 255, 25, 0, 1, 1);
AtomDef_setAtomData(2, "He", "헬륨", "Helium", 217, 255, 255, 120, 0, 18, 1);
AtomDef_setAtomData(3, "Li", "리튬", "Lithium", 204, 128, 255, 145, 0, 1, 2);
AtomDef_setAtomData(4, "Be", "베릴륨", "Beryllium", 194, 255, 0, 105, 0, 2, 2);
AtomDef_setAtomData(5, "B", "붕소", "Boron", 255, 181, 181, 85, 0, 13, 2);
AtomDef_setAtomData(6, "C", "탄소", "Carbon", 54, 54, 54, 70, 0, 14, 2);
AtomDef_setAtomData(7, "N", "질소", "Nitrogen", 48, 80, 248, 65, 0, 15, 2);
AtomDef_setAtomData(8, "O", "산소", "Oxygen", 255, 13, 13, 60, 0, 16, 2);
AtomDef_setAtomData(9, "F", "플루오린", "Fluorine", 144, 224, 80, 50, 0, 17, 2);
AtomDef_setAtomData(10, "Ne", "네온", "Neon", 179, 227, 245, 160, 0, 18, 2);
AtomDef_setAtomData(11, "Na", "나트륨", "Sodium", 171, 92, 242, 180, 0, 1, 3);
AtomDef_setAtomData(12, "Mg", "마그네슘", "Magnesium", 138, 255, 0, 150, 0, 2, 3);
AtomDef_setAtomData(13, "Al", "알루미늄", "Aluminium", 191, 166, 166, 125, 0, 13, 3);
AtomDef_setAtomData(14, "Si", "규소", "Silicon", 240, 200, 160, 110, 0, 14, 3);
AtomDef_setAtomData(15, "P", "인", "Phosphorus", 255, 128, 0, 100, 0, 15, 3);
AtomDef_setAtomData(16, "S", "황", "Sulfur", 255, 255, 48, 100, 0, 16, 3);
AtomDef_setAtomData(17, "Cl", "염소", "Chlorine", 31, 240, 31, 100, 0, 17, 3);
AtomDef_setAtomData(18, "Ar", "아르곤", "Argon", 128, 209, 227, 71, 0, 18, 3);
AtomDef_setAtomData(19, "K", "칼륨", "Potassium", 143, 64, 212, 220, 0, 1, 4);
AtomDef_setAtomData(20, "Ca", "칼슘", "Calcium", 61, 255, 0, 180, 0, 2, 4);
AtomDef_setAtomData(21, "Sc", "스칸듐", "Scandium", 230, 230, 230, 160, 0, 3, 4);
AtomDef_setAtomData(22, "Ti", "티타늄", "Titanium", 191, 194, 199, 140, 0, 4, 4);
AtomDef_setAtomData(23, "V", "바나듐", "Vanadium", 166, 166, 171, 135, 0, 5, 4);
AtomDef_setAtomData(24, "Cr", "크롬", "Chromium", 138, 153, 199, 140, 0, 6, 4);
AtomDef_setAtomData(25, "Mn", "망가니즈", "Manganese", 156, 122, 199, 140, 0, 7, 4);
AtomDef_setAtomData(26, "Fe", "철", "Iron", 224, 102, 51, 140, 0, 8, 4);
AtomDef_setAtomData(27, "Co", "코발트", "Cobalt", 240, 144, 160, 135, 0, 9, 4);
AtomDef_setAtomData(28, "Ni", "니켈", "Nickel", 80, 208, 80, 135, 0, 10, 4);
AtomDef_setAtomData(29, "Cu", "구리", "Copper", 200, 128, 51, 135, 0, 11, 4);
AtomDef_setAtomData(30, "Zn", "아연", "Zinc", 125, 128, 176, 135, 0, 12, 4);
AtomDef_setAtomData(31, "Ga", "갈륨", "Gallium", 194, 143, 143, 130, 0, 13, 4);
AtomDef_setAtomData(32, "Ge", "게르마늄", "Germanium", 102, 143, 143, 125, 0, 14, 4);
AtomDef_setAtomData(33, "As", "비소", "Arsenic", 189, 128, 227, 115, 0, 15, 4);
AtomDef_setAtomData(34, "Se", "셀레늄", "Selenium", 255, 161, 0, 115, 0, 16, 4);
AtomDef_setAtomData(35, "Br", "브로민", "Bromine", 166, 41, 41, 115, 0, 17, 4);
AtomDef_setAtomData(36, "Kr", "크립톤", "Krypton", 92, 184, 209, 115, 0, 18, 4);
AtomDef_setAtomData(37, "Rb", "루비듐", "Rubidium", 112, 46, 176, 235, 0, 1, 5);
AtomDef_setAtomData(38, "Sr", "스트론튬", "Strontium", 0, 255, 0, 200, 0, 2, 5);
AtomDef_setAtomData(39, "Y", "이트륨", "Yttrium", 148, 255, 255, 180, 0, 3, 5);
AtomDef_setAtomData(40, "Zr", "지르코늄", "Zirconium", 148, 224, 224, 155, 0, 4, 5);
AtomDef_setAtomData(41, "Nb", "나이오븀", "Niobium", 115, 194, 201, 145, 0, 5, 5);
AtomDef_setAtomData(42, "Mo", "몰리브데넘", "Molybdenum", 84, 181, 181, 145, 0, 6, 5);
AtomDef_setAtomData(43, "Tc", "테크네튬", "Technetium", 59, 158, 158, 135, 0, 7, 5);
AtomDef_setAtomData(44, "Ru", "루테늄", "Ruthenium", 36, 143, 143, 130, 0, 8, 5);
AtomDef_setAtomData(45, "Rh", "로듐", "Rhodium", 10, 125, 140, 135, 0, 9, 5);
AtomDef_setAtomData(46, "Pd", "팔라듐", "Palladium", 0, 105, 133, 140, 0, 10, 5);
AtomDef_setAtomData(47, "Ag", "은", "Silver", 192, 192, 192, 160, 0, 11, 5);
AtomDef_setAtomData(48, "Cd", "카드뮴", "Cadmium", 255, 217, 143, 155, 0, 12, 5);
AtomDef_setAtomData(49, "In", "인듐", "Indium", 166, 117, 115, 155, 0, 13, 5);
AtomDef_setAtomData(50, "Sn", "주석", "Tin", 102, 128, 128, 145, 0, 14, 5);
AtomDef_setAtomData(51, "Sb", "안티모니", "Antimony", 158, 99, 181, 145, 0, 15, 5);
AtomDef_setAtomData(52, "Te", "텔루륨", "Tellurium", 212, 122, 0, 140, 0, 16, 5);
AtomDef_setAtomData(53, "I", "아이오딘", "Iodine", 148, 0, 148, 140, 0, 17, 5);
AtomDef_setAtomData(54, "Xe", "제논", "Xenon", 66, 158, 176, 140, 0, 18, 5);
AtomDef_setAtomData(55, "Cs", "세슘", "Caesium", 87, 23, 143, 260, 0, 1, 6);
AtomDef_setAtomData(56, "Ba", "바륨", "Barium", 0, 201, 0, 215, 0, 2, 6);

// Lantan Group - Period/Group Modified for Table.
AtomDef_setAtomData(57, "La", "란타넘", "Lanthanum", 112, 212, 255, 195, 0, 3, 8);
AtomDef_setAtomData(58, "Ce", "세륨", "Cerium", 255, 255, 199, 185, 0, 4, 8);
AtomDef_setAtomData(59, "Pr", "프라세오디뮴", "Praseodymium", 217, 255, 199, 185, 0, 5, 8);
AtomDef_setAtomData(60, "Nd", "네오디뮴", "Neodymium", 199, 255, 199, 185, 0, 6, 8);
AtomDef_setAtomData(61, "Pm", "프로메튬", "Promethium", 163, 255, 199, 185, 0, 7, 8);
AtomDef_setAtomData(62, "Sm", "사마륨", "Samarium", 143, 255, 199, 185, 0, 8, 8);
AtomDef_setAtomData(63, "Eu", "유로퓸", "Europium", 97, 255, 199, 185, 0, 9, 8);
AtomDef_setAtomData(64, "Gd", "가돌리늄", "Gadolinium", 69, 255, 199, 180, 0, 10, 8);
AtomDef_setAtomData(65, "Tb", "터븀", "Terbium", 48, 255, 199, 175, 0, 11, 8);
AtomDef_setAtomData(66, "Dy", "디스프로슘", "Dysprosium", 31, 255, 199, 175, 0, 12, 8);
AtomDef_setAtomData(67, "Ho", "홀뮴", "Holmium", 0, 255, 156, 175, 0, 13, 8);
AtomDef_setAtomData(68, "Er", "어븀", "Erbium", 0, 230, 117, 175, 0, 14, 8);
AtomDef_setAtomData(69, "Tm", "툴륨", "Thulium", 0, 212, 82, 175, 0, 15, 8);
AtomDef_setAtomData(70, "Yb", "이터븀", "Ytterbium", 0, 191, 56, 175, 0, 16, 8);
AtomDef_setAtomData(71, "Lu", "루테튬", "Lutetium", 0, 171, 36, 175, 0, 17, 8);
// end of Lantan Group

AtomDef_setAtomData(72, "Hf", "하프늄", "Hafnium", 77, 194, 255, 155, 0, 4, 6);
AtomDef_setAtomData(73, "Ta", "탄탈럼", "Tantalum", 77, 166, 255, 145, 0, 5, 6);
AtomDef_setAtomData(74, "W", "텅스텐", "Tungsten", 33, 148, 214, 135, 0, 6, 6);
AtomDef_setAtomData(75, "Re", "레늄", "Rhenium", 38, 125, 171, 135, 0, 7, 6);
AtomDef_setAtomData(76, "Os", "오스뮴", "Osmium", 38, 102, 150, 130, 0, 8, 6);
AtomDef_setAtomData(77, "Ir", "이리듐", "Iridium", 23, 84, 135, 135, 0, 9, 6);
AtomDef_setAtomData(78, "Pt", "백금", "Platinum", 208, 208, 224, 135, 0, 10, 6);
AtomDef_setAtomData(79, "Au", "금", "Gold", 255, 209, 35, 135, 0, 11, 6);
AtomDef_setAtomData(80, "Hg", "수은", "Mercury", 184, 184, 208, 150, 0, 12, 6);
AtomDef_setAtomData(81, "Tl", "탈륨", "Thallium", 166, 84, 77, 190, 0, 13, 6);
AtomDef_setAtomData(82, "Pb", "납", "Lead", 87, 89, 97, 180, 0, 14, 6);
AtomDef_setAtomData(83, "Bi", "비스무트", "Bismuth", 158, 79, 181, 160, 0, 15, 6);
AtomDef_setAtomData(84, "Po", "폴로늄", "Polonium", 171, 92, 0, 190, 0, 16, 6);
AtomDef_setAtomData(85, "At", "아스타틴", "Astatine", 117, 79, 69, 190, 0, 17, 6);
AtomDef_setAtomData(86, "Rn", "라돈", "Radon", 66, 130, 150, 190, 0, 18, 6);
AtomDef_setAtomData(87, "Fr", "프랑슘", "Francium", 66, 0, 102, 190, 0, 1, 7);
AtomDef_setAtomData(88, "Ra", "라듐", "Radium", 0, 125, 0, 215, 0, 2, 7);

// Actin Group - Period/Group Modified for Table.
AtomDef_setAtomData(89, "Ac", "악티늄", "Actinium", 112, 171, 250, 195, 0, 3, 9);
AtomDef_setAtomData(90, "Th", "토륨", "Thorium", 0, 186, 255, 180, 0, 4, 9);
AtomDef_setAtomData(91, "Pa", "프로트악티늄", "Protactinium", 0, 161, 255, 180, 0, 5, 9);
AtomDef_setAtomData(92, "U", "우라늄", "Uranium", 0, 143, 255, 175, 0, 6, 9);
AtomDef_setAtomData(93, "Np", "넵투늄", "Neptunium", 0, 128, 255, 175, 0, 7, 9);
AtomDef_setAtomData(94, "Pu", "플루토늄", "Plutonium", 0, 107, 255, 175, 0, 8, 9);
AtomDef_setAtomData(95, "Am", "아메리슘", "Americium", 84, 92, 242, 175, 0, 9, 9);
AtomDef_setAtomData(96, "Cm", "퀴륨", "Curium", 120, 92, 227, 175, 0, 10, 9);
AtomDef_setAtomData(97, "Bk", "버클륨", "Berkelium", 138, 79, 227, 175, 0, 11, 9);
AtomDef_setAtomData(98, "Cf", "캘리포늄", "Californium", 161, 54, 212, 175, 0, 12, 9);
AtomDef_setAtomData(99, "Es", "아인슈타이늄", "Einsteinium", 179, 31, 212, 175, 0, 13, 9);
AtomDef_setAtomData(100, "Fm", "페르뮴", "Fermium", 179, 31, 186, 175, 0, 14, 9);
AtomDef_setAtomData(101, "Md", "멘델레븀", "Mendelevium", 179, 13, 166, 175, 0, 15, 9);
AtomDef_setAtomData(102, "No", "노벨륨", "Nobelium", 189, 13, 135, 175, 0, 16, 9);
AtomDef_setAtomData(103, "Lr", "로렌슘", "Lawrencium", 199, 0, 102, 175, 0, 17, 9);
// end of Actin Group

AtomDef_setAtomData(104, "Rf", "러더포듐", "Rutherfordium", 204, 0, 89, 175, 0, 4, 7);
AtomDef_setAtomData(105, "Db", "더브늄", "Dubnium", 209, 0, 79, 175, 0, 5, 7);
AtomDef_setAtomData(106, "Sg", "시보귬", "Seaborgium", 217, 0, 69, 175, 0, 6, 7);
AtomDef_setAtomData(107, "Bh", "보륨", "Bohrium", 224, 0, 56, 175, 0, 7, 7);
AtomDef_setAtomData(108, "Hs", "하슘", "Hassium", 230, 0, 46, 175, 0, 8, 7);
AtomDef_setAtomData(109, "Mt", "마이트너륨", "Meitnerium", 235, 0, 38, 175, 0, 9, 7);
AtomDef_setAtomData(110, "Ds", "다름슈타튬", "Darmstadtium", 128, 128, 128, 175, 0, 10, 7);
AtomDef_setAtomData(111, "Rg", "뢴트게늄", "Roentgenium", 128, 128, 128, 175, 0, 11, 7);
AtomDef_setAtomData(112, "Cn", "코페르니슘", "Copernicium", 128, 128, 128, 175, 0, 12, 7);
AtomDef_setAtomData(113, "Nh", "니호늄", "Nihonium", 128, 128, 128, 175, 0, 13, 7);
AtomDef_setAtomData(114, "Fl", "플레로븀", "Flerovium", 128, 128, 128, 175, 0, 14, 7);
AtomDef_setAtomData(115, "Mc", "모스코븀", "Moscovium", 128, 128, 128, 175, 0, 15, 7);
AtomDef_setAtomData(116, "Lv", "리버모륨", "Livermorium", 128, 128, 128, 175, 0, 16, 7);
AtomDef_setAtomData(117, "Ts", "테네신", "Tennessine", 128, 128, 128, 175, 0, 17, 7);
AtomDef_setAtomData(118, "Og", "오가네손", "Oganesson", 128, 128, 128, 175, 0, 18, 7);
AtomDef_setAtomData(199, "?", "미정", "?", 28, 28, 28, 100, 0, 0, 0);
AtomDef_setAtomData(200, "@", "@Anchor", "Anchor", 256, 0, 0, 10, 0, 0, 0);
AtomDef_setAtomData(201, "#", "#Upvector", "Upvector", 0, 0, 255, 10, 0, 0, 0);
AtomDef_setAtomData(211, "+1", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(212, "+2", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(213, "+3", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(214, "+4", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(215, "+5", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(216, "+6", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(217, "+7", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(218, "+8", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(219, "+9", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(221, "-1", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(222, "-2", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(223, "-3", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(224, "-4", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(225, "-5", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(226, "-6", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(227, "-7", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(228, "-8", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);
AtomDef_setAtomData(229, "-9", "+1", "+1", 255, 255, 255, 10, 7, 0, 0);

// 0 : 비금속
// 1 : 알카리 금속
// 2 : 알카리 포금속
// 3 : 전이 금속
// 4 : 전이 후 금속
// 5 : 준금속
// 6 : 비활성 기체

AtomDef_setAtomMetal("He", 6);
AtomDef_setAtomMetal("Ne", 6);
AtomDef_setAtomMetal("Ar", 6);
AtomDef_setAtomMetal("Kr", 6);
AtomDef_setAtomMetal("Xe", 6);
AtomDef_setAtomMetal("Rn", 6);
AtomDef_setAtomMetal("B", 5);
AtomDef_setAtomMetal("Si", 5);
AtomDef_setAtomMetal("Ge", 5);
AtomDef_setAtomMetal("As", 5);
AtomDef_setAtomMetal("Sb", 5);
AtomDef_setAtomMetal("Te", 5);
AtomDef_setAtomMetal("At", 5);
AtomDef_setAtomMetal("Li", 1);
AtomDef_setAtomMetal("Na", 1);
AtomDef_setAtomMetal("K", 1);
AtomDef_setAtomMetal("Rb", 1);
AtomDef_setAtomMetal("Cs", 1);
AtomDef_setAtomMetal("Fr", 1);
AtomDef_setAtomMetal("Uue", 1);
AtomDef_setAtomMetal("Be", 2);
AtomDef_setAtomMetal("Mg", 2);
AtomDef_setAtomMetal("Ca", 2);
AtomDef_setAtomMetal("Sr", 2);
AtomDef_setAtomMetal("Ba", 2);
AtomDef_setAtomMetal("Ra", 2);
AtomDef_setAtomMetal("Sc", 3);
AtomDef_setAtomMetal("Ti", 3);
AtomDef_setAtomMetal("V", 3);
AtomDef_setAtomMetal("Cr", 3);
AtomDef_setAtomMetal("Mn", 3);
AtomDef_setAtomMetal("Fe", 3);
AtomDef_setAtomMetal("Co", 3);
AtomDef_setAtomMetal("Ni", 3);
AtomDef_setAtomMetal("Cu", 3);
AtomDef_setAtomMetal("Zn", 3);
AtomDef_setAtomMetal("Y", 3);
AtomDef_setAtomMetal("Zr", 3);
AtomDef_setAtomMetal("Nb", 3);
AtomDef_setAtomMetal("Mo", 3);
AtomDef_setAtomMetal("Tc", 3);
AtomDef_setAtomMetal("Ru", 3);
AtomDef_setAtomMetal("Rh", 3);
AtomDef_setAtomMetal("Pd", 3);
AtomDef_setAtomMetal("Ag", 3);
AtomDef_setAtomMetal("Cd", 3);
AtomDef_setAtomMetal("Rf", 3);
AtomDef_setAtomMetal("Db", 3);
AtomDef_setAtomMetal("Sg", 3);
AtomDef_setAtomMetal("Bh", 3);
AtomDef_setAtomMetal("Hs", 3);
AtomDef_setAtomMetal("Cn", 3);
AtomDef_setAtomMetal("Hf", 3);
AtomDef_setAtomMetal("Ta", 3);
AtomDef_setAtomMetal("W", 3);
AtomDef_setAtomMetal("Re", 3);
AtomDef_setAtomMetal("Os", 3);
AtomDef_setAtomMetal("Ir", 3);
AtomDef_setAtomMetal("Pt", 3);
AtomDef_setAtomMetal("Au", 3);
AtomDef_setAtomMetal("Hg", 3);
AtomDef_setAtomMetal("Al", 4);
AtomDef_setAtomMetal("Ga", 4);
AtomDef_setAtomMetal("In", 4);
AtomDef_setAtomMetal("Sn", 4);
AtomDef_setAtomMetal("Tl", 4);
AtomDef_setAtomMetal("Pb", 4);
AtomDef_setAtomMetal("Bi", 4);
AtomDef_setAtomMetal("Po", 4);
AtomDef_setAtomVSEPR("C", 4, 0, 109.5);
AtomDef_setAtomVSEPR("Ge", 4, 0, 109.5);
AtomDef_setAtomVSEPR("N", 4, 1, 109.5);
AtomDef_setAtomVSEPR("P", 4, 1, 109.5);
AtomDef_setAtomVSEPR("O", 4, 2, 109.5);
AtomDef_setAtomVSEPR("S", 4, 2, 109.5);
AtomDef_setAtomVSEPR("Se", 4, 2, 109.5);
AtomDef_setAtomVSEPR("Te", 4, 2, 109.5);
AtomDef_setAtomVSEPR("Po", 4, 2, 109.5);
AtomDef_setAtomVSEPR("B", 3, 0, 120);
AtomDef_setAtomVSEPR("Al", 3, 0, 120);
AtomDef_setAtomVSEPR("Ga", 3, 0, 120);
AtomDef_setAtomVSEPR("As", 1, 0, 0);
AtomDef_setAtomVSEPR("F", 1, 0, 0);
AtomDef_setAtomVSEPR("Cl", 1, 0, 0);
AtomDef_setAtomVSEPR("Br", 1, 0, 0);
AtomDef_setAtomVSEPR("I", 1, 0, 0);
AtomDef_setAtomVSEPR("At", 1, 0, 0);
AtomDef_setAtomVSEPR("Li", 1, 0, 0);
AtomDef_setAtomVSEPR("Na", 1, 0, 0);
AtomDef_setAtomVSEPR("K", 1, 0, 0);
AtomDef_setAtomVSEPR("Rb", 1, 0, 0);
AtomDef_setAtomVSEPR("Cs", 1, 0, 0);
AtomDef_setAtomVSEPR("Fr", 1, 0, 0);
AtomDef_setAtomVSEPR("Be", 2, 0, 180);
AtomDef_setAtomVSEPR("Mg", 2, 0, 180);
AtomDef_setAtomVSEPR("Ca", 2, 0, 180);
AtomDef_setAtomVSEPR("Sr", 2, 0, 180);
AtomDef_setAtomVSEPR("Ba", 2, 0, 180);
AtomDef_setAtomVSEPR("Ra", 2, 0, 180);
;// CONCATENATED MODULE: ./Renderer/Util.js



/**
 * 랜덤 숫자를 생성한다.
 * @param {Number} seed 랜덤 시드
 */
function seedRandom(seed) {
  let value = seed;
  return function () {
    value = value * 16807 % 2147483647;
    return value;
  };
}
var _cylinder;

/**
 * Renderer 유틸리티 클래스
 * */
class Util {
  /*
   * Axis Geom 객체를 생성한다.
   * @returns {Object} Axis Geom 객체
   * */
  static generateAxisGeom() {
    var geom = new BufferGeometry();
    var mat = new Matrix4();
    var bx = new CylinderGeometry(1, 1, 1, 8).lookAt(new three_module_Vector3(10, 0, 0));
    var cx = new ConeGeometry(5, 20, 32).lookAt(new three_module_Vector3(10, 0, 0)).translate(1, 0, 0);
    var by = new CylinderGeometry(1, 1, 1, 8).lookAt(new three_module_Vector3(0, 10, 0));
    var cy = new ConeGeometry(5, 20, 32).lookAt(new three_module_Vector3(0, 10, 0)).translate(0, 1, 0);
    var bz = new CylinderGeometry(1, 1, 1, 8).lookAt(new three_module_Vector3(0, 0, 10));
    var cz = new ConeGeometry(5, 20, 32).lookAt(new three_module_Vector3(0, 0, 10)).translate(0, 0, 1);
    geom.merge(bx, mat);
    geom.merge(cx, mat);
    geom.merge(by, mat);
    geom.merge(cy, mat);
    geom.merge(bz, mat);
    geom.merge(cz, mat);
    geom.computeVertexNormals();
    return geom;
  }

  /**
   * 여러개의 geometry를 병합한다.
   * @param {Array} geometry_list 합칠 geometry 리스트
   * @returns {THREE.Geometry} 병합된 geometry
   */
  static mergeGeometries(geometry_list) {
    var geom = new BufferGeometry();
    var mat = new Matrix4();
    for (let i = 0; i < geometry_list.length; i++) {
      if (!geometry_list[i]) continue;
      geom.merge(geometry_list[i], mat);
    }
    return geom;
  }

  /**
   * 3D 점선 객체를 생성한다.
   * @param {THREE.Vector3} p1 시작점 좌표
   * @param {THREE.Vector3} p2 끝점 좌표
   * @returns {THREE.Geometry} 생성된 geometry
   */
  static generateDottedLineGeom(p1, p2) {
    if (!_cylinder) {
      _cylinder = new CylinderGeometry(0.2, 0.2, 0.3, 4).lookAt(new three_module_Vector3(0, 10, 0));
    }
    var v1 = p2.clone();
    v1.sub(p1);
    const vlen = v1.length();
    const dt = 1 / vlen * 0.5;
    var step = dt;
    var st = 0;
    var ed = 1;
    var up = new three_module_Vector3(0, 1, 0);

    //var mergedGeo = new THREE.BufferGeometry();
    var listGeom = [];
    var matTr = new Matrix4();
    var matSc = new Matrix4();
    var matLk = new Matrix4();
    var pos = new three_module_Vector3();
    for (var i = st; i <= ed; i += step) {
      pos.set(p1.x, p1.y, p1.z);
      pos.lerp(p2, i);
      matTr.makeTranslation(pos.x, pos.y, pos.z);
      matSc.makeScale(0.2, 0.2, 0.6);
      matLk.lookAt(pos, p2, up);
      matTr.multiply(matLk);
      matTr.multiply(matSc);

      //mergedGeo.merge(_cylinder, matTr);
      var dgeom = _cylinder.clone().applyMatrix4(matTr);
      listGeom.push(dgeom);
    }
    var mergedGeo = BufferGeometryUtils.mergeBufferGeometries(listGeom);
    return mergedGeo;
  }

  /**
   * 하나의 Geom 데이터를 딕셔너리에 등록한다.
   * @param {Object} dic 딕셔너리
   * @param {Geom} geom geom 데이터
   */
  static markOneGeomDic(dic, geom) {
    let id = geom.GetID();
    dic[id] = geom;
    let type = geom.GetType();
    if (type == 6)
      // group
      {
        let len = geom.GetNumberOfChildren();
        let i;
        for (i = 0; i < len; i++) {
          let child = geom.Get(i);
          Util.markOneGeomDic(dic, child);
        }
      }
  }

  /**
   * Geom 데이터를 딕셔너리에 등록한다.
   * @param {Object} dic 딕셔너리
   * @param {Geom} geom geom 데이터
   */
  static makeGeomDic(dic, geom) {
    Util.markOneGeomDic(dic, geom);
  }

  /**
   * 세 점이 만드는 평면의 노말 벡터를 계산한다.
   * @param {THREE.Vector3} p1 점 1 좌표
   * @param {THREE.Vector3} p2 점 2 좌표
   * @param {THREE.Vector3} p3 점 3 좌표
   */
  static calcNormal(p1, p2, p3) {
    let v1 = p2.clone();
    v1.sub(p1);
    let v2 = p3.clone();
    v2.sub(p2);
    let v3 = v2.cross(v1);
    return v3;
  }

  /**
   * 배열의 구성 요소 순서를 뒤집는다.
   * @param {Array} array 배열
   * @returns {Array} 변환된 배열
   */
  static flipArray(array) {
    const len = array.length;
    let array2 = [];
    for (let i = len - 1; i >= 0; i--) {
      array2.push(array[i]);
    }
    return array2;
  }
}
;// CONCATENATED MODULE: ./Renderer/GeomRenderer.js










/**
 * Geom Renderer 클래스
 * */
class GeomRenderer {
  /**
   * GeomRenderer 생성자
   * @param {any} api 다른 외부 라이브러리와 연동하기 위한 api 객체
   * @param {any} renderer 렌더러
   * @param {any} point_tex_fn 
   */
  constructor(api, renderer) {
    this._baseID = 0;
    this._group = new Group();
    this._renderer = renderer;
    renderer._scene.add(this._group);
    this._api = api;
    this._atomMaterial = [];
    this._sphere = new SphereGeometry(1, 32, 32);
    this._cylinder = new CylinderGeometry(1, 1, 1, 32).lookAt(new three_module_Vector3(0, 10, 0));
    this._cylinder.deleteAttribute("uv");
    this._materials = [];
    this._current_material = null;
    this._dic = {};
    this._maxid = 0;

    /*
            this._pointVShader = "attribute float size;"+
                "attribute vec3 customColor;"+
                "varying vec3 vColor;"+
                "void main() {"+
                "   vColor = customColor;"+
                "   vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);"+
                "   gl_PointSize = 1.0 ;"+
                "   gl_Position = projectionMatrix * mvPosition;"+
                "}";
    
            this._pointPShader = "uniform vec3 color;" +
                "uniform sampler2D pointTexture;"+
                "varying vec3 vColor;" +
                "void main() {" +
                "gl_FragColor = vec4(color * vColor, 1.0);" +
                "gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);" +
                "}";
                */
    this._genFunctions = [];
    this.initGenFunctions();
    this._trajectoryType = 0;
  }

  /**
   * Base ID를 설정한다.
   * @param {any} base_id
   */
  SetBaseID(base_id) {
    this._baseID = base_id;
    this._api.KRFTextParser.SetBaseID4Load(this._baseID);
  }

  /**
   * 프로그래스바와 함께 문자열로부터 geom 데이터를 로드한다
   * @param {String} data krf text 데이터
   */
  LoadFromStringProgressPrepare(data) {
    var parser = new this._api.KRFTextParser();
    var mb = new this._api.MemoryBlock();
    mb.CreateWithString(data);
    parser.Load(mb);
    //        var cl2 = new this._api.CommandList();
    this._loadingList = parser.GetCommandList();
    this._loadingIdx = 0;
    const num = this._loadingList.GetNumberOfCommands();
    const max_step = Math.ceil(num / 30);
    return max_step;
  }

  /**
   * 일정 수준 이상 로드되면 finished로 처리한다
   * */
  LoadFromStringProgressLoading() {
    const num = this._loadingList.GetNumberOfCommands();
    var finished = false;
    var endidx = this._loadingIdx + 30;
    if (endidx >= num) {
      finished = true;
      endidx = num;
    }
    for (; this._loadingIdx < endidx; this._loadingIdx++) {
      var cmd1 = this._loadingList.GetCommand(this._loadingIdx);
      this.generateOne(cmd1, this._group);
    }
    return finished;
  }

  /**
   * krf text 데이터로부터 geom을 생성한다
   * @param {any} data krf text data
   */
  LoadFromString(data) {
    var parser = new this._api.KRFTextParser();
    var mb = new this._api.MemoryBlock();
    mb.CreateWithString(data);
    parser.Load(mb);
    //        var cl2 = new this._api.CommandList();
    var cl2 = parser.GetCommandList();
    rayLog(3, " cl2 LoadFromString = " + cl2.GetNumberOfCommands());
    const num = cl2.GetNumberOfCommands();
    let geom_list = [];
    for (var i = 0; i < num; i++) {
      var cmd1 = cl2.GetCommand(i);
      geom_list.push(cmd1);
    }
    this.generateGeomDictionary(geom_list);
    for (var i = 0; i < num; i++) {
      rayLog(3, " gen id = " + i);
      var cmd1 = cl2.GetCommand(i);
      this.generateOne(cmd1, this._group);
    }
  }

  /**
   * 데이터 로드 진행율 값을 반환한다.
   * @returns {Number} progress 진행율 값
   * */
  getProgressLoadFromString() {
    return this._progress;
  }

  /**
   * 비동기로 krf text 데이터를 로드한다
   * @param {String} data krf text 데이터
   */
  async LoadFromStringAsync(data) {
    this._progress = 0;
    var parser = new this._api.KRFTextParser();
    var mb = new this._api.MemoryBlock();
    mb.CreateWithString(data);
    await parser.Load(mb);
    this._progress = 0.2;

    //        var cl2 = new this._api.CommandList();
    var cl2 = parser.GetCommandList();
    rayLog(3, " cl2 LoadFromString = " + cl2.GetNumberOfCommands());
    const num = cl2.GetNumberOfCommands();
    for (var i = 0; i < num; i++) {
      rayLog(3, " gen id = " + i);
      var cmd1 = cl2.GetCommand(i);
      await this.generateOneAsync(cmd1, this._group);
      this._progress = 0.2 + i / num * 0.8;
    }
    this._progress = 1;
  }

  /**
   * 아이디에 해당하는 geom을 반환한다
   * @param {Number} id geom id
   * @returns geom
   */
  get(id) {
    return this._dic[id];
  }

  /**
   * max id를 설정한다
   * @param {Number} id
   */
  setMaxID(id) {
    if (this._maxid < id) this._maxid = id;
  }
  test1() {
    const fileUrl = '../_testdata/test.krf'; // provide file location

    fetch(fileUrl).then(r => r.text()).then(t => {
      this.LoadFromString(t);
      //this.deleteOne(2);

      var gg = new this._api.Sphere();
      gg.Set(20, 0, 20, 4);
      gg.SetID(6);
      //this.updateGeom(gg);

      this.addNewGeom(gg, 4);
      this.setColor(4, 1, 1, 1);
      //this.deleteOne(2);
    });

    /*
    var cmd =
        "LineSeg,0,0,0,1,0,0\n" +
        "LineSeg,1,0,0,1,0,1\n" + 
        "Sphere,2,0,2,0.2\n" +
        "Sphere,3,3,3,0.2\n" +
        "Cylinder,2,0,2,3,3,3,0.1\n" 
        ;
      var cl2 = new this._api.CommandList();
    cl2.LoadFromString(cmd);
    console.log(" cl2 LoadFromString = " + cl2.GetNumberOfCommands());
      const num = cl2.GetNumberOfCommands();
      for (var i = 0; i < num; i++) {
        var cmd1 = cl2.GetCommand(i);
        this.generateOne(cmd1);
    }
    */
  }

  /**
   * id에 해당하는 메쉬를 갱신한다
   * @param {any} mesh 메쉬
   * @param {any} id 아이디
   * @param {any} geom geom
   * @param {any} parent geom의 parent
   */
  updateMeshWithID(mesh, id, geom, parent) {
    mesh._id = id;
    mesh._geom = geom;
    mesh._parent = parent;
    if (id != 0) {
      this._dic[id] = mesh;
    }
    if (parent) parent.add(mesh);
  }

  // 3.mesh에 geom의 데이터를 넣기
  // mesh._id : geom의 ID. 렌더링 파일의 id
  // mesh._geom : geom의 pointer
  // mesh._parent : 3.js의 mesh parent임. 
  // geomGenerator._dic에는 id로 분류되어 mesh 포인터가 들어감.

  /**
   * 메쉬를 업데이트한다
   * @param {any} mesh _id : geom의 id. 렌더링 파일의 id / _geom : geom의 pointer / _parent : 3.js의 mesh parent / geomGenerator._dic에는 id로 분류되어 mesh 포인터가 들어간다
   * @param {any} geom geom
   * @param {any} parent geom의 parent
   */
  updateMesh(mesh, geom, parent) {
    mesh._id = geom.GetID();
    mesh._geom = geom;
    mesh._parent = parent;
    geom._id = geom.GetID();
    geom._mesh = mesh;
    if (mesh._id != 0) {
      this._dic[mesh._id] = mesh;
    }
    if (parent) parent.add(mesh);
  }

  /**
   * mesh 색상을 설정한다
   * @param {any} mesh
   * @param {Number} r 컬러의 red component [0,1]
   * @param {Number} g 컬러의 green component [0,1]
   * @param {Number} b 컬러의 blue component [0,1]
   */
  static _setColor(mesh, r, g, b) {
    if (!mesh) return;
    if (mesh._mat) mesh._mat.color.setRGB(r, g, b);
    var geom = mesh._geom;
    if (!geom) return;
    if (geom.GetType() == 6) {
      // group

      for (let i = 0; i < mesh.children.length; i++) {
        var child = mesh.children[i];
        GeomRenderer._setColor(child, r, g, b);
      }
    }
  }

  /**
   * mesh의 original color를 설정한다
   * @param {any} mesh 
   * @param {Number} r 컬러의 red component [0,1]
   * @param {Number} g 컬러의 green component [0,1]
   * @param {Number} b 컬러의 blue component [0,1]
   */
  static setOriginalColorWithMesh(mesh, r, g, b) {
    if (!mesh) return;
    mesh._originalColorR = r;
    mesh._originalColorG = g;
    mesh._originalColorB = b;
    GeomRenderer._setColor(mesh, r, g, b);
  }

  /**
   * id에 해당하는 메쉬의 original color를 설정한다
   * @param {Number} id mesh id
   * @param {Number} r 컬러의 red component [0,1]
   * @param {Number} g 컬러의 green component [0,1]
   * @param {Number} b 컬러의 blue component [0,1]
   */
  setOriginalColor(id, r, g, b) {
    var mesh = this._dic[id];
    if (!mesh) return;
    mesh._originalColorR = r;
    mesh._originalColorG = g;
    mesh._originalColorB = b;
    GeomRenderer._setColor(mesh, r, g, b);
  }

  /**
   * 원래의 색상으로 복원한다
   * @param {Number} id mesh의 id
   */
  restoreOriginalColor(id) {
    var mesh = this._dic[id];
    if (!mesh) return;
    GeomRenderer._setColor(mesh, mesh._originalColorR, mesh._originalColorG, mesh._originalColorB);
  }

  /**
   * 메쉬의 색상을 원래대로 복원한다.
   * @param {THREE.Mesh} mesh 메쉬
   */
  static restoreOriginalColorMesh(mesh) {
    GeomRenderer._setColor(mesh, mesh._originalColorR, mesh._originalColorG, mesh._originalColorB);
  }

  /**
   * 메쉬의 색상을 설정한다
   * @param {Number} id mesh의 id
   * @param {Number} r 컬러의 red component [0,1]
   * @param {Number} g 컬러의 green component [0,1]
   * @param {Number} b 컬러의 blue component [0,1]
   */
  setColor(id, r, g, b) {
    var mesh = this._dic[id];
    if (!mesh) return;
    GeomRenderer._setColor(mesh, r, g, b);
  }

  /**
   * preview를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genPreview(gr, geom, parent) {
    var group = new gr._api.Group();
    geom.GeneratePreview(group);
    group.SetID(geom.GetID());
    var ret = gr.generateOne(group, parent);
    return ret;
  }

  /**
   * lineseg를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genLineSeg(gr, geom, parent) {
    const points = [];
    const p1 = geom.Get(0);
    const p2 = geom.Get(1);
    points.push(new three_module_Vector3(p1[0], p1[1], p1[2]));
    points.push(new three_module_Vector3(p2[0], p2[1], p2[2]));
    const geometry = new BufferGeometry().setFromPoints(points);
    var mat = null;
    var material = new MeshBasicMaterial({
      color: 0xff0000
    });
    const mesh = new Line(geometry, material);
    mesh._mat = material;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * group을 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genGroup(gr, geom, parent) {
    var mesh = new Group();
    gr.updateMesh(mesh, geom, parent);
    const num = geom.GetNumberOfChildren();
    for (var i = 0; i < num; i++) {
      var child = geom.Get(i);
      var cmesh = gr.__generateOne(child, mesh);
    }
    return mesh;
  }

  // 라인리스트 임. 
  /**
   * polyline을 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genPLine(gr, geom, parent) {
    //const p1x = geom.GetData(0);

    const points = [];
    //const p1 = geom.GetPoint(0);
    //const p2 = geom.GetPoint(1);

    const num = geom.GetNumberOfPoints();
    for (var i = 0; i < num; i++) {
      const pp = geom.GetPoint(i);
      const tp = new three_module_Vector3(pp[0], pp[1], pp[2]);
      points.push(tp);
    }
    const geometry = new BufferGeometry().setFromPoints(points);
    var material = new MeshBasicMaterial({
      color: 0xff0000
    });
    const mesh = new Line(geometry, material);
    mesh._mat = material;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * sphere geometry 를 생성한다
   * @param {array} vlist vertex list : number의 list
   * @param {number} vidx vertex index : vlist에서 vertex가 시작하는 위치
   * @param {array} nlist normal list
   * @param {number} nidx normal index : nlist에서 normal이 시작하는 위치
   * @param {array} ilist index list
   * @param {number} iidx index index 에서 시작하는 위치
   * @param {array} vclist vertex color의 list
   * @param {Vector3} center center of the sphere
   * @param {number} radius radius of the sphere
   * @param {array} color the sphere 의 컬러
   * @param {number} lat_furfaces sphere 생성 시 위도 당 polygon 수
   * @param {number} lon_furfaces sphere 생성 시 경도 당 polygon 수
   * 
   */
  static genGeomSphere(vlist, vidx, nlist, nidx, ilist, iidx, vclist, center, radius, color, lat_furfaces, lon_furfaces) {
    let start_vidx = vidx;
    const thetaLength = Math.PI * 2;
    const thetaStart = 0;
    const thetaEnd = thetaLength - thetaStart;
    const phiStart = 0;
    const phiLength = Math.PI * 2;
    const widthSegments = lat_furfaces;
    const heightSegements = lon_furfaces;
    let index = (vidx + 1) / 3;
    const grid = [];
    const vertex = new three_module_Vector3();
    const normal = new three_module_Vector3();
    for (let iy = 0; iy <= heightSegements; ++iy) {
      const verticesRow = [];
      const v = iy / heightSegements;

      // special case for the poles

      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegements && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ++ix) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vlist[vidx++] = vertex.x + center.x;
        vlist[vidx++] = vertex.y + center.y;
        vlist[vidx++] = vertex.z + center.z;
        normal.copy(vertex).normalize();
        nlist[nidx++] = normal.x;
        nlist[nidx++] = normal.y;
        nlist[nidx++] = normal.z;
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegements; ++iy) {
      for (let ix = 0; ix < widthSegments; ++ix) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];

        // 상단 pole인 경우 생략
        if (iy !== 0 || thetaStart > 0) {
          ilist[iidx++] = a;
          ilist[iidx++] = b;
          ilist[iidx++] = d;
        }

        // 하단 pole인 경우 생략
        if (iy !== heightSegements - 1 || thetaEnd < Math.PI) {
          ilist[iidx++] = b;
          ilist[iidx++] = c;
          ilist[iidx++] = d;
        }
      }
    }
    return [vidx, nidx, iidx];
  }

  /**
   * sphere geometry 를 생성 할 때 필요한 index(number*3), vertex(number*3) 수를 구한다. 
   * @param {number} lat_furfaces sphere 생성 시 위도 당 polygon 수
   * @param {number} lon_furfaces sphere 생성 시 경도 당 polygon 수
   */
  static getSizeGeomSphere(lat_furfaces, lon_furfaces) {
    let numOfVertex = (lat_furfaces + 1) * (lon_furfaces + 1) * 3;
    let numOfIndex = lat_furfaces * lon_furfaces * 6 - 3 * lon_furfaces - 3 * lat_furfaces;
    return [numOfIndex, numOfVertex];
  }

  /**
   * cylinder geometry 를 생성한다
   * @param {array} vlist vertex list : number의 list
   * @param {number} vidx vertex index : vlist에서 vertex가 시작하는 위치
   * @param {array} nlist normal list
   * @param {number} nidx normal index : nlist에서 normal이 시작하는 위치
   * @param {array} ilist index list
   * @param {number} iidx index index 에서 시작하는 위치
   * @param {array} vclist vertex color의 list
   * @param {Vector3} p1 cylinder의 시작점
   * @param {Vector3} p2 cylinder의 끝 점
   * @param {number} radius cylinder의 반지름
   * @param {array} color the sphere 의 컬러
   * @param {number} num_furfaces cylinder 를 생성시 360도 당 polygon의 수
   */
  static genGeomCylinder(vlist, vidx, nlist, nidx, ilist, iidx, vclist, p1, p2, radius, color, num_furfaces) {
    let vertex = new three_module_Vector3();
    let normal = new three_module_Vector3();
    const center_diff = new three_module_Vector3().addVectors(p1, p2).multiplyScalar(1 / 2);
    const height = p1.distanceTo(p2);
    const halfHeight = height / 2;
    const thetaStart = 0;
    const thetaLength = Math.PI * 2;
    const slope = 0;
    const radialSegments = num_furfaces;
    const heightSegments = 1;
    let mat = new Matrix4();
    mat.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    let quaternion = new Quaternion();
    let basis = new three_module_Vector3(0, 1, 0);
    let rotation_diff = new three_module_Vector3();
    rotation_diff.subVectors(p1, p2);
    quaternion.setFromUnitVectors(basis, rotation_diff.normalize());
    let index = (vidx + 1) / 3;
    const indexArray = [];
    for (let y = 0; y <= heightSegments; ++y) {
      const indexRow = [];
      const v = y / heightSegments;
      for (let x = 0; x <= radialSegments; ++x) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        normal.set(sinTheta, slope, cosTheta).applyQuaternion(quaternion).normalize();
        vertex.applyQuaternion(quaternion);
        vertex.add(center_diff);
        vlist[vidx++] = vertex.x;
        vlist[vidx++] = vertex.y;
        vlist[vidx++] = vertex.z;
        nlist[nidx++] = normal.x;
        nlist[nidx++] = normal.y;
        nlist[nidx++] = normal.z;
        indexRow.push(index++);
      }
      indexArray.push(indexRow);
    }
    for (let x = 0; x < radialSegments; ++x) {
      for (let y = 0; y < heightSegments; ++y) {
        const a = indexArray[y][x];
        const b = indexArray[y + 1][x];
        const c = indexArray[y + 1][x + 1];
        const d = indexArray[y][x + 1];
        ilist[iidx++] = a;
        ilist[iidx++] = b;
        ilist[iidx++] = d;
        ilist[iidx++] = b;
        ilist[iidx++] = c;
        ilist[iidx++] = d;
      }
    }
    return [vidx, nidx, iidx];
  }

  /**
   * cylinder geometry 를 생성할 때 필요한 index, vertex 의 수를 계산한다. 
   * @param {number} num_furfaces cylinder 를 생성시 360도 당 polygon의 수
   */
  static getSizeGeomCylinder(num_furfaces) {
    return [num_furfaces * 6, (num_furfaces + 1) * 6];
  }

  /**
   * sphere를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer
   * @param {any} geom 생성 할 geom class pointer
   * @param {any} parent geom의 parent pointer
   */
  genSphere(gr, geom, parent) {
    const center = geom.GetCenter();
    const radius = geom.GetRadius();
    var material = new MeshLambertMaterial({
      color: 0x0000ff
    });
    const mesh = new three_module_Mesh(gr._sphere, material);
    mesh._mat = material;
    mesh.position.fromArray(center, 0);
    mesh.scale.set(radius, radius, radius);
    mesh._originalColorR = 0x0 / 0xff;
    mesh._originalColorG = 0x0 / 0xff;
    mesh._originalColorB = 0xff / 0xff;
    mesh._disposeMaterial = true;
    mesh._disposeGeometry = false;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * mesh를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다. 
   * @param {any} geom 생성 할 Core.Geom class pointer 이다. 
   * @param {any} parent Core.Geom의 parent pointer 이다. 
   */
  genMesh(gr, geom, parent) {
    const geometry = new BufferGeometry();
    const nVtx = geom.GetNumVertex();
    const nTri = geom.GetNumTris();
    for (var i = 0; i < nVtx; i++) {
      const x = geom.GetVertexData(i * 3 + 0);
      const y = geom.GetVertexData(i * 3 + 1);
      const z = geom.GetVertexData(i * 3 + 2);
      geometry.vertices.push(new three_module_Vector3(x, y, z));
    }
    for (var i = 0; i < nTri; i++) {
      const i1 = geom.GetTriIndex(i * 3 + 0);
      const i2 = geom.GetTriIndex(i * 3 + 1);
      const i3 = geom.GetTriIndex(i * 3 + 2);
      geometry.faces.push(new three_module_namespaceObject.Face3(i1, i3, i2));
    }
    geometry.computeFaceNormals();
    geometry.computeBoundingSphere();
    var material = new MeshLambertMaterial({
      color: 0xffffff
    });
    var mesh = new three_module_Mesh(geometry, material);
    mesh._mat = material;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * material을 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genMaterial(gr, geom, parent) {
    var cc = geom.GetColor();
    const color = cc[0] * 256 * 256 + cc[1] * 256 + cc[2];
    const name = geom.GetName();
    var material = new MeshLambertMaterial({
      color: color
    });
    gr._materials[name] = material;
    gr._current_material = material;
    mat._id = geom.GetID();
    return null;
  }

  /**
   * spline을 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genSpline(gr, geom, parent) {
    const len = geom.GetNumberOfPoints();
    const points = [];
    //const p1 = geom.GetPoint(0);
    //const p2 = geom.GetPoint(1);

    const num = geom.GetNumberOfPoints();
    var spt = [];
    var spx = [];
    var spy = [];
    var spz = [];
    for (var i = 0; i < num; i++) {
      const p2 = geom.GetPoint(i);
      spt.push(i);
      spx.push(p2[0]);
      spy.push(p2[1]);
      spz.push(p2[2]);
    }
    var spline_x = new cubic_spline_Spline(spt, spx);
    var spline_y = new cubic_spline_Spline(spt, spy);
    var spline_z = new cubic_spline_Spline(spt, spz);
    for (var j = 0; j <= num - 1; j += 0.002) {
      const x = spline_x.at(j);
      const y = spline_y.at(j);
      const z = spline_z.at(j);
      if (isNaN(x) || isNaN(y) || isNaN(z)) {
        var ttt = 323;
      }
      points.push(new three_module_Vector3(x, y, z));
    }
    const geometry = new BufferGeometry().setFromPoints(points);
    var material = new MeshBasicMaterial({
      color: 0xff0000
    });
    const mesh = new Line(geometry, material);
    mesh._mat = material;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * protein trajectory를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
   */
  genProteinTrajectory(gr, geom, parent) {
    ProteinTrajectory.genProteinTrajectory(gr, geom, parent);
  }

  /**
  * point를 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
  */
  genPoints(gr, geom, parent) {
    const amount = geom.GetNumberOfPoints();
    let vertices = [];
    for (let i = 0; i < amount; i++) {
      var pos = geom.GetPoint(i);
      vertices.push(pos[0], pos[1], pos[2]);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    //
    var material = new PointsMaterial({
      size: 5,
      sizeAttenuation: false,
      color: 0xff00000
    });
    //

    var mesh = new Points(geometry, material);
    mesh._mat = material;
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * Cylinder geometry를 생성한다.
   * @param {any} gr
   * @param {any} pos1
   * @param {any} pos2
   * @param {any} radius
   */
  static createCylinderGeometry(gr, pos1, pos2, radius) {
    var a = pos1;
    var b = pos2;
    var center = new three_module_Vector3(a.x, a.y, a.z).add(b).multiplyScalar(0.5);
    ;
    const len = b.sub(a).length();
    let geometry = gr._cylinder.clone();
    let up = new three_module_Vector3(0, 1, 0);
    let mat1 = new Matrix4();
    mat1.lookAt(center, a, up);
    let mat2 = new Matrix4();
    mat2.makeScale(radius, radius, len);
    let mat3 = new Matrix4();
    mat3.makeTranslation(center.x, center.y, center.z);

    //        mat2.multiply(mat3).multiply(mat1);
    mat3.multiply(mat1).multiply(mat2);
    geometry.applyMatrix4(mat3);
    return geometry;
  }

  /**
   * Cylinder Mesh를 생성한다.
   * @param {any} gr
   * @param {any} pos1
   * @param {any} pos2
   * @param {any} radius
   * @param {any} color
   */
  static createCylinderMesh(gr, pos1, pos2, radius, color) {
    var a = pos1;
    var b = pos2;
    var center = new three_module_Vector3(a.x, a.y, a.z).add(b).multiplyScalar(0.5);
    ;
    const len = b.sub(a).length();
    var mat = new MeshLambertMaterial();
    mat.color.r = color[0];
    mat.color.g = color[1];
    mat.color.b = color[2];
    var mesh = new three_module_Mesh(gr._cylinder, mat);
    mesh.position.x = center.x;
    mesh.position.y = center.y;
    mesh.position.z = center.z;
    mesh.lookAt(a);
    mesh._mat = mat;
    mesh._originalColorR = color[0];
    mesh._originalColorG = color[1];
    mesh._originalColorB = color[2];
    mesh._disposeMaterial = true;
    mesh._disposeGeometry = false;

    //object.scale.set(len, geom.GetRadius(), geom.GetRadius());
    mesh.scale.set(radius, radius, len);
    return mesh;
  }

  /**
  * cylinder을 생성한다
   * @param {GeomRenderer} gr GeomRenderer class pointer 이다. Core.Geom을 사용하여 Three.js Mesh를 생성할 때 사용된다.
   * @param {any} geom 생성 할 Core.Geom class pointer 이다.
   * @param {any} parent Core.Geom의 parent pointer 이다.
  */
  genCylinder(gr, geom, parent) {
    var aa = geom.GetPosition1();
    var bb = geom.GetPosition2();
    var a = new three_module_Vector3(aa[0], aa[1], aa[2]);
    var b = new three_module_Vector3(bb[0], bb[1], bb[2]);
    var mesh = GeomRenderer.createCylinderMesh(gr, a, b, geom.GetRadius(), [0.5, 0.5, 0.5]);
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * Generate 함수들을 초기화한다
   * */
  initGenFunctions() {
    this._genFunctions[1] = this.genLineSeg;
    this._genFunctions[2] = this.genPLine;
    this._genFunctions[4] = this.genPreview;
    this._genFunctions[6] = this.genGroup;
    this._genFunctions[7] = this.genSphere;
    this._genFunctions[8] = this.genCylinder;
    this._genFunctions[9] = this.genMesh;
    this._genFunctions[10] = this.genMaterial;
    this._genFunctions[11] = this.genSpline;
    this._genFunctions[13] = this.genPoints;
    this._genFunctions[14] = this.genProteinTrajectory;
    this._genFunctions[15] = this.genPreview;
    this._genFunctions[17] = GeomMole.genAtom;
    this._genFunctions[18] = GeomMole.genBond;
  }
  /**
   * 인덱스에 해당하는 함수를 설정한다
   * @param {Number} index 인덱스
   * @param {Function} func 함수
   */
  setGenFunction(index, func) {
    this._genFunctions[index] = func;
  }

  /**
   * 타입에 따른 기하 오브젝트를 비동기 생성한다
   * @param {any} geom geom
   * @param {any} parent geom의 parent
   */
  async generateOneAsync(geom, parent) {
    return await this.generateOne(geom, parent);
  }

  /**
   * geom 데이터 딕셔너리를 생성한다.
   * @param {any} geom_list geom 리스트
   */
  generateGeomDictionary(geom_list) {
    this._geomDic = {};
    for (let i in geom_list) {
      let geom = geom_list[i];
      Util.makeGeomDic(this._geomDic, geom);
    }
  }

  /**
   * 타입에 따른 기하 오브젝트를 생성한다
   * @param {any} geom geom
   * @param {any} parent geom의 parent
   */
  generateOne(geom, parent) {
    let mesh = this.__generateOne(geom, parent);
    return mesh;
  }

  /**
   * 타입에 따른 기하 오브젝트를 생성한다
   * @param {any} geom
   * @param {any} parent
   */
  __generateOne(geom, parent) {
    if (!geom) return;
    if (geom.GetID() == -1) {
      this._maxid++;
      geom.SetID(this._maxid);
    } else {
      this.setMaxID(geom.GetID());
    }
    var type = geom.GetType();
    var mesh;
    if (this._genFunctions[type] != null) {
      mesh = this._genFunctions[type](this, geom, parent);
    }
    return mesh;
  }

  /**
   * geom list에 있는 오브젝트들을 생성한다
   * @param {Array} geom_list geom array
  generateWithArray(geom_list) {
        this._dic = {};
        geom_list.foreach(function (geom) {
          this.generateOne(geom, this._group);
      });
  }
   */

  /**
   * geom들을 모두 clear한다
   * */
  clear() {
    const len = this._group.children.length;
    for (var i = len - 1; i >= 0; i--) {
      var obj = this._group.children[i];
      const id = obj._geom.GetID();
      this.deleteOne(id);
    }
    this._maxid = 0;
    this._dic = {};
  }

  /**
   * id에 해당하는 geom을 삭제한다
   * @param {Number} id geom id
   */
  deleteOne(id) {
    var prev = this._dic[id];
    if (prev == null) {
      return;
    }
    var geom = prev._geom;
    if (geom.GetType() == 6)
      // group
      {
        const size = geom.GetNumberOfChildren();
        for (var i = 0; i < size; i++) {
          var gg = geom.Get(i);
          if (gg.GetID() == 0) {
            // id가 0이면 dic에 넣지 않고 생성만 한다. 
            // parent에서 빼준다. 
            //gg._mesh.parent.remove(gg._mesh);
          } else {
            this.deleteOne(gg.GetID());
          }
        }
      }
    this._dic[id] = null;
    prev.parent.remove(prev);
    if (prev._disposeGeometry) {
      prev.geometry.dispose();
    }
    if (prev._disposeMaterial) {
      prev.material.dispose();
    }

    //delete prev;
  }

  // 생성해서 추가 한다는 의미임. 기존에 같은 id가 존재하면 해당 id의 mesh, geom을 삭제하고 추가함. 
  //generateNaddGeom

  /**
   * geom을 업데이트한다
   * @param {any} geom
   */
  updateGeom(geom) {
    var id = geom.GetID();
    var prev = this._dic[id];
    var mesh;
    if (prev) {
      mesh = this.generateOne(geom, prev._parent);
      var parent = prev.parent;
      parent.attach(mesh);
      parent.remove(prev);
      if (mesh._id != 0) this._dic[mesh._id] = mesh;
    } else {
      mesh = this.generateOne(geom, this._group);
      var parent = this._group;
      parent.attach(mesh);
      if (mesh._id != 0) this._dic[mesh._id] = mesh;
    }
    return mesh;
  }

  /**
   * 새로운 geom을 추가한다
   * @param {any} geom geom
   * @param {any} parent_id geom의 parent_id
   */
  addNewGeom(geom, parent_id) {
    var id = geom.GetID();
    var parent;
    if (parent_id) {
      parent = this.get(parent_id);
      if (!parent) parent = this._group;
    } else {
      parent = this._group;
    }
    var pgeom = parent._geom;
    if (pgeom) if (pgeom.GetType() == 6) {
      // group
      pgeom.Add(geom);
    }
    var mesh;
    mesh = this.generateOne(geom, parent);
    parent.attach(mesh);
    if (mesh._id != 0) this._dic[mesh._id] = mesh;
    return mesh;
  }

  /**
   * 새로운 geom을 추가한다
   * @param {any} geom
   */
  addNewGeom2(geom) {
    var id = geom.GetID();
    var mesh;
    mesh = this.generateOne(geom, null);
    if (mesh._id != 0) this._dic[mesh._id] = mesh;
    return mesh;
  }

  /**
   * 단일 메쉬로 분자 메쉬를 생성한다.
   * @param {any} alist
   * @param {any} blist
   */
  generateOneMeshMole(alist, blist) {
    let atom;
    let bond;
    let position1, position2;
    let vlist = [],
      vidx = 0,
      nlist = [],
      nidx = 0,
      ilist = [],
      iidx = 0,
      vclist = [],
      color = new Color(0x000000),
      lat_furfaces = 30,
      lon_furfaces = 30,
      num_furfaces = 30;
    let sphereSize = GeomRenderer.getSizeGeomSphere(lat_furfaces, lon_furfaces);
    let cylinderSize = GeomRenderer.getSizeGeomCylinder(num_furfaces);
    let len1 = sphereSize[1] * alist.length + cylinderSize[1] * blist.length;
    let len2 = sphereSize[0] * alist.length + cylinderSize[0] * blist.length;
    vlist = new Array(len1);
    nlist = new Array(len1);
    ilist = new Array(len2);
    for (let i = 0; i < alist.length; ++i) {
      atom = alist[i];
      [vidx, nidx, iidx] = GeomRenderer.genGeomSphere(vlist, vidx, nlist, nidx, ilist, iidx, vclist, atom._position, 0.4, color, lat_furfaces, lon_furfaces);
    }
    for (let i = 0; i < blist.length; ++i) {
      bond = blist[i];
      if (bond.position1.x) {
        continue;
      } else {
        position1 = new three_module_Vector3(bond.position1[0], bond.position1[1], bond.position1[2]);
        position2 = new three_module_Vector3(bond.position2[0], bond.position2[1], bond.position2[2]);
      }
      [vidx, nidx, iidx] = GeomRenderer.genGeomCylinder(vlist, vidx, nlist, nidx, ilist, iidx, vclist, position1, position2, bond.radius, color, num_furfaces);
    }
    let geometry = new BufferGeometry();
    const positionAttr = new Float32BufferAttribute(vlist, 3);
    const normalAttr = new Float32BufferAttribute(nlist, 3);
    const count = vlist.length;
    geometry.setAttribute('color', new BufferAttribute(new Float32Array(count * 3), 3));
    geometry.setAttribute('position', positionAttr);
    geometry.setAttribute('normal', normalAttr);
    geometry.setIndex(ilist);
    const colors = geometry.attributes.color;
    for (let i = 0; i < count; ++i) {
      color.setRGB(0, 0, 1);
      colors.setXYZ(i, color.r, color.g, color.b);
    }
    let uniforms = {};
    uniforms = UniformsUtils.merge([uniforms, UniformsLib['lights']]);
    let material = new ShaderMaterial({
      uniforms: uniforms,
      vertexColors: true,
      fragmentShader: lambertLightFragmentShader(),
      vertexShader: vertexShader(),
      lights: true
    });
    let mesh = new three_module_Mesh(geometry, material);
    this._renderer._scene.add(mesh);
  }

  /**
   * 문자 데이터를 여러개의 메쉬로 생성한다.
   * @param {any} alist
   * @param {any} blist
   */
  generateMoleWithMultipleMesh(alist, blist) {
    let atom;
    let bond;
    let quaternion = new Quaternion();
    let basis = new three_module_Vector3(0, 1, 0);
    let rotation_diff = new three_module_Vector3();
    let position1, position2;
    let pos = new three_module_Vector3();
    let material = new MeshBasicMaterial({
      color: 0x4488aa,
      side: DoubleSide
    });
    let lat_furfaces = 30,
      lon_furfaces = 30,
      num_furfaces = 30;
    for (let i = 0; i < alist.length; ++i) {
      atom = alist[i];
      let geometry = new SphereGeometry(0.4, lat_furfaces, lon_furfaces);
      let mesh = new three_module_Mesh(geometry, material);
      mesh.position.set(atom._position.x, atom._position.y, atom._position.z);
      this._renderer._scene.add(mesh);
    }
    for (let i = 0; i < blist.length; ++i) {
      bond = blist[i];
      if (bond.position1.x) {
        continue;
      } else {
        position1 = new three_module_Vector3(bond.position1[0], bond.position1[1], bond.position1[2]);
        position2 = new three_module_Vector3(bond.position2[0], bond.position2[1], bond.position2[2]);
      }
      let dist = position1.distanceTo(position2);
      let geometry = new CylinderGeometry(bond.radius, bond.radialSegments, dist, num_furfaces, 1, true);
      let mesh = new three_module_Mesh(geometry, material);
      pos.addVectors(position1, position2).multiplyScalar(1 / 2);
      rotation_diff.subVectors(position1, position2);
      quaternion.setFromUnitVectors(basis, rotation_diff.normalize());
      mesh.applyQuaternion(quaternion);
      mesh.position.set(pos.x, pos.y, pos.z);
      this._renderer._scene.add(mesh);
    }
  }
}

/**
 * vertex shader를 반환한다
 * */
function vertexShader() {
  return `
    varying vec3 vUv; 
    varying vec4 modelViewPosition; 
    varying vec3 vecNormal;
    varying vec3 v_color;

    void main() {
      v_color = vec3(color);
      vUv = position; 
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  `;
}

/**
 * lambert light fragment shader를 반환한다
 * */
function lambertLightFragmentShader() {
  return `

    varying vec3 v_color;

    struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };  
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      varying vec3 vUv;
      varying vec4 modelViewPosition; 
      varying vec3 vecNormal; 

      void main() {
        vec4 addedLights = vec4(0.1, 0.1, 0.1, 1.0);

        for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
            vec3 lightDirection = normalize(modelViewPosition.xyz - pointLights[l].position - cameraPosition);
            addedLights.rgb += clamp(dot(-lightDirection, vecNormal), 0.0, 1.0) * pointLights[l].color; //'light intensity' 
        }

        vec3 colorAndPointLight = v_color * addedLights.rgb;
        vec3 finalColor = vec3(colorAndPointLight.r + 0.3, colorAndPointLight.g + 0.3, colorAndPointLight.b + 0.3);

        gl_FragColor = vec4(finalColor, 1.0);
        
      }
    `;
}
;// CONCATENATED MODULE: ./Renderer/ProteinTrajectory.js







/**
 * Projection Trajectory 계산 클래스
 * */
class ProteinTrajectory {
  /**
   * Null Coil을 생성한다
   * @param {any} ptspline
   * @param {any} ppt1
   * @param {any} ppt4
   * @param {any} cr
   * @param {any} cg
   * @param {any} cb
   */
  static genNullCoil(ptspline, ppt1, ppt4, cr, cg, cb) {
    var pt1 = ppt1.clone();
    var pt2 = ppt1.clone();
    var pt3 = ppt4.clone();
    var pt4 = ppt4.clone();
    const t2 = 1 / 3;
    const t3 = 2 / 3;
    pt2._pos = pt1._pos.lerp(pt4._pos, t2);
    pt3._pos = pt1._pos.lerp(pt4._pos, t3);
    pt2._normal = pt1._normal.lerp(pt4._normal, t2);
    pt3._normal = pt1._normal.lerp(pt4._normal, t3);
    pt2._forward = pt1._forward.lerp(pt4._forward, t2);
    pt3._forward = pt1._forward.lerp(pt4._forward, t3);
    pt2._binormal = pt1._binormal.lerp(pt4._binormal, t2);
    pt3._binormal = pt1._binormal.lerp(pt4._binormal, t3);
    pt4._pos.set(0, 0, 0);

    // 거리구하기
    var p1 = pt1._pos.clone();
    var p4 = pt4._pos.clone();
    var dist = p1.distanceTo(p4);
    var len = dist / 0.05;
    var traj = new ProteinTrajectory();
    traj.add(pt1);
    traj.add(pt2);
    traj.add(pt3);
    traj.add(pt4);
    var mesh = ptspline.generateEmpty(traj._points, cr, cg, cb);
    return mesh;
  }
  static getAtomGeomPosition(geom) {
    return new three_module_Vector3(geom.GetX(), geom.GetY(), geom.GetZ());
  }

  /**
   * DNA arm 위치를 찾는다.
   * @param {any} pos
   * @param {any} geom_dic
   * @param {any} cycle
   * @returns {THREE.Vector3} 위치 값
   */
  static findDNAarmPosition(pos, geom_dic, cycle) {
    const len = cycle.size();
    let min_length = 100000;
    let sel_pos = pos.clone();
    for (let i = 0; i < len; i++) {
      let idb = cycle.get(i);
      if (idb < 0) continue;
      let geom1 = geom_dic[idb];
      let pos2 = ProteinTrajectory.getAtomGeomPosition(geom1);
      const length = pos2.sub(pos).length();
      if (length < min_length) {
        min_length = length;
        sel_pos = ProteinTrajectory.getAtomGeomPosition(geom1);
      }
    }
    return sel_pos;
  }

  /**
   * Cycle를 분리한다.
   * @param {any} cycle_list
   * @returns {Array} 분리된 cycle 데이터
   */
  static splitCycle(cycle_list) {
    let ret = [];
    const len = cycle_list.size();
    let j = 0;
    ret[j] = [];
    for (let i = 0; i < len; i++) {
      const v = cycle_list.get(i);
      if (v < 0) {
        // end
        j++;
        ret[j] = [];
      } else {
        ret[j].push(v);
      }
    }
    ret.pop();
    return ret;
  }

  /**
   * Cycle Flip 상태를 체크한다.
   * @param {any} geom_dic
   * @param {any} cycle
   * @param {any} v1
   */
  static checkCycleFlip(geom_dic, cycle, v1) {
    let cycle2;
    let p1 = geom_dic[cycle[0]].position.clone();
    let p2 = geom_dic[cycle[1]].position.clone();
    let p3 = geom_dic[cycle[2]].position.clone();
    let normal = Util.calcNormal(p1, p2, p3);
    let value = normal;
    return cycle2;
  }

  /**
   * cycle을 생성한다
   * @param {any} geom_dic
   * @param {any} cycle
   * @param {any} v_forward
   * @param {any} color
   * @returns {THREE.Geometry} 
   */
  static createCycleGeometry(geom_dic, cycle, v_forward, color) {
    let width = 0.1;
    let p1 = ProteinTrajectory.getAtomGeomPosition(geom_dic[cycle[0]]);
    let p2 = ProteinTrajectory.getAtomGeomPosition(geom_dic[cycle[1]]);
    let p3 = ProteinTrajectory.getAtomGeomPosition(geom_dic[cycle[2]]);
    let normal = Util.calcNormal(p1, p2, p3);
    let value = normal.dot(v_forward);
    if (value < 0) {
      cycle = Util.flipArray(cycle);
      normal.multiplyScalar(-1);
    }
    normal.normalize();
    normal.multiplyScalar(width);
    const geometry = new BufferGeometry();
    let indices = [];
    let positions = [];
    let colors = [];
    const shade = 0.8;
    let sumU = new three_module_Vector3();
    let sumD = new three_module_Vector3();
    for (let i = 0; i < cycle.length; i++) {
      const id = cycle[i];
      let geom = geom_dic[id];
      let tposU = ProteinTrajectory.getAtomGeomPosition(geom).add(normal);
      let tposD = ProteinTrajectory.getAtomGeomPosition(geom).sub(normal);
      sumU.add(tposU);
      sumD.add(tposD);
      positions.push(tposU.x, tposU.y, tposU.z);
      positions.push(tposD.x, tposD.y, tposD.z);
      positions.push(tposU.x, tposU.y, tposU.z);
      positions.push(tposD.x, tposD.y, tposD.z);
      positions.push(tposU.x, tposU.y, tposU.z);
      positions.push(tposD.x, tposD.y, tposD.z);
      colors.push(shade, shade, shade);
      colors.push(shade, shade, shade);
      colors.push(shade, shade, shade);
      colors.push(shade, shade, shade);
      colors.push(shade, shade, shade);
      colors.push(shade, shade, shade);
      //geometry.vertices.push(tpos);
    }

    sumU.multiplyScalar(1 / cycle.length);
    sumD.multiplyScalar(1 / cycle.length);
    positions.push(sumU.x, sumU.y, sumU.z);
    let cidxU = positions.length / 3 - 1;
    positions.push(sumD.x, sumD.y, sumD.z);
    colors.push(shade, shade, shade);
    colors.push(shade, shade, shade);
    let i3U = cidxU;
    for (let i = 0; i < cycle.length; i++) {
      let i1 = i * 6;
      let i2 = (i + 1) * 6;
      if (i2 >= cycle.length * 6) {
        i2 = 0;
      }
      indices.push(i1, i3U, i2);
      indices.push(i1 + 1, i2 + 1, i3U + 1);
      let ii1 = i1 + 2;
      let ii2 = i2 + 2;
      let iii1 = i1 + 4;
      let iii2 = i2 + 4;
      indices.push(ii1, iii2, ii1 + 1);
      indices.push(iii2, iii2 + 1, ii1 + 1);
    }
    geometry.setIndex(indices);
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.setAttribute('normal', new Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    geometry.computeVertexNormals();
    geometry.computeBoundingSphere();
    return geometry;
  }

  /**
   * dna arm을 생성한다
   * @param {any} idx
   * @param {any} geom_idx
   * @param {any} gr
   * @param {any} geom
   * @param {any} protein_trajectory
   */
  static genDNAarmGeometry(idx, geom_idx, gr, geom, protein_trajectory) {
    let list = [];
    let geomdic = gr._geomDic;
    let pt = protein_trajectory;
    let point = pt._points[idx + 1];
    let cycle_data = geom.GetDnaArm(point._geomIdx);
    let pos1 = point._pos;
    let idb_size = cycle_data.size();
    let pos2 = ProteinTrajectory.findDNAarmPosition(pos1, geomdic, cycle_data);

    // DNA의 cylinder부분 모델링 해서 list에 넣음. 
    let cylinder_geom = GeomRenderer.createCylinderGeometry(gr, pos1, pos2, 0.1);
    let attr1 = cylinder_geom.getAttribute("position");
    const vertex_size = attr1.count;
    let colors = [];
    const shade = 0.6;
    for (let i = 0; i < vertex_size; i++) {
      colors.push(shade, shade, shade);
    }
    cylinder_geom.setAttribute('color', new Float32BufferAttribute(colors, 3));
    list.push(cylinder_geom);

    // cycle을 여러개의 cycle로 분해
    let cycles = ProteinTrajectory.splitCycle(cycle_data);
    for (let i = 0; i < cycles.length; i++) {
      let geometry = ProteinTrajectory.createCycleGeometry(geomdic, cycles[i], point._forward);
      list.push(geometry);
    }
    return list;
  }

  /**
   * protein trajectory를 생성한다
   * @param {any} gr geom renderer
   * @param {any} geom geom 
   * @param {any} parent geom의 parent
   */
  static genProteinTrajectory(gr, geom, parent) {
    const len = geom.GetNumPoints();
    const id = geom.GetID();
    let ptlist = [];
    let pt = new ProteinTrajectory();
    ptlist.push(pt);
    //let sp = new ptSplinePoint();
    //pt.add(sp);

    let bridge_id = [];
    let bi = 1;
    let bFirst = true;
    for (var i = 0; i < len; i++) {
      var pi = i - 1;
      var ni = i + 1;
      if (pi < 0) pi = 0;
      if (ni > len - 1) ni = len - 1;
      var ntype = String.fromCharCode(geom.GetAminoType(ni));
      var ptype = String.fromCharCode(geom.GetAminoType(pi));
      var type = String.fromCharCode(geom.GetAminoType(i));

      // 끊어짐 이 있는지 체크
      if (type == '#') {
        const cpos = geom.GetPos(i);
        if (cpos[0] > 1) {
          pt = new ProteinTrajectory();
          ptlist.push(pt);
          //var sp2 = new ptSplinePoint();
          //pt.add(sp2);

          bridge_id[bi] = i + id;
          bi++;
          bFirst = true;
          continue;
        }
        continue;
      }
      if (ntype == '#') {
        ni = i;
      }
      if (ptype == '#') {
        pi = i;
      }
      if (gr._trajectoryType == 1) {
        if (type != 'x') {
          type = 'c';
        }
      }
      if (type != 'x') {
        const cpos = geom.GetPos(i);
        const ppos = geom.GetPos(pi);
        const npos = geom.GetPos(ni);
        const normal = geom.GetNormal(i);
        var pos = [];
        pos[0] = cpos[0];
        pos[1] = cpos[1];
        pos[2] = cpos[2];
        var forward = [];
        if (ntype != 'x') {
          forward[0] = npos[0] - ppos[0];
          forward[1] = npos[1] - ppos[1];
          forward[2] = npos[2] - ppos[2];
        } else {
          if (pt._points.length > 0) {
            let ppf = pt._points[pt._points.length - 1]._forward;
            forward = [ppf.x, ppf.y, ppf.z];
          } else {
            forward = [0, 0, 0];
          }
        }

        /*
        var pos = [];
        pos[0] = (cpos[0] + npos[0]) * 0.5;
        pos[1] = (cpos[1] + npos[1]) * 0.5;
        pos[2] = (cpos[2] + npos[2]) * 0.5;
          var forward = [];
        forward[0] = npos[0] - cpos[0];
        forward[1] = npos[1] - cpos[1];
        forward[2] = npos[2] - cpos[2];
        */

        let sp = new ptSplinePoint();
        sp.setType(type);
        sp.setPos(new three_module_Vector3(pos[0], pos[1], pos[2]));
        sp.setNormal(new three_module_Vector3(normal[0], normal[1], normal[2]));
        sp.setForward(new three_module_Vector3(forward[0], forward[1], forward[2]));
        sp._id = i + id;
        sp._geomIdx = i;
        pt.add(sp);
        bFirst = false;
      }
    }

    /*
    const mesh = pt.generateMesh();
    this.updateMesh(mesh, geom, parent);
    return mesh;
    */

    const cr = Math.random() * 0.5;
    const cg = Math.random();
    const cb = Math.random();
    let prev_pt = null;
    bFirst = true;
    for (var k = 0; k < ptlist.length; k++) {
      pt = ptlist[k];
      if (pt._points.length < 4) continue;

      // 처음과 끝에 점 하나 더 넣기
      pt._points[0] = pt._points[1].clone();
      var vf = pt._points[2]._pos.clone();
      vf.sub(pt._points[1]._pos);
      vf.multiplyScalar(0.3);
      pt._points[0]._pos.sub(vf);
      let end_pt = pt._points[pt._points.length - 1].clone();
      pt.add(end_pt);
      let start_idx = pt._points[0]._id;
      const list = pt.generateGeometryList(cr, cg, cb);
      if (!bFirst) {
        // Residue 데이터 없는 곳의 연결 점선.

        var p1 = prev_pt._cartoon._endPos;
        var p4 = pt._cartoon._startPos;
        var emesh = ptSpline.generateBlankLineMesh(gr, p1, p4, cr, cg, cb);
        emesh._disposeMaterial = true;
        emesh._disposeGeometry = true;
        gr.updateMeshWithID(emesh, bridge_id[k], geom, parent);
      }
      for (var i = 0; i < list.length; i++) {
        let geometry = list[i];
        if (geometry) {
          let merged_geom;
          if (geom.IsDNA()) {
            {
              let geometry_list = ProteinTrajectory.genDNAarmGeometry(i, start_idx, gr, geom, pt);
              geometry_list.push(geometry);
              merged_geom = BufferGeometryUtils.mergeBufferGeometries(geometry_list);
            }
          } else {
            merged_geom = geometry;
          }
          const material = new MeshLambertMaterial();
          material.color = new Color(cr, cg, cb);
          material.vertexColors = true;
          var mesh = new three_module_Mesh(merged_geom, material);
          mesh._originalColorR = cr;
          mesh._originalColorG = cg;
          mesh._originalColorB = cb;
          mesh._mat = material;
          mesh._id = geometry._ptPoint._id;
          mesh._disposeMaterial = true;
          mesh._disposeGeometry = true;
          gr.updateMeshWithID(mesh, mesh._id, geom, parent);
        }
      }
      bFirst = false;
      prev_pt = pt;
    }

    //        return mesh;
  }

  /**
   * 클래스 생성자
   * @param {Number} num_faces 점 개수
   */
  constructor(num_faces) {
    this._numFaces = num_faces;
    this._points = [];
    this._cartoon = new ptSpline();
  }

  /**
   * 점을 추가한다.
   * @param {Point} st_point
   */
  add(st_point) {
    if (this._points.length == 0) {
      let pt0 = st_point.clone();
      this._points.push(pt0);
    } else {
      var prev = this._points[this._points.length - 1];
      st_point.checkFlip(prev);
    }

    // Helix?? ??? ???????? ???????? Normal???????? 1.5??? ??????
    if (st_point._type == "H") {
      var t = 0.9;
      if (st_point._flipped) t = -t;
      st_point._pos.x = st_point._pos.x + st_point._normal.x * t;
      st_point._pos.y = st_point._pos.y + st_point._normal.y * t;
      st_point._pos.z = st_point._pos.z + st_point._normal.z * t;
    }
    this._points.push(st_point);
  }

  /**
   * Mesh 를 생성한다.
   * @param {Number} r red color [0,1]
   * @param {Number} g green color [0,1]
   * @param {Number} b blue color [0,1]
   */
  generateMesh(r, g, b) {
    var mesh = this._cartoon.generate(this._points, r, g, b, false);
    return mesh;

    //        return this._cartoon._mesh.generateMesh(m1)
  }

  /**
   * Mesh List 를 생성한다.
   * @param {Number} r red color [0,1]
   * @param {Number} g green color [0,1]
   * @param {Number} b blue color [0,1]
   */
  generateGeometryList(r, g, b) {
    var list = this._cartoon.generate(this._points, r, g, b, true);
    return list;
  }

  /*
  Generate(geom) {
      const xs = [1, 2, 3, 4, 5];
      const ys = [9, 3, 6, 2, 4];
        const spline = new Spline(xs, ys);
        // get Y at arbitrary X
      console.log(spline.at(1.4));
        this._splinePoints = [];
        var num = geom.GetNumPoints();
      for (var i = 0; i < num; i++) {
          var pos = geom.GetPos(i);
          var normal = geom.GetNormal(i);
          var type = geom.GetType(i);
      }
          for (var i = 0; i < num; i++) {
          var pos = geom.GetPos(i);
          var normal = geom.GetNormal(i);
          var type = geom.GetType(i);
      }
      }
  */
}
;// CONCATENATED MODULE: ./Renderer/jsm/controls/OrbitControls.js


// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = {
  type: 'change'
};
const _startEvent = {
  type: 'start'
};
const _endEvent = {
  type: 'end'
};
class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = 'none'; // disable touch scroll

    // Set to false to disable this control
    this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    this.target = new three_module_Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    this.minDistance = 0;
    this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    this.minZoom = 0;
    this.maxZoom = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
    this.minAzimuthAngle = -Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    this.enableDamping = false;
    this.dampingFactor = 0.05;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    this.enableZoom = true;
    this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    this.enableRotate = true;
    this.rotateSpeed = 1.0;

    // Set to false to disable panning
    this.enablePan = true;
    this.panSpeed = 1.0;
    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
    this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    this.autoRotate = false;
    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

    // The four arrow keys
    this.keys = {
      LEFT: 'ArrowLeft',
      UP: 'ArrowUp',
      RIGHT: 'ArrowRight',
      BOTTOM: 'ArrowDown'
    };

    // Mouse buttons
    this.mouseButtons = {
      LEFT: three_module_MOUSE.ROTATE,
      MIDDLE: three_module_MOUSE.DOLLY,
      RIGHT: three_module_MOUSE.PAN
    };

    // Touch fingers
    this.touches = {
      ONE: three_module_TOUCH.ROTATE,
      TWO: three_module_TOUCH.DOLLY_PAN
    };

    // for reset
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;

    // the target DOM element for key events
    this._domElementKeyEvents = null;

    //
    // public methods
    //

    this.getPolarAngle = function () {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function () {
      return spherical.theta;
    };
    this.getDistance = function () {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function (domElement) {
      domElement.addEventListener('keydown', onKeyDown);
      this._domElementKeyEvents = domElement;
    };
    this.saveState = function () {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function () {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    this.update = function () {
      const offset = new three_module_Vector3();

      // so camera.up is the orbit axis
      const quat = new Quaternion().setFromUnitVectors(object.up, new three_module_Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new three_module_Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);

        // rotate offset to "y-axis-is-up" space
        offset.applyQuaternion(quat);

        // angle from z-axis around y-axis
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }

        // restrict theta to be between desired limits

        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
          if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }

        // restrict phi to be between desired limits
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;

        // restrict radius to be between desired limits
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

        // move target to panned location

        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);

        // rotate offset back to "camera-up-vector-is-up" space
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;

        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function () {
      scope.domElement.removeEventListener('contextmenu', onContextMenu);
      scope.domElement.removeEventListener('pointerdown', onPointerDown);
      scope.domElement.removeEventListener('pointercancel', onPointerCancel);
      scope.domElement.removeEventListener('wheel', onMouseWheel);
      scope.domElement.removeEventListener('pointermove', onPointerMove);
      scope.domElement.removeEventListener('pointerup', onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
      }

      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };

    //
    // internals
    //

    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 0.000001;

    // current position in spherical coordinates
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new three_module_Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function () {
      const v = new three_module_Vector3();
      return function panLeft(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function () {
      const v = new three_module_Vector3();
      return function panUp(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();

    // deltaX and deltaY are in pixels; right and down are positive
    const pan = function () {
      const offset = new three_module_Vector3();
      return function pan(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          // perspective
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();

          // half of the fov is center to top of screen
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

          // we use only clientHeight here so aspect ratio does not distort speed
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          // orthographic
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    }

    //
    // event callbacks - update the object state
    //

    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseUp( /*event*/
    ) {

      // no-op
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        // prevent the browser from scrolling on cursor keys
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom) handleTouchStartDolly();
      if (scope.enablePan) handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom) handleTouchStartDolly();
      if (scope.enableRotate) handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enablePan) handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enableRotate) handleTouchMoveRotate(event);
    }
    function handleTouchEnd( /*event*/
    ) {

      // no-op
    }

    //
    // event handlers - FSM: listen for events and reset state
    //

    function onPointerDown(event) {
      if (scope.enabled === false) return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
      }

      //

      addPointer(event);
      if (event.pointerType === 'touch') {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === 'touch') {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === 'touch') {
        onTouchEnd();
      } else {
        onMouseUp(event);
      }
      removePointer(event);

      //

      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);
      }
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case three_module_MOUSE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case three_module_MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case three_module_MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false) return;
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false) return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false) return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseUp(event) {
      handleMouseUp(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false) return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case three_module_TOUCH.ROTATE:
              if (scope.enableRotate === false) return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case three_module_TOUCH.PAN:
              if (scope.enablePan === false) return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case three_module_TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false) return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case three_module_TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false) return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false) return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false) return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false) return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false) return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onTouchEnd(event) {
      handleTouchEnd(event);
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onContextMenu(event) {
      if (scope.enabled === false) return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === undefined) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }

    //

    scope.domElement.addEventListener('contextmenu', onContextMenu);
    scope.domElement.addEventListener('pointerdown', onPointerDown);
    scope.domElement.addEventListener('pointercancel', onPointerCancel);
    scope.domElement.addEventListener('wheel', onMouseWheel, {
      passive: false
    });

    // force an update at start

    this.update();
  }
}

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

class MapControls extends (/* unused pure expression or super */ null && (OrbitControls)) {
  constructor(object, domElement) {
    super(object, domElement);
    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

    this.mouseButtons.LEFT = MOUSE.PAN;
    this.mouseButtons.RIGHT = MOUSE.ROTATE;
    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/controls/TrackballControls.js

const TrackballControls_changeEvent = {
  type: 'change'
};
const TrackballControls_startEvent = {
  type: 'start'
};
const TrackballControls_endEvent = {
  type: 'end'
};
class TrackballControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === undefined) console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document) console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      ZOOM: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_ZOOM_PAN: 4
    };
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = 'none'; // disable touch scroll

    // API

    this.enabled = true;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this.rotateSpeed = 1.0;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;
    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.keys = ['KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/];

    this.mouseButtons = {
      LEFT: three_module_MOUSE.ROTATE,
      MIDDLE: three_module_MOUSE.DOLLY,
      RIGHT: three_module_MOUSE.PAN
    };

    // internals

    this.target = new three_module_Vector3();
    const EPS = 0.000001;
    const lastPosition = new three_module_Vector3();
    let lastZoom = 1;
    let _state = STATE.NONE,
      _keyState = STATE.NONE,
      _touchZoomDistanceStart = 0,
      _touchZoomDistanceEnd = 0,
      _lastAngle = 0;
    const _eye = new three_module_Vector3(),
      _movePrev = new Vector2(),
      _moveCurr = new Vector2(),
      _lastAxis = new three_module_Vector3(),
      _zoomStart = new Vector2(),
      _zoomEnd = new Vector2(),
      _panStart = new Vector2(),
      _panEnd = new Vector2(),
      _pointers = [],
      _pointerPositions = {};

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();
    this.zoom0 = this.object.zoom;

    // methods

    this.handleResize = function () {
      const box = scope.domElement.getBoundingClientRect();
      // adjustments come from similar code in the jquery offset() function
      const d = scope.domElement.ownerDocument.documentElement;
      scope.screen.left = box.left + window.pageXOffset - d.clientLeft;
      scope.screen.top = box.top + window.pageYOffset - d.clientTop;
      scope.screen.width = box.width;
      scope.screen.height = box.height;
    };
    const getMouseOnScreen = function () {
      const vector = new Vector2();
      return function getMouseOnScreen(pageX, pageY) {
        vector.set((pageX - scope.screen.left) / scope.screen.width, (pageY - scope.screen.top) / scope.screen.height);
        return vector;
      };
    }();
    const getMouseOnCircle = function () {
      const vector = new Vector2();
      return function getMouseOnCircle(pageX, pageY) {
        vector.set((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5), (scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width // screen.width intentional
        );

        return vector;
      };
    }();
    this.rotateCamera = function () {
      const axis = new three_module_Vector3(),
        quaternion = new Quaternion(),
        eyeDirection = new three_module_Vector3(),
        objectUpDirection = new three_module_Vector3(),
        objectSidewaysDirection = new three_module_Vector3(),
        moveDirection = new three_module_Vector3();
      return function rotateCamera() {
        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        let angle = moveDirection.length();
        if (angle) {
          _eye.copy(scope.object.position).sub(scope.target);
          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(scope.object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();
          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);
          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));
          axis.crossVectors(moveDirection, _eye).normalize();
          angle *= scope.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);
          _eye.applyQuaternion(quaternion);
          scope.object.up.applyQuaternion(quaternion);
          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else if (!scope.staticMoving && _lastAngle) {
          _lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);
          _eye.copy(scope.object.position).sub(scope.target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          scope.object.up.applyQuaternion(quaternion);
        }
        _movePrev.copy(_moveCurr);
      };
    }();
    this.zoomCamera = function () {
      let factor;
      if (_state === STATE.TOUCH_ZOOM_PAN) {
        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;
        if (scope.object.isPerspectiveCamera) {
          _eye.multiplyScalar(factor);
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom *= factor;
          scope.object.updateProjectionMatrix();
        } else {
          console.warn('THREE.TrackballControls: Unsupported camera type');
        }
      } else {
        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * scope.zoomSpeed;
        if (factor !== 1.0 && factor > 0.0) {
          if (scope.object.isPerspectiveCamera) {
            _eye.multiplyScalar(factor);
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom /= factor;
            scope.object.updateProjectionMatrix();
          } else {
            console.warn('THREE.TrackballControls: Unsupported camera type');
          }
        }
        if (scope.staticMoving) {
          _zoomStart.copy(_zoomEnd);
        } else {
          _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
        }
      }
    };
    this.panCamera = function () {
      const mouseChange = new Vector2(),
        objectUp = new three_module_Vector3(),
        pan = new three_module_Vector3();
      return function panCamera() {
        mouseChange.copy(_panEnd).sub(_panStart);
        if (mouseChange.lengthSq()) {
          if (scope.object.isOrthographicCamera) {
            const scale_x = (scope.object.right - scope.object.left) / scope.object.zoom / scope.domElement.clientWidth;
            const scale_y = (scope.object.top - scope.object.bottom) / scope.object.zoom / scope.domElement.clientWidth;
            mouseChange.x *= scale_x;
            mouseChange.y *= scale_y;
          }
          mouseChange.multiplyScalar(_eye.length() * scope.panSpeed);
          pan.copy(_eye).cross(scope.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(scope.object.up).setLength(mouseChange.y));
          scope.object.position.add(pan);
          scope.target.add(pan);
          if (scope.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(scope.dynamicDampingFactor));
          }
        }
      };
    }();
    this.checkDistances = function () {
      if (!scope.noZoom || !scope.noPan) {
        if (_eye.lengthSq() > scope.maxDistance * scope.maxDistance) {
          scope.object.position.addVectors(scope.target, _eye.setLength(scope.maxDistance));
          _zoomStart.copy(_zoomEnd);
        }
        if (_eye.lengthSq() < scope.minDistance * scope.minDistance) {
          scope.object.position.addVectors(scope.target, _eye.setLength(scope.minDistance));
          _zoomStart.copy(_zoomEnd);
        }
      }
    };
    this.update = function () {
      _eye.subVectors(scope.object.position, scope.target);
      if (!scope.noRotate) {
        scope.rotateCamera();
      }
      if (!scope.noZoom) {
        scope.zoomCamera();
      }
      if (!scope.noPan) {
        scope.panCamera();
      }
      scope.object.position.addVectors(scope.target, _eye);
      if (scope.object.isPerspectiveCamera) {
        scope.checkDistances();
        scope.object.lookAt(scope.target);
        if (lastPosition.distanceToSquared(scope.object.position) > EPS) {
          scope.dispatchEvent(TrackballControls_changeEvent);
          lastPosition.copy(scope.object.position);
        }
      } else if (scope.object.isOrthographicCamera) {
        scope.object.lookAt(scope.target);
        if (lastPosition.distanceToSquared(scope.object.position) > EPS || lastZoom !== scope.object.zoom) {
          scope.dispatchEvent(TrackballControls_changeEvent);
          lastPosition.copy(scope.object.position);
          lastZoom = scope.object.zoom;
        }
      } else {
        console.warn('THREE.TrackballControls: Unsupported camera type');
      }
    };
    this.reset = function () {
      _state = STATE.NONE;
      _keyState = STATE.NONE;
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.up.copy(scope.up0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      _eye.subVectors(scope.object.position, scope.target);
      scope.object.lookAt(scope.target);
      scope.dispatchEvent(TrackballControls_changeEvent);
      lastPosition.copy(scope.object.position);
      lastZoom = scope.object.zoom;
    };

    // listeners

    function onPointerDown(event) {
      if (scope.enabled === false) return;
      if (_pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
      }

      //

      addPointer(event);
      if (event.pointerType === 'touch') {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === 'touch') {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === 'touch') {
        onTouchEnd(event);
      } else {
        onMouseUp();
      }

      //

      removePointer(event);
      if (_pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);
      }
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function keydown(event) {
      if (scope.enabled === false) return;
      window.removeEventListener('keydown', keydown);
      if (_keyState !== STATE.NONE) {
        return;
      } else if (event.code === scope.keys[STATE.ROTATE] && !scope.noRotate) {
        _keyState = STATE.ROTATE;
      } else if (event.code === scope.keys[STATE.ZOOM] && !scope.noZoom) {
        _keyState = STATE.ZOOM;
      } else if (event.code === scope.keys[STATE.PAN] && !scope.noPan) {
        _keyState = STATE.PAN;
      }
    }
    function keyup() {
      if (scope.enabled === false) return;
      _keyState = STATE.NONE;
      window.addEventListener('keydown', keydown);
    }
    function onMouseDown(event) {
      if (_state === STATE.NONE) {
        switch (event.button) {
          case scope.mouseButtons.LEFT:
            _state = STATE.ROTATE;
            break;
          case scope.mouseButtons.MIDDLE:
            _state = STATE.ZOOM;
            break;
          case scope.mouseButtons.RIGHT:
            _state = STATE.PAN;
            break;
          default:
            _state = STATE.NONE;
        }
      }
      const state = _keyState !== STATE.NONE ? _keyState : _state;
      if (state === STATE.ROTATE && !scope.noRotate) {
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      } else if (state === STATE.ZOOM && !scope.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (state === STATE.PAN && !scope.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      }
      scope.dispatchEvent(TrackballControls_startEvent);
    }
    function onMouseMove(event) {
      const state = _keyState !== STATE.NONE ? _keyState : _state;
      if (state === STATE.ROTATE && !scope.noRotate) {
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      } else if (state === STATE.ZOOM && !scope.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (state === STATE.PAN && !scope.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }
    function onMouseUp() {
      _state = STATE.NONE;
      scope.dispatchEvent(TrackballControls_endEvent);
    }
    function onMouseWheel(event) {
      if (scope.enabled === false) return;
      if (scope.noZoom === true) return;
      event.preventDefault();
      switch (event.deltaMode) {
        case 2:
          // Zoom in pages
          _zoomStart.y -= event.deltaY * 0.025;
          break;
        case 1:
          // Zoom in lines
          _zoomStart.y -= event.deltaY * 0.01;
          break;
        default:
          // undefined, 0, assume pixels
          _zoomStart.y -= event.deltaY * 0.00025;
          break;
      }
      scope.dispatchEvent(TrackballControls_startEvent);
      scope.dispatchEvent(TrackballControls_endEvent);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (_pointers.length) {
        case 1:
          _state = STATE.TOUCH_ROTATE;
          _moveCurr.copy(getMouseOnCircle(_pointers[0].pageX, _pointers[0].pageY));
          _movePrev.copy(_moveCurr);
          break;
        default:
          // 2 or more
          _state = STATE.TOUCH_ZOOM_PAN;
          const dx = _pointers[0].pageX - _pointers[1].pageX;
          const dy = _pointers[0].pageY - _pointers[1].pageY;
          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
          const x = (_pointers[0].pageX + _pointers[1].pageX) / 2;
          const y = (_pointers[0].pageY + _pointers[1].pageY) / 2;
          _panStart.copy(getMouseOnScreen(x, y));
          _panEnd.copy(_panStart);
          break;
      }
      scope.dispatchEvent(TrackballControls_startEvent);
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (_pointers.length) {
        case 1:
          _movePrev.copy(_moveCurr);
          _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
          break;
        default:
          // 2 or more

          const position = getSecondPointerPosition(event);
          const dx = event.pageX - position.x;
          const dy = event.pageY - position.y;
          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
          const x = (event.pageX + position.x) / 2;
          const y = (event.pageY + position.y) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          break;
      }
    }
    function onTouchEnd(event) {
      switch (_pointers.length) {
        case 0:
          _state = STATE.NONE;
          break;
        case 1:
          _state = STATE.TOUCH_ROTATE;
          _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
          _movePrev.copy(_moveCurr);
          break;
        case 2:
          _state = STATE.TOUCH_ZOOM_PAN;
          _moveCurr.copy(getMouseOnCircle(event.pageX - _movePrev.pageX, event.pageY - _movePrev.pageY));
          _movePrev.copy(_moveCurr);
          break;
      }
      scope.dispatchEvent(TrackballControls_endEvent);
    }
    function contextmenu(event) {
      if (scope.enabled === false) return;
      event.preventDefault();
    }
    function addPointer(event) {
      _pointers.push(event);
    }
    function removePointer(event) {
      delete _pointerPositions[event.pointerId];
      for (let i = 0; i < _pointers.length; i++) {
        if (_pointers[i].pointerId == event.pointerId) {
          _pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = _pointerPositions[event.pointerId];
      if (position === undefined) {
        position = new Vector2();
        _pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === _pointers[0].pointerId ? _pointers[1] : _pointers[0];
      return _pointerPositions[pointer.pointerId];
    }
    this.dispose = function () {
      scope.domElement.removeEventListener('contextmenu', contextmenu);
      scope.domElement.removeEventListener('pointerdown', onPointerDown);
      scope.domElement.removeEventListener('pointercancel', onPointerCancel);
      scope.domElement.removeEventListener('wheel', onMouseWheel);
      scope.domElement.removeEventListener('pointermove', onPointerMove);
      scope.domElement.removeEventListener('pointerup', onPointerUp);
      window.removeEventListener('keydown', keydown);
      window.removeEventListener('keyup', keyup);
    };
    this.domElement.addEventListener('contextmenu', contextmenu);
    this.domElement.addEventListener('pointerdown', onPointerDown);
    this.domElement.addEventListener('pointercancel', onPointerCancel);
    this.domElement.addEventListener('wheel', onMouseWheel, {
      passive: false
    });
    window.addEventListener('keydown', keydown);
    window.addEventListener('keyup', keyup);
    this.handleResize();

    // force an update at start
    this.update();
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/loaders/GLTFLoader.js

class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function (parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function (parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== '') {
      resourcePath = this.resourcePath;
    } else if (this.path !== '') {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }

    // Tells the LoadingManager to track an extra item, which resolves after
    // the model is fully loaded. This means the count of items loaded will
    // be incorrect, but ensures manager.onLoad() does not fire early.
    this.manager.itemStart(url);
    const _onError = function (e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (data) {
      try {
        scope.parse(data, resourcePath, function (gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions = {};
    const plugins = {};
    if (typeof data === 'string') {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }
        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json = JSON.parse(content);
    if (json.asset === undefined || json.asset.version[0] < 2) {
      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      plugins[plugin.name] = plugin;

      // Workaround to avoid determining as unknown extension
      // in addUnknownExtensionsToUserData().
      // Remove this workaround if we move all the existing
      // extension handlers to plugin system
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
}

/* GLTFREGISTRY */

function GLTFRegistry() {
  let objects = {};
  return {
    get: function (key) {
      return objects[key];
    },
    add: function (key, object) {
      objects[key] = object;
    },
    remove: function (key) {
      delete objects[key];
    },
    removeAll: function () {
      objects = {};
    }
  };
}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

    // Object3D instance caches
    this.cache = {
      refs: {},
      uses: {}
    };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = 'light:' + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(0xffffff);
    if (lightDef.color !== undefined) color.fromArray(lightDef.color);
    const range = lightDef.range !== undefined ? lightDef.range : 0;
    switch (lightDef.type) {
      case 'directional':
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case 'point':
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case 'spot':
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        // Handle spotlight properties.
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);
    }

    // Some lights (e.g. spot) default to a position other than the origin. Reset the position
    // here, because node-level parsing will only override position if explicitly specified.
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === undefined) return null;
    return this._loadLight(lightIndex).then(function (light) {
      return parser._getNodeRef(self.cache, lightIndex, light);
    });
  }
}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  }
}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== undefined) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== undefined) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== undefined) {
        const scale = extension.clearcoatNormalTexture.scale;

        // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);
      }
    }
    return Promise.all(pending);
  }
}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== undefined) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
    return Promise.resolve();
  }
}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;
    if (extension.specularTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {
        texture.encoding = sRGBEncoding;
      }));
    }
    return Promise.all(pending);
  }
}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const source = json.images[extension.source];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
      } else {
        // Assumes that the extension is optional and that a fallback texture is present
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  }
}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function (isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
      }

      // Fall back to PNG or JPEG.
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function (resolve) {
        const image = new Image();

        // Lossy test image. Support for lossy images doesn't guarantee support for all
        // WebP images, unfortunately.
        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
        image.onload = image.onerror = function () {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
        } else {
          // Assumes that the extension is optional and that fallback buffer data is present
          return null;
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function (res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const result = new ArrayBuffer(count * stride);
        const source = new Uint8Array(res[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  }
}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = {
  JSON: 0x4E4F534A,
  BIN: 0x004E4942
};
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    } else if (this.header.version < 2.0) {
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }

      // Clients must ignore chunks with unknown types.

      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error('THREE.GLTFLoader: JSON content not found.');
    }
  }
}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== undefined) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
      return new Promise(function (resolve) {
        dracoLoader.decodeDracoFile(bufferView, function (geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== undefined) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if (transform.texCoord !== undefined) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
      // See https://github.com/mrdoob/three.js/issues/21819.
      return texture;
    }
    texture = texture.clone();
    if (transform.offset !== undefined) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== undefined) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== undefined) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(params) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;

    //various chunks that need replacing
    const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
    const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
    const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
    const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
    const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\n');
    const uniforms = {
      specular: {
        value: new Color().setHex(0xffffff)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function (shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function () {
          return uniforms.specular.value;
        },
        set: function (v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function () {
          return uniforms.specularMap.value;
        },
        set: function (v) {
          uniforms.specularMap.value = v;
          if (v) {
            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function () {
          return uniforms.glossiness.value;
        },
        set: function (v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function () {
          return uniforms.glossinessMap.value;
        },
        set: function (v) {
          uniforms.glossinessMap.value = v;
          if (v) {
            this.defines.USE_GLOSSINESSMAP = '';
            this.defines.USE_UV = '';
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
    }
    materialParams.emissive = new Color(0.0, 0.0, 0.0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
    materialParams.specular = new Color(1.0, 1.0, 1.0);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === undefined ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1.0;
    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
    material.aoMapIntensity = 1.0;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = 1.0;
    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
    material.envMapIntensity = 1.0;
    material.refractionRatio = 0.98;
    return material;
  }
}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    // Copies a sample value to the result buffer. See description of glTF
    // CUBICSPLINE values layout in interpolate_() function below.

    const result = this.resultBuffer,
      values = this.sampleValues,
      valueSize = this.valueSize,
      offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
}
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
  const result = this.resultBuffer;
  const values = this.sampleValues;
  const stride = this.valueSize;
  const stride2 = stride * 2;
  const stride3 = stride * 3;
  const td = t1 - t0;
  const p = (t - t0) / td;
  const pp = p * p;
  const ppp = pp * p;
  const offset1 = i1 * stride3;
  const offset0 = offset1 - stride3;
  const s2 = -2 * ppp + 3 * pp;
  const s3 = ppp - pp;
  const s0 = 1 - s2;
  const s1 = s3 - pp + p;

  // Layout of keyframe output values for CUBICSPLINE animations:
  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
  for (let i = 0; i !== stride; i++) {
    const p0 = values[offset0 + i + stride]; // splineVertex_k
    const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
    const p1 = values[offset1 + i + stride]; // splineVertex_k+1
    const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
  }
  return result;
};

/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  'SCALAR': 1,
  'VEC2': 2,
  'VEC3': 3,
  'VEC4': 4,
  'MAT2': 4,
  'MAT3': 9,
  'MAT4': 16
};
const ATTRIBUTES = {
  POSITION: 'position',
  NORMAL: 'normal',
  TANGENT: 'tangent',
  TEXCOORD_0: 'uv',
  TEXCOORD_1: 'uv2',
  COLOR_0: 'color',
  WEIGHTS_0: 'skinWeight',
  JOINTS_0: 'skinIndex'
};
const PATH_PROPERTIES = {
  scale: 'scale',
  translation: 'position',
  rotation: 'quaternion',
  weights: 'morphTargetInfluences'
};
const INTERPOLATION = {
  CUBICSPLINE: undefined,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: 'OPAQUE',
  MASK: 'MASK',
  BLEND: 'BLEND'
};

/* UTILITY FUNCTIONS */

function resolveURL(url, path) {
  // Invalid URL
  if (typeof url !== 'string' || url === '') return '';

  // Host Relative URL
  if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
    path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
  }

  // Absolute URL http://,https://,//
  if (/^(https?:)?\/\//i.test(url)) return url;

  // Data URI
  if (/^data:.*,.*$/i.test(url)) return url;

  // Blob URL
  if (/^blob:.*$/i.test(url)) return url;

  // Relative URL
  return path + url;
}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial(cache) {
  if (cache['DefaultMaterial'] === undefined) {
    cache['DefaultMaterial'] = new MeshStandardMaterial({
      color: 0xFFFFFF,
      emissive: 0x000000,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache['DefaultMaterial'];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  // Add unknown glTF extensions to an object's userData.

  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === undefined) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== undefined) {
    if (typeof gltfDef.extras === 'object') {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
    }
  }
}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== undefined) hasMorphPosition = true;
    if (target.NORMAL !== undefined) hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal) break;
  }
  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== undefined) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }

  // .extras has user-defined data, so check that .extras.targetNames is an array.
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = '';
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  // Reference:
  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
  }
}

/* GLTF PARSER */

class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;

    // loader object cache
    this.cache = new GLTFRegistry();

    // associations between Three.js objects and glTF elements
    this.associations = new Map();

    // BufferGeometry caching
    this.primitiveCache = {};

    // Object3D instance caches
    this.meshCache = {
      refs: {},
      uses: {}
    };
    this.cameraCache = {
      refs: {},
      uses: {}
    };
    this.lightCache = {
      refs: {},
      uses: {}
    };
    this.textureCache = {};

    // Track node names, to ensure no duplicates
    this.nodeNamesUsed = {};

    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
    // expensive work of uploading a texture to the GPU off the main thread.
    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType('arraybuffer');
    if (this.options.crossOrigin === 'use-credentials') {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;

    // Clear the loader cache
    this.cache.removeAll();

    // Mark the special nodes/meshes in json for efficient parse
    this._invokeAll(function (ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function (ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function () {
      return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);
    }).then(function (dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser: parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function (ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function () {
        onLoad(result);
      });
    }).catch(onError);
  }

  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];

    // Nothing in the node definition indicates whether it is a Bone or an
    // Object3D. Use the skins' joint references to mark bones.
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }

    // Iterate over all nodes, marking references to shared resources,
    // as well as skeleton joints.
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== undefined) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);

        // Nothing in the mesh definition indicates whether it is
        // a SkinnedMesh or Mesh. Use the node's mesh reference
        // to mark SkinnedMesh if node has skin.
        if (nodeDef.skin !== undefined) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== undefined) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }

  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === undefined) return;
    if (cache.refs[index] === undefined) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }

  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    ref.name += '_instance_' + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }

  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ':' + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case 'scene':
          dependency = this.loadScene(index);
          break;
        case 'node':
          dependency = this.loadNode(index);
          break;
        case 'mesh':
          dependency = this._invokeOne(function (ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case 'accessor':
          dependency = this.loadAccessor(index);
          break;
        case 'bufferView':
          dependency = this._invokeOne(function (ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case 'buffer':
          dependency = this.loadBuffer(index);
          break;
        case 'material':
          dependency = this._invokeOne(function (ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case 'texture':
          dependency = this._invokeOne(function (ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case 'skin':
          dependency = this.loadSkin(index);
          break;
        case 'animation':
          dependency = this.loadAnimation(index);
          break;
        case 'camera':
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error('Unknown type: ' + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }

  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
      dependencies = Promise.all(defs.map(function (def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
    }

    // If present, GLB container is required to be the first buffer.
    if (bufferDef.uri === undefined && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function (resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
      // Ignore empty accessors, which may be used to declare runtime
      // information about attributes coming from another source (e.g. Draco
      // compression extension).
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function (bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;

      // The buffer is not interleaved if the stride is the item size in bytes.
      if (byteStride && byteStride !== itemBytes) {
        // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
        // This makes sure that IBA.count reflects accessor.count properly
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);

          // Integer parameters to IB/IBA are in array elements, not bytes.
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }

      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
      if (accessorDef.sparse !== undefined) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
        }
      }
      return bufferAttribute;
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const source = json.images[textureDef.source];
    let loader = this.textureLoader;
    if (source.uri) {
      const handler = options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  }
  loadTextureImage(textureIndex, source, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      // See https://github.com/mrdoob/three.js/issues/21559.
      return this.textureCache[cacheKey];
    }
    const URL = self.URL || self.webkitURL;
    let sourceURI = source.uri || '';
    let isObjectURL = false;
    let hasAlpha = true;
    const isJPEG = sourceURI.search(/\.jpe?g($|\?)/i) > 0 || sourceURI.search(/^data\:image\/jpeg/) === 0;
    if (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;
    if (source.bufferView !== undefined) {
      // Load binary image data from bufferView, if provided.

      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
        if (source.mimeType === 'image/png') {
          // Inspect the PNG 'IHDR' chunk to determine whether the image could have an
          // alpha channel. This check is conservative — the image could have an alpha
          // channel with all values == 1, and the indexed type (colorType == 3) only
          // sometimes contains alpha.
          //
          // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
          const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
        }
        isObjectURL = true;
        const blob = new Blob([bufferView], {
          type: source.mimeType
        });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === undefined) {
      throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');
    }
    const promise = Promise.resolve(sourceURI).then(function (sourceURI) {
      return new Promise(function (resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function (imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);
      });
    }).then(function (texture) {
      // Clean up resources and configure Texture.

      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name) texture.name = textureDef.name;

      // When there is definitely no alpha channel in the texture, set RGBFormat to save space.
      if (!hasAlpha) texture.format = RGBFormat;
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, {
        type: 'textures',
        index: textureIndex
      });
      return texture;
    }).catch(function () {
      console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }

  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef) {
    const parser = this;
    return this.getDependency('texture', mapDef.index).then(function (texture) {
      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
      // However, we will copy UV set 0 to UV set 1 on demand for aoMap
      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }

  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useVertexTangents = geometry.attributes.tangent !== undefined;
    const useVertexColors = geometry.attributes.color !== undefined;
    const useFlatShading = geometry.attributes.normal === undefined;
    if (mesh.isPoints) {
      const cacheKey = 'PointsMaterial:' + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = 'LineBasicMaterial:' + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }

    // Clone the material if it will be modified
    if (useVertexTangents || useVertexColors || useFlatShading) {
      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';
      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
      if (useVertexTangents) cacheKey += 'vertex-tangents:';
      if (useVertexColors) cacheKey += 'vertex-colors:';
      if (useFlatShading) cacheKey += 'flat-shading:';
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useVertexTangents) {
          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }

    // workarounds for mesh and geometry

    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
      geometry.setAttribute('uv2', geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType( /* materialIndex */
  ) {
    return MeshStandardMaterial;
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      // Specification:
      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
      if (metallicRoughness.metallicRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function (ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function (ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;

      // See: https://github.com/mrdoob/three.js/issues/17706
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));

      // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
      materialParams.normalScale = new Vector2(1, -1);
      if (materialDef.normalTexture.scale !== undefined) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
      }
    }
    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== undefined) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function () {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name) material.name = materialDef.name;

      // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
      if (material.map) material.map.encoding = sRGBEncoding;
      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, {
        type: 'materials',
        index: materialIndex
      });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }

  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');
    let name = sanitizedName;
    for (let i = 1; this.nodeNamesUsed[name]; ++i) {
      name = sanitizedName + '_' + i;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);

      // See if we've already created this geometry
      const cached = cache[cacheKey];
      if (cached) {
        // Use the cached geometry if it exists
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          // Use DRACO geometry if available
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          // Otherwise create a new geometry
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }

        // Cache this geometry
        cache[cacheKey] = {
          primitive: primitive,
          promise: geometryPromise
        };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function (results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];

        // 1. create Mesh

        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new three_module_Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            // we normalize floating point skin weight array to fix malformed assets (see #15319)
            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.');
      return;
    }
    if (cameraDef.type === 'perspective') {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === 'orthographic') {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = {
      joints: skinDef.joints
    };
    if (skinDef.inverseBindMatrices === undefined) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency('node', name));
      pendingInputAccessors.push(this.getDependency('accessor', input));
      pendingOutputAccessors.push(this.getDependency('accessor', output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === undefined) continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          // Node may be a Group (glTF mesh with several primitives) or a Mesh.
          node.traverse(function (object) {
            if (object.isMesh === true && object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }
          outputArray = scaled;
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);

          // Override interpolation with custom factory method.
          if (sampler.interpolation === 'CUBICSPLINE') {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              // A CUBICSPLINE keyframe in glTF has three output values for each input value,
              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
              // must be divided by three to get the interpolant's sampleSize argument.

              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
            };

            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
      return new AnimationClip(name, undefined, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === undefined) return null;
    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

      // if weights are provided on the node, override weights on the mesh.
      if (nodeDef.weights !== undefined) {
        node.traverse(function (o) {
          if (!o.isMesh) return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];

    // reserve node's name before its dependencies, so the root has the intended name.
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
    return function () {
      const pending = [];
      const meshPromise = parser._invokeOne(function (ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== undefined) {
        pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function (ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function (promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function (objects) {
      let node;

      // .isBone isn't in glTF spec. See ._markDefs
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== undefined) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== undefined) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== undefined) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== undefined) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      parser.associations.set(node, {
        type: 'nodes',
        index: nodeIndex
      });
      return node;
    });
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;

    // Loader returns Group, not Scene.
    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
    }
    return Promise.all(pending).then(function () {
      return scene;
    });
  }
}
function buildNodeHierachy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId];
  return parser.getDependency('node', nodeId).then(function (node) {
    if (nodeDef.skin === undefined) return node;

    // build skeleton here as well

    let skinEntry;
    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
      }
      return Promise.all(pendingJoints);
    }).then(function (jointNodes) {
      node.traverse(function (mesh) {
        if (!mesh.isMesh) return;
        const bones = [];
        const boneInverses = [];
        for (let j = 0, jl = jointNodes.length; j < jl; j++) {
          const jointNode = jointNodes[j];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== undefined) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function (node) {
    // build node hierachy

    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i = 0, il = children.length; i < il; i++) {
        const child = children[i];
        pending.push(buildNodeHierachy(child, node, json, parser));
      }
    }
    return Promise.all(pending);
  });
}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== undefined) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;

    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

    if (min !== undefined && max !== undefined) {
      box.set(new three_module_Vector3(min[0], min[1], min[2]), new three_module_Vector3(max[0], max[1], max[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== undefined) {
    const maxDisplacement = new three_module_Vector3();
    const vector = new three_module_Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== undefined) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;

        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

        if (min !== undefined && max !== undefined) {
          // we need to get max of absolute components because target weight is [-1,1]
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }

          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
          // are used to implement key-frame animations and as such only two are active at a time - this results in very large
          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
          maxDisplacement.max(vector);
        } else {
          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
        }
      }
    }

    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();

    // Skip attributes already provided by e.g. Draco extension.
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== undefined && !geometry.index) {
    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
      geometry.setIndex(accessor);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function () {
    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode(geometry, drawMode) {
  let index = geometry.getIndex();

  // generate index if not present

  if (index === null) {
    const indices = [];
    const position = geometry.getAttribute('position');
    if (position !== undefined) {
      for (let i = 0; i < position.count; i++) {
        indices.push(i);
      }
      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
      return geometry;
    }
  }

  //

  const numberOfTriangles = index.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    // gl.TRIANGLE_FAN

    for (let i = 1; i <= numberOfTriangles; i++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(i));
      newIndices.push(index.getX(i + 1));
    }
  } else {
    // gl.TRIANGLE_STRIP

    for (let i = 0; i < numberOfTriangles; i++) {
      if (i % 2 === 0) {
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
        newIndices.push(index.getX(i + 2));
      } else {
        newIndices.push(index.getX(i + 2));
        newIndices.push(index.getX(i + 1));
        newIndices.push(index.getX(i));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
  }

  // build final geometry

  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}

;// CONCATENATED MODULE: ./Renderer/jsm/loaders/RGBELoader.js


// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }

  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

  parse(buffer) {
    const /* return codes for rgbe routines */
      //RGBE_RETURN_SUCCESS = 0,
      RGBE_RETURN_FAILURE = -1,
      /* default error routine.  change this to change error handling */
      rgbe_read_error = 1,
      rgbe_write_error = 2,
      rgbe_format_error = 3,
      rgbe_memory_error = 4,
      rgbe_error = function (rgbe_error_code, msg) {
        switch (rgbe_error_code) {
          case rgbe_read_error:
            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));
            break;
          case rgbe_write_error:
            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));
            break;
          case rgbe_format_error:
            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));
            break;
          default:
          case rgbe_memory_error:
            console.error('THREE.RGBELoader: Error: ' + (msg || ''));
        }
        return RGBE_RETURN_FAILURE;
      },
      /* offsets to red, green, and blue components in a data (float) pixel */
      //RGBE_DATA_RED = 0,
      //RGBE_DATA_GREEN = 1,
      //RGBE_DATA_BLUE = 2,

      /* number of floats per pixel, use 4 since stored in rgba image format */
      //RGBE_DATA_SIZE = 4,

      /* flags indicating which fields in an rgbe_header_info are valid */
      RGBE_VALID_PROGRAMTYPE = 1,
      RGBE_VALID_FORMAT = 2,
      RGBE_VALID_DIMENSIONS = 4,
      NEWLINE = '\n',
      fgets = function (buffer, lineLimit, consume) {
        const chunkSize = 128;
        lineLimit = !lineLimit ? 1024 : lineLimit;
        let p = buffer.pos,
          i = -1,
          len = 0,
          s = '',
          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {
          s += chunk;
          len += chunk.length;
          p += chunkSize;
          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        }
        if (-1 < i) {
          /*for (i=l-1; i>=0; i--) {
          	byteCode = m.charCodeAt(i);
          	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
          	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
          	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
          }*/
          if (false !== consume) buffer.pos += len + i + 1;
          return s + chunk.slice(0, i);
        }
        return false;
      },
      /* minimal header reading.  modify if you want to parse more information */
      RGBE_ReadHeader = function (buffer) {
        // regexes to parse header info fields
        const magic_token_re = /^#\?(\S+)/,
          gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          format_re = /^\s*FORMAT=(\S+)\s*$/,
          dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          // RGBE format header struct
          header = {
            valid: 0,
            /* indicate which fields are valid */

            string: '',
            /* the actual header string */

            comments: '',
            /* comments found in header */

            programtype: 'RGBE',
            /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

            format: '',
            /* RGBE format, default 32-bit_rle_rgbe */

            gamma: 1.0,
            /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

            exposure: 1.0,
            /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

            width: 0,
            height: 0 /* image dimensions, width/height */
          };

        let line, match;
        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {
          return rgbe_error(rgbe_read_error, 'no header found');
        }

        /* if you want to require the magic token then uncomment the next line */
        if (!(match = line.match(magic_token_re))) {
          return rgbe_error(rgbe_format_error, 'bad initial token');
        }
        header.valid |= RGBE_VALID_PROGRAMTYPE;
        header.programtype = match[1];
        header.string += line + '\n';
        while (true) {
          line = fgets(buffer);
          if (false === line) break;
          header.string += line + '\n';
          if ('#' === line.charAt(0)) {
            header.comments += line + '\n';
            continue; // comment line
          }

          if (match = line.match(gamma_re)) {
            header.gamma = parseFloat(match[1], 10);
          }
          if (match = line.match(exposure_re)) {
            header.exposure = parseFloat(match[1], 10);
          }
          if (match = line.match(format_re)) {
            header.valid |= RGBE_VALID_FORMAT;
            header.format = match[1]; //'32-bit_rle_rgbe';
          }

          if (match = line.match(dimensions_re)) {
            header.valid |= RGBE_VALID_DIMENSIONS;
            header.height = parseInt(match[1], 10);
            header.width = parseInt(match[2], 10);
          }
          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
        }
        if (!(header.valid & RGBE_VALID_FORMAT)) {
          return rgbe_error(rgbe_format_error, 'missing format specifier');
        }
        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
          return rgbe_error(rgbe_format_error, 'missing image size specifier');
        }
        return header;
      },
      RGBE_ReadPixels_RLE = function (buffer, w, h) {
        const scanline_width = w;
        if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 0x7fff ||
        // this file is not run length encoded
        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {
          // return the flat buffer
          return new Uint8Array(buffer);
        }
        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {
          return rgbe_error(rgbe_format_error, 'wrong scanline width');
        }
        const data_rgba = new Uint8Array(4 * w * h);
        if (!data_rgba.length) {
          return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');
        }
        let offset = 0,
          pos = 0;
        const ptr_end = 4 * scanline_width;
        const rgbeStart = new Uint8Array(4);
        const scanline_buffer = new Uint8Array(ptr_end);
        let num_scanlines = h;

        // read in each successive scanline
        while (num_scanlines > 0 && pos < buffer.byteLength) {
          if (pos + 4 > buffer.byteLength) {
            return rgbe_error(rgbe_read_error);
          }
          rgbeStart[0] = buffer[pos++];
          rgbeStart[1] = buffer[pos++];
          rgbeStart[2] = buffer[pos++];
          rgbeStart[3] = buffer[pos++];
          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');
          }

          // read each of the four channels for the scanline into the buffer
          // first red, then green, then blue, then exponent
          let ptr = 0,
            count;
          while (ptr < ptr_end && pos < buffer.byteLength) {
            count = buffer[pos++];
            const isEncodedRun = count > 128;
            if (isEncodedRun) count -= 128;
            if (0 === count || ptr + count > ptr_end) {
              return rgbe_error(rgbe_format_error, 'bad scanline data');
            }
            if (isEncodedRun) {
              // a (encoded) run of the same value
              const byteValue = buffer[pos++];
              for (let i = 0; i < count; i++) {
                scanline_buffer[ptr++] = byteValue;
              }
              //ptr += count;
            } else {
              // a literal-run
              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
              ptr += count;
              pos += count;
            }
          }

          // now convert data from buffer into rgba
          // first red, then green, then blue, then exponent (alpha)
          const l = scanline_width; //scanline_buffer.byteLength;
          for (let i = 0; i < l; i++) {
            let off = 0;
            data_rgba[offset] = scanline_buffer[i + off];
            off += scanline_width; //1;
            data_rgba[offset + 1] = scanline_buffer[i + off];
            off += scanline_width; //1;
            data_rgba[offset + 2] = scanline_buffer[i + off];
            off += scanline_width; //1;
            data_rgba[offset + 3] = scanline_buffer[i + off];
            offset += 4;
          }
          num_scanlines--;
        }
        return data_rgba;
      };
    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2.0, e - 128.0) / 255.0;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
    };
    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2.0, e - 128.0) / 255.0;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);
      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);
      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w = rgbe_header_info.width,
        h = rgbe_header_info.height,
        image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, format, type;
        let numElements;
        switch (this.type) {
          case UnsignedByteType:
            data = image_rgba_data;
            format = RGBEFormat; // handled as THREE.RGBAFormat in shaders
            type = UnsignedByteType;
            break;
          case FloatType:
            numElements = image_rgba_data.length / 4 * 3;
            const floatArray = new Float32Array(numElements);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);
            }
            data = floatArray;
            format = RGBFormat;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4 * 3;
            const halfArray = new Uint16Array(numElements);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);
            }
            data = halfArray;
            format = RGBFormat;
            type = HalfFloatType;
            break;
          default:
            console.error('THREE.RGBELoader: unsupported type: ', this.type);
            break;
        }
        return {
          width: w,
          height: h,
          data: data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          format: format,
          type: type
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case UnsignedByteType:
          texture.encoding = RGBEEncoding;
          texture.minFilter = NearestFilter;
          texture.magFilter = NearestFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
        case FloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
        case HalfFloatType:
          texture.encoding = LinearEncoding;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad) onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/utils/RoughnessMipmapper.js
/**
 * This class generates custom mipmaps for a roughness map by encoding the lost variation in the
 * normal map mip levels as increased roughness in the corresponding roughness mip levels. This
 * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when
 * using PMREM. If the normal map is larger than the roughness map, the roughness map will be
 * enlarged to match the dimensions of the normal map.
 */


const _mipmapMaterial = _getMipmapMaterial();
const RoughnessMipmapper_mesh = new three_module_Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);
const RoughnessMipmapper_flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);
let _tempTarget = null;
let _renderer = null;
class RoughnessMipmapper {
  constructor(renderer) {
    _renderer = renderer;
    _renderer.compile(RoughnessMipmapper_mesh, RoughnessMipmapper_flatCamera);
  }
  generateMipmaps(material) {
    if ('roughnessMap' in material === false) return;
    const {
      roughnessMap,
      normalMap
    } = material;
    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) return;
    material.userData.roughnessUpdated = true;
    let width = Math.max(roughnessMap.image.width, normalMap.image.width);
    let height = Math.max(roughnessMap.image.height, normalMap.image.height);
    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return;
    const oldTarget = _renderer.getRenderTarget();
    const autoClear = _renderer.autoClear;
    _renderer.autoClear = false;
    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {
      if (_tempTarget !== null) _tempTarget.dispose();
      _tempTarget = new WebGLRenderTarget(width, height, {
        depthBuffer: false
      });
      _tempTarget.scissorTest = true;
    }
    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {
      const params = {
        wrapS: roughnessMap.wrapS,
        wrapT: roughnessMap.wrapT,
        magFilter: roughnessMap.magFilter,
        minFilter: roughnessMap.minFilter,
        depthBuffer: false
      };
      const newRoughnessTarget = new WebGLRenderTarget(width, height, params);
      newRoughnessTarget.texture.generateMipmaps = true;

      // Setting the render target causes the memory to be allocated.

      _renderer.setRenderTarget(newRoughnessTarget);
      material.roughnessMap = newRoughnessTarget.texture;
      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;
      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;

      // Copy UV transform parameters

      material.roughnessMap.offset.copy(roughnessMap.offset);
      material.roughnessMap.repeat.copy(roughnessMap.repeat);
      material.roughnessMap.center.copy(roughnessMap.center);
      material.roughnessMap.rotation = roughnessMap.rotation;
      material.roughnessMap.matrixAutoUpdate = roughnessMap.matrixAutoUpdate;
      material.roughnessMap.matrix.copy(roughnessMap.matrix);
    }
    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;
    _mipmapMaterial.uniforms.normalMap.value = normalMap;
    const position = new Vector2(0, 0);
    const texelSize = _mipmapMaterial.uniforms.texelSize.value;
    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {
      // Rendering to a mip level is not allowed in webGL1. Instead we must set
      // up a secondary texture to write the result to, then copy it back to the
      // proper mipmap level.

      texelSize.set(1.0 / width, 1.0 / height);
      if (mip == 0) texelSize.set(0.0, 0.0);
      _tempTarget.viewport.set(position.x, position.y, width, height);
      _tempTarget.scissor.set(position.x, position.y, width, height);
      _renderer.setRenderTarget(_tempTarget);
      _renderer.render(RoughnessMipmapper_mesh, RoughnessMipmapper_flatCamera);
      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);
      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();
    _renderer.setRenderTarget(oldTarget);
    _renderer.autoClear = autoClear;
  }
  dispose() {
    _mipmapMaterial.dispose();
    RoughnessMipmapper_mesh.geometry.dispose();
    if (_tempTarget != null) _tempTarget.dispose();
  }
}
function _getMipmapMaterial() {
  const shaderMaterial = new RawShaderMaterial({
    uniforms: {
      roughnessMap: {
        value: null
      },
      normalMap: {
        value: null
      },
      texelSize: {
        value: new Vector2(1, 1)
      }
    },
    vertexShader: /* glsl */`
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`,
    fragmentShader: /* glsl */`
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  shaderMaterial.type = 'RoughnessMipmapper';
  return shaderMaterial;
}

;// CONCATENATED MODULE: ./Renderer/jsm/exporters/GLTFExporter.js

class GLTFExporter {
  constructor() {
    this.pluginCallbacks = [];
    this.register(function (writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function (writer) {
      return new GLTFExporter_GLTFMaterialsUnlitExtension(writer);
    });
    this.register(function (writer) {
      return new GLTFMaterialsPBRSpecularGlossiness(writer);
    });
    this.register(function (writer) {
      return new GLTFExporter_GLTFMaterialsTransmissionExtension(writer);
    });
    this.register(function (writer) {
      return new GLTFExporter_GLTFMaterialsVolumeExtension(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }

  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  parse(input, onDone, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {
      plugins.push(this.pluginCallbacks[i](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options);
  }
}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const GLTFExporter_WEBGL_CONSTANTS = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,
  UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT: 0x1403,
  FLOAT: 0x1406,
  UNSIGNED_INT: 0x1405,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
const THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = GLTFExporter_WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = GLTFExporter_WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = GLTFExporter_WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = GLTFExporter_WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = GLTFExporter_WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = GLTFExporter_WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = GLTFExporter_WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = GLTFExporter_WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = GLTFExporter_WEBGL_CONSTANTS.MIRRORED_REPEAT;
const GLTFExporter_PATH_PROPERTIES = {
  scale: 'scale',
  position: 'translation',
  quaternion: 'rotation',
  morphTargetInfluences: 'weights'
};

// GLB constants
// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

const GLB_HEADER_BYTES = 12;
const GLB_HEADER_MAGIC = 0x46546C67;
const GLB_VERSION = 2;
const GLB_CHUNK_PREFIX_BYTES = 8;
const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
const GLB_CHUNK_TYPE_BIN = 0x004E4942;

//------------------------------------------------------------------------------
// Utility functions
//------------------------------------------------------------------------------

/**
 * Compare two arrays
 * @param  {Array} array1 Array 1 to compare
 * @param  {Array} array2 Array 2 to compare
 * @return {Boolean}        Returns true if both arrays are equal
 */
function equalArray(array1, array2) {
  return array1.length === array2.length && array1.every(function (element, index) {
    return element === array2[index];
  });
}

/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */
function stringToArrayBuffer(text) {
  if (window.TextEncoder !== undefined) {
    return new TextEncoder().encode(text).buffer;
  }
  const array = new Uint8Array(new ArrayBuffer(text.length));
  for (let i = 0, il = text.length; i < il; i++) {
    const value = text.charCodeAt(i);

    // Replacing multi-byte character with space(0x20).
    array[i] = value > 0xFF ? 0x20 : value;
  }
  return array.buffer;
}

/**
 * Is identity matrix
 *
 * @param {Matrix4} matrix
 * @returns {Boolean} Returns true, if parameter is identity matrix
 */
function isIdentityMatrix(matrix) {
  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}

/**
 * Get the min and max vectors from the given attribute
 * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
 * @param  {Integer} start
 * @param  {Integer} count
 * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
 */
function getMinMax(attribute, start, count) {
  const output = {
    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let i = start; i < start + count; i++) {
    for (let a = 0; a < attribute.itemSize; a++) {
      let value;
      if (attribute.itemSize > 4) {
        // no support for interleaved data for itemSize > 4

        value = attribute.array[i * attribute.itemSize + a];
      } else {
        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);
      }
      output.min[a] = Math.min(output.min[a], value);
      output.max[a] = Math.max(output.max[a], value);
    }
  }
  return output;
}

/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */
function getPaddedBufferSize(bufferSize) {
  return Math.ceil(bufferSize / 4) * 4;
}

/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {ArrayBuffer} arrayBuffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */
function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
  if (paddedLength !== arrayBuffer.byteLength) {
    const array = new Uint8Array(paddedLength);
    array.set(new Uint8Array(arrayBuffer));
    if (paddingByte !== 0) {
      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
        array[i] = paddingByte;
      }
    }
    return array.buffer;
  }
  return arrayBuffer;
}
let cachedCanvas = null;

/**
 * Writer
 */
class GLTFWriter {
  constructor() {
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.buffers = [];
    this.nodeMap = new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.uids = new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: '2.0',
        generator: 'THREE.GLTFExporter'
      }
    };
    this.cache = {
      meshes: new Map(),
      attributes: new Map(),
      attributesNormalized: new Map(),
      materials: new Map(),
      textures: new Map(),
      images: new Map()
    };
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }

  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  write(input, onDone, options) {
    this.options = Object.assign({}, {
      // default options
      binary: false,
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true,
      embedImages: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations.length > 0) {
      // Only TRS properties, and not matrices, may be targeted by animation.
      this.options.trs = true;
    }
    this.processInput(input);
    const writer = this;
    Promise.all(this.pending).then(function () {
      const buffers = writer.buffers;
      const json = writer.json;
      const options = writer.options;
      const extensionsUsed = writer.extensionsUsed;

      // Merge buffers.
      const blob = new Blob(buffers, {
        type: 'application/octet-stream'
      });

      // Declare extensions.
      const extensionsUsedList = Object.keys(extensionsUsed);
      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;

      // Update bytelength of the single buffer.
      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;
      if (options.binary === true) {
        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

        const reader = new window.FileReader();
        reader.readAsArrayBuffer(blob);
        reader.onloadend = function () {
          // Binary chunk.
          const binaryChunk = getPaddedArrayBuffer(reader.result);
          const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
          binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
          binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);

          // JSON chunk.
          const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);
          const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
          jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
          jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);

          // GLB header.
          const header = new ArrayBuffer(GLB_HEADER_BYTES);
          const headerView = new DataView(header);
          headerView.setUint32(0, GLB_HEADER_MAGIC, true);
          headerView.setUint32(4, GLB_VERSION, true);
          const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
          headerView.setUint32(8, totalByteLength, true);
          const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
            type: 'application/octet-stream'
          });
          const glbReader = new window.FileReader();
          glbReader.readAsArrayBuffer(glbBlob);
          glbReader.onloadend = function () {
            onDone(glbReader.result);
          };
        };
      } else {
        if (json.buffers && json.buffers.length > 0) {
          const reader = new window.FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = function () {
            const base64data = reader.result;
            json.buffers[0].uri = base64data;
            onDone(json);
          };
        } else {
          onDone(json);
        }
      }
    });
  }

  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0) return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === undefined) objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0) objectDef.extras = json;
    } catch (error) {
      console.warn('THREE.GLTFExporter: userData of \'' + object.name + '\' ' + 'won\'t be serialized because of JSON.stringify error - ' + error.message);
    }
  }

  /**
   * Assign and return a temporal unique id for an object
   * especially which doesn't have .uuid
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(object) {
    if (!this.uids.has(object)) this.uids.set(object, this.uid++);
    return this.uids.get(object);
  }

  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal)) return false;
    const v = new three_module_Vector3();
    for (let i = 0, il = normal.count; i < il; i++) {
      // 0.0005 is from glTF-validator
      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;
    }
    return true;
  }

  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);
    const attribute = normal.clone();
    const v = new three_module_Vector3();
    for (let i = 0, il = attribute.count; i < il; i++) {
      v.fromBufferAttribute(attribute, i);
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        // if values can't be normalized set (1, 0, 0)
        v.setX(1.0);
      } else {
        v.normalize();
      }
      attribute.setXYZ(i, v.x, v.y, v.z);
    }
    cache.attributesNormalized.set(normal, attribute);
    return attribute;
  }

  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(mapDef, texture) {
    let didTransform = false;
    const transformDef = {};
    if (texture.offset.x !== 0 || texture.offset.y !== 0) {
      transformDef.offset = texture.offset.toArray();
      didTransform = true;
    }
    if (texture.rotation !== 0) {
      transformDef.rotation = texture.rotation;
      didTransform = true;
    }
    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
      transformDef.scale = texture.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions['KHR_texture_transform'] = transformDef;
      this.extensionsUsed['KHR_texture_transform'] = true;
    }
  }

  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(buffer) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers) json.buffers = [{
      byteLength: 0
    }];

    // All buffers are merged before export.
    buffers.push(buffer);
    return 0;
  }

  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(attribute, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews) json.bufferViews = [];

    // Create a new dataview and dump the attribute's array into it

    let componentSize;
    if (componentType === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE) {
      componentSize = 1;
    } else if (componentType === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT) {
      componentSize = 2;
    } else {
      componentSize = 4;
    }
    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i = start; i < start + count; i++) {
      for (let a = 0; a < attribute.itemSize; a++) {
        let value;
        if (attribute.itemSize > 4) {
          // no support for interleaved data for itemSize > 4

          value = attribute.array[i * attribute.itemSize + a];
        } else {
          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);
        }
        if (componentType === GLTFExporter_WEBGL_CONSTANTS.FLOAT) {
          dataView.setFloat32(offset, value, true);
        } else if (componentType === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_INT) {
          dataView.setUint32(offset, value, true);
        } else if (componentType === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT) {
          dataView.setUint16(offset, value, true);
        } else if (componentType === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE) {
          dataView.setUint8(offset, value);
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength: byteLength
    };
    if (target !== undefined) bufferViewDef.target = target;
    if (target === GLTFExporter_WEBGL_CONSTANTS.ARRAY_BUFFER) {
      // Only define byteStride for vertex attributes.
      bufferViewDef.byteStride = attribute.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);

    // @TODO Merge bufferViews where possible.
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }

  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews) json.bufferViews = [];
    return new Promise(function (resolve) {
      const reader = new window.FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function () {
        const buffer = getPaddedArrayBuffer(reader.result);
        const bufferViewDef = {
          buffer: writer.processBuffer(buffer),
          byteOffset: writer.byteOffset,
          byteLength: buffer.byteLength
        };
        writer.byteOffset += buffer.byteLength;
        resolve(json.bufferViews.push(bufferViewDef) - 1);
      };
    });
  }

  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(attribute, geometry, start, count) {
    const options = this.options;
    const json = this.json;
    const types = {
      1: 'SCALAR',
      2: 'VEC2',
      3: 'VEC3',
      4: 'VEC4',
      16: 'MAT4'
    };
    let componentType;

    // Detect the component type of the attribute array (float, uint or ushort)
    if (attribute.array.constructor === Float32Array) {
      componentType = GLTFExporter_WEBGL_CONSTANTS.FLOAT;
    } else if (attribute.array.constructor === Uint32Array) {
      componentType = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_INT;
    } else if (attribute.array.constructor === Uint16Array) {
      componentType = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT;
    } else if (attribute.array.constructor === Uint8Array) {
      componentType = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE;
    } else {
      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');
    }
    if (start === undefined) start = 0;
    if (count === undefined) count = attribute.count;

    // @TODO Indexed buffer geometry with drawRange not supported yet
    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {
      const end = start + count;
      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;
      start = Math.max(start, geometry.drawRange.start);
      count = Math.min(end, end2) - start;
      if (count < 0) count = 0;
    }

    // Skip creating an accessor if the attribute doesn't have data to export
    if (count === 0) return null;
    const minMax = getMinMax(attribute, start, count);
    let bufferViewTarget;

    // If geometry isn't provided, don't infer the target usage of the bufferView. For
    // animation samplers, target must not be set.
    if (geometry !== undefined) {
      bufferViewTarget = attribute === geometry.index ? GLTFExporter_WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : GLTFExporter_WEBGL_CONSTANTS.ARRAY_BUFFER;
    }
    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);
    const accessorDef = {
      bufferView: bufferView.id,
      byteOffset: bufferView.byteOffset,
      componentType: componentType,
      count: count,
      max: minMax.max,
      min: minMax.min,
      type: types[attribute.itemSize]
    };
    if (attribute.normalized === true) accessorDef.normalized = true;
    if (!json.accessors) json.accessors = [];
    return json.accessors.push(accessorDef) - 1;
  }

  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)
   * @param  {Boolean} flipY before writing out the image
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(image, format, flipY) {
    const writer = this;
    const cache = writer.cache;
    const json = writer.json;
    const options = writer.options;
    const pending = writer.pending;
    if (!cache.images.has(image)) cache.images.set(image, {});
    const cachedImages = cache.images.get(image);
    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';
    const key = mimeType + ':flipY/' + flipY.toString();
    if (cachedImages[key] !== undefined) return cachedImages[key];
    if (!json.images) json.images = [];
    const imageDef = {
      mimeType: mimeType
    };
    if (options.embedImages) {
      const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext('2d');
      if (flipY === true) {
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
      }
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      } else {
        if (format !== RGBAFormat && format !== RGBFormat) {
          console.error('GLTFExporter: Only RGB and RGBA formats are supported.');
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        if (format === RGBAFormat) {
          for (let i = 0; i < data.length; i += 4) {
            data[i + 0] = image.data[i + 0];
            data[i + 1] = image.data[i + 1];
            data[i + 2] = image.data[i + 2];
            data[i + 3] = image.data[i + 3];
          }
        } else {
          for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {
            data[i + 0] = image.data[j + 0];
            data[i + 1] = image.data[j + 1];
            data[i + 2] = image.data[j + 2];
            data[i + 3] = 255;
          }
        }
        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      }
      if (options.binary === true) {
        pending.push(new Promise(function (resolve) {
          canvas.toBlob(function (blob) {
            writer.processBufferViewImage(blob).then(function (bufferViewIndex) {
              imageDef.bufferView = bufferViewIndex;
              resolve();
            });
          }, mimeType);
        }));
      } else {
        imageDef.uri = canvas.toDataURL(mimeType);
      }
    } else {
      imageDef.uri = image.src;
    }
    const index = json.images.push(imageDef) - 1;
    cachedImages[key] = index;
    return index;
  }

  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(map) {
    const json = this.json;
    if (!json.samplers) json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map.magFilter],
      minFilter: THREE_TO_WEBGL[map.minFilter],
      wrapS: THREE_TO_WEBGL[map.wrapS],
      wrapT: THREE_TO_WEBGL[map.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }

  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(map) {
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map)) return cache.textures.get(map);
    if (!json.textures) json.textures = [];
    const textureDef = {
      sampler: this.processSampler(map),
      source: this.processImage(map.image, map.format, map.flipY)
    };
    if (map.name) textureDef.name = map.name;
    this._invokeAll(function (ext) {
      ext.writeTexture && ext.writeTexture(map, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map, index);
    return index;
  }

  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(material) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material)) return cache.materials.get(material);
    if (material.isShaderMaterial) {
      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');
      return null;
    }
    if (!json.materials) json.materials = [];

    // @QUESTION Should we avoid including any attribute that has the default value?
    const materialDef = {
      pbrMetallicRoughness: {}
    };
    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {
      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');
    }

    // pbrMetallicRoughness.baseColorFactor
    const color = material.color.toArray().concat([material.opacity]);
    if (!equalArray(color, [1, 1, 1, 1])) {
      materialDef.pbrMetallicRoughness.baseColorFactor = color;
    }
    if (material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }

    // pbrMetallicRoughness.metallicRoughnessTexture
    if (material.metalnessMap || material.roughnessMap) {
      if (material.metalnessMap === material.roughnessMap) {
        const metalRoughMapDef = {
          index: this.processTexture(material.metalnessMap)
        };
        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);
        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
      } else {
        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');
      }
    }

    // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture
    if (material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map)
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if (material.emissive) {
      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.
      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 1) {
        emissive.multiplyScalar(1 / maxEmissiveComponent);
        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');
      }
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = emissive.toArray();
      }

      // emissiveTexture
      if (material.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap)
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }

    // normalTexture
    if (material.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap)
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        // glTF normal scale is univariate. Ignore `y`, which may be flipped.
        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }

    // occlusionTexture
    if (material.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: 1
      };
      if (material.aoMapIntensity !== 1.0) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }

    // alphaMode
    if (material.transparent) {
      materialDef.alphaMode = 'BLEND';
    } else {
      if (material.alphaTest > 0.0) {
        materialDef.alphaMode = 'MASK';
        materialDef.alphaCutoff = material.alphaTest;
      }
    }

    // doubleSided
    if (material.side === DoubleSide) materialDef.doubleSided = true;
    if (material.name !== '') materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function (ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }

  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i = 0, l = mesh.material.length; i < l; i++) {
        meshCacheKeyParts.push(mesh.material[i].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(':');
    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);
    const geometry = mesh.geometry;
    let mode;

    // Use the correct mode
    if (mesh.isLineSegments) {
      mode = GLTFExporter_WEBGL_CONSTANTS.LINES;
    } else if (mesh.isLineLoop) {
      mode = GLTFExporter_WEBGL_CONSTANTS.LINE_LOOP;
    } else if (mesh.isLine) {
      mode = GLTFExporter_WEBGL_CONSTANTS.LINE_STRIP;
    } else if (mesh.isPoints) {
      mode = GLTFExporter_WEBGL_CONSTANTS.POINTS;
    } else {
      mode = mesh.material.wireframe ? GLTFExporter_WEBGL_CONSTANTS.LINES : GLTFExporter_WEBGL_CONSTANTS.TRIANGLES;
    }
    if (geometry.isBufferGeometry !== true) {
      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];

    // Conversion between attributes names in threejs and gltf spec
    const nameConversion = {
      uv: 'TEXCOORD_0',
      uv2: 'TEXCOORD_1',
      color: 'COLOR_0',
      skinWeight: 'WEIGHTS_0',
      skinIndex: 'JOINTS_0'
    };
    const originalNormal = geometry.getAttribute('normal');
    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');
      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));
    }

    // @QUESTION Detect if .vertexColors = true?
    // For every attribute create an accessor
    let modifiedAttribute = null;
    for (let attributeName in geometry.attributes) {
      // Ignore morph target attributes, which are exported later.
      if (attributeName.substr(0, 5) === 'morph') continue;
      const attribute = geometry.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();

      // Prefix all geometry attributes except the ones specifically
      // listed in the spec; non-spec attributes are considered custom.
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;
      if (cache.attributes.has(this.getUID(attribute))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
        continue;
      }

      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
      modifiedAttribute = null;
      const array = attribute.array;
      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);
      }
      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);
      if (accessor !== null) {
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute), accessor);
      }
    }
    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal);

    // Skip if no exportable attributes found
    if (Object.keys(attributes).length === 0) return null;

    // Morph targets
    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== undefined) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry.morphAttributes) {
          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
          // Three.js doesn't support TANGENT yet.

          if (attributeName !== 'position' && attributeName !== 'normal') {
            if (!warned) {
              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');
              warned = true;
            }
            continue;
          }
          const attribute = geometry.morphAttributes[attributeName][i];
          const gltfAttributeName = attributeName.toUpperCase();

          // Three.js morph attribute has absolute values while the one of glTF has relative values.
          //
          // glTF 2.0 Specification:
          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

          const baseAttribute = geometry.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));
            continue;
          }

          // Clones attribute not to override
          const relativeAttribute = attribute.clone();
          if (!geometry.morphTargetsRelative) {
            for (let j = 0, jl = attribute.count; j < jl; j++) {
              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));
            }
          }
          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);
          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i]);
        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry.groups.length === 0) return null;
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry.groups : [{
      materialIndex: 0,
      start: undefined,
      count: undefined
    }];
    for (let i = 0, il = groups.length; i < il; i++) {
      const primitive = {
        mode: mode,
        attributes: attributes
      };
      this.serializeUserData(geometry, primitive);
      if (targets.length > 0) primitive.targets = targets;
      if (geometry.index !== null) {
        let cacheKey = this.getUID(geometry.index);
        if (groups[i].start !== undefined || groups[i].count !== undefined) {
          cacheKey += ':' + groups[i].start + ':' + groups[i].count;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null) delete primitive.indices;
      }
      const material = this.processMaterial(materials[groups[i].materialIndex]);
      if (material !== null) primitive.material = material;
      primitives.push(primitive);
    }
    meshDef.primitives = primitives;
    if (!json.meshes) json.meshes = [];
    this._invokeAll(function (ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }

  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras) json.cameras = [];
    const isOrtho = camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? 'orthographic' : 'perspective'
    };
    if (isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 0.001 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 0.001 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }

    // Question: Is saving "type" as name intentional?
    if (camera.name !== '') cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }

  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations) json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i = 0; i < tracks.length; ++i) {
      const track = tracks[i];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = GLTFExporter_PATH_PROPERTIES[trackBinding.propertyName];
      if (trackBinding.objectName === 'bones') {
        if (trackNode.isSkinnedMesh === true) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = undefined;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === GLTFExporter_PATH_PROPERTIES.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;

      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

      // Detecting glTF cubic spline interpolant by checking factory method's special property
      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
      // valid value from .getInterpolation().
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
        interpolation = 'CUBICSPLINE';

        // itemSize of CUBICSPLINE keyframe is 9
        // (VEC3 * 3: inTangent, splineVertex, and outTangent)
        // but needs to be stored as VEC3 so dividing by 3 here.
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = 'STEP';
      } else {
        interpolation = 'LINEAR';
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation: interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || 'clip_' + json.animations.length,
      samplers: samplers,
      channels: channels
    });
    return json.animations.length - 1;
  }

  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    const node = json.nodes[nodeMap.get(object)];
    const skeleton = object.skeleton;
    if (skeleton === undefined) return null;
    const rootJoint = object.skeleton.bones[0];
    if (rootJoint === undefined) return null;
    const joints = [];
    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
    const temporaryBoneInverse = new Matrix4();
    for (let i = 0; i < skeleton.bones.length; ++i) {
      joints.push(nodeMap.get(skeleton.bones[i]));
      temporaryBoneInverse.copy(skeleton.boneInverses[i]);
      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);
    }
    if (json.skins === undefined) json.skins = [];
    json.skins.push({
      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
      joints: joints,
      skeleton: nodeMap.get(rootJoint)
    });
    const skinIndex = node.skin = json.skins.length - 1;
    return skinIndex;
  }

  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes) json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (isIdentityMatrix(object.matrix) === false) {
        nodeDef.matrix = object.matrix.elements;
      }
    }

    // We don't export empty strings name because it represents no-name in Three.js.
    if (object.name !== '') nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if (object.isMesh || object.isLine || object.isPoints) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null) nodeDef.mesh = meshIndex;
    } else if (object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object.isSkinnedMesh) this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i = 0, l = object.children.length; i < l; i++) {
        const child = object.children[i];
        if (child.visible || options.onlyVisible === false) {
          const nodeIndex = this.processNode(child);
          if (nodeIndex !== null) children.push(nodeIndex);
        }
      }
      if (children.length > 0) nodeDef.children = children;
    }
    this._invokeAll(function (ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }

  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== '') sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i = 0, l = scene.children.length; i < l; i++) {
      const child = scene.children[i];
      if (child.visible || options.onlyVisible === false) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null) nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0) sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }

  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(objects) {
    const scene = new Scene();
    scene.name = 'AuxScene';
    for (let i = 0; i < objects.length; i++) {
      // We push directly to children instead of calling `add` to prevent
      // modify the .parent and break its original scene and hierarchy
      scene.children.push(objects[i]);
    }
    this.processScene(scene);
  }

  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function (ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i = 0; i < input.length; i++) {
      if (input[i] instanceof Scene) {
        this.processScene(input[i]);
      } else {
        objectsWithoutScene.push(input[i]);
      }
    }
    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);
    for (let i = 0; i < this.skins.length; ++i) {
      this.processSkin(this.skins[i]);
    }
    for (let i = 0; i < options.animations.length; ++i) {
      this.processAnimation(options.animations[i], input[0]);
    }
    this._invokeAll(function (ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i = 0, il = this.plugins.length; i < il; i++) {
      func(this.plugins[i]);
    }
  }
}

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = 'KHR_lights_punctual';
  }
  writeNode(light, nodeDef) {
    if (!light.isLight) return;
    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name) lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light.isDirectionalLight) {
      lightDef.type = 'directional';
    } else if (light.isPointLight) {
      lightDef.type = 'point';
      if (light.distance > 0) lightDef.range = light.distance;
    } else if (light.isSpotLight) {
      lightDef.type = 'spot';
      if (light.distance > 0) lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (light.decay !== undefined && light.decay !== 2) {
      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');
    }
    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = {
        lights: []
      };
      extensionsUsed[this.name] = true;
    }
    const lights = json.extensions[this.name].lights;
    lights.push(lightDef);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = {
      light: lights.length - 1
    };
  }
}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFExporter_GLTFMaterialsUnlitExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = 'KHR_materials_unlit';
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshBasicMaterial) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */
class GLTFMaterialsPBRSpecularGlossiness {
  constructor(writer) {
    this.writer = writer;
    this.name = 'KHR_materials_pbrSpecularGlossiness';
  }
  writeMaterial(material, materialDef) {
    if (!material.isGLTFSpecularGlossinessMaterial) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (materialDef.pbrMetallicRoughness.baseColorFactor) {
      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;
    }
    const specularFactor = [1, 1, 1];
    material.specular.toArray(specularFactor, 0);
    extensionDef.specularFactor = specularFactor;
    extensionDef.glossinessFactor = material.glossiness;
    if (materialDef.pbrMetallicRoughness.baseColorTexture) {
      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;
    }
    if (material.specularMap) {
      const specularMapDef = {
        index: writer.processTexture(material.specularMap)
      };
      writer.applyTextureTransform(specularMapDef, material.specularMap);
      extensionDef.specularGlossinessTexture = specularMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 */
class GLTFExporter_GLTFMaterialsTransmissionExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = 'KHR_materials_transmission';
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap)
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFExporter_GLTFMaterialsVolumeExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = 'KHR_materials_volume';
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.thickness === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thicknessFactor = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap)
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material.attenuationDistance;
    extensionDef.attenuationColor = material.attenuationTint.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
}

/**
 * Static utility functions
 */
GLTFExporter.Utils = {
  insertKeyframe: function (track, time) {
    const tolerance = 0.001; // 1ms
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i = 0; i < valueSize; i++) {
        values[i] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance) return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i = 0; i < track.times.length; i++) {
        if (Math.abs(track.times[i] - time) < tolerance) return i;
        if (track.times[i] < time && track.times[i + 1] > time) {
          times.set(track.times.slice(0, i + 1), 0);
          times[i + 1] = time;
          times.set(track.times.slice(i + 1), i + 2);
          values.set(track.values.slice(0, (i + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i + 1) * valueSize);
          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);
          index = i + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function (clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i = 0; i < sourceTracks.length; ++i) {
      let sourceTrack = sourceTracks[i];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {
        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          // This should never happen, because glTF morph target animations
          // affect all targets already.
          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');
        }
        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === undefined) {
        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;

      // If this is the first time we've seen this object, create a new
      // track to store merged keyframe data for each morph target.
      if (mergedTracks[sourceTrackNode.uuid] === undefined) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j = 0; j < mergedTrack.times.length; j++) {
          values[j * targetCount + targetIndex] = mergedTrack.values[j];
        }

        // We need to take into consideration the intended target node
        // of our original un-merged morphTarget animation.
        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];

      // For every existing keyframe of the merged track, write a (possibly
      // interpolated) value from the source track.
      for (let j = 0; j < mergedTrack.times.length; j++) {
        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
      }

      // For every existing keyframe of the source track, write a (possibly
      // new) keyframe to the merged track. Values from the previous loop may
      // be written again, but keyframes are de-duplicated.
      for (let j = 0; j < sourceTrack.times.length; j++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
};

;// CONCATENATED MODULE: ./Renderer/Global.js
var _meshQuality = 1;
var _cameraOrthoAxisSize = 1.8;
var _cameraPersfAxisSize = 0.001;
;// CONCATENATED MODULE: ./Renderer/AxisGeom.js




/**
 * 좌표축 Geometry 클래스
 * */
class AxisGeom {
  /**
   * 클래스 생성자
   * @param {Renderer} renderer 렌더러 참조
   */
  constructor(renderer) {
    this._renderer = renderer;
    this._xp = null;
    this._yp = null;
    this._zp = null;
    this._vPos = new Vector4(-0.9, -0.9, -0.9, 1);
  }

  /**
  * axis mesh를 현재 카메라를 기준으로 화면의 우측 하단에 위치 시킨다. 
  */
  updateAxisMesh() {
    if (!this._renderer._isOrthoCamera) {
      /*
      this._renderer._raycaster.setFromCamera(new THREE.Vector2(0.5, 0.5), this._renderer._camera);
        var width = this._renderer._div.clientWidth;
      var height = this._renderer._div.clientHeight;
      var aspect = width / height;
        var fov = this._renderer._camera.fov;
      var cz = 20;
      var cx = cz * Math.tan(fov * Math.PI / 180 / 2) * 0.95 * aspect;
      var cy = cz * Math.tan(fov * Math.PI / 180 / 2) * 0.93;
        var forward = new THREE.Vector3(0, 0, 1);
      forward.applyQuaternion(this._renderer._camera.quaternion);
      var right = new THREE.Vector3(1, 0, 0);
      right.applyQuaternion(this._renderer._camera.quaternion);
      var up = new THREE.Vector3(0, 1, 0);
      up.applyQuaternion(this._renderer._camera.quaternion);
        right.multiplyScalar(-cx);
      up.multiplyScalar(-cy);
      forward.multiplyScalar(-cz);
      var pos = new THREE.Vector3();
      pos.copy(this._renderer._camera.position);
        pos.add(right);
      pos.add(up);
      pos.add(forward);
          this._renderer._axisMesh.position.copy(pos);
      */
      // orthogonal camera
      this._renderer._camera.updateProjectionMatrix();
      let pmat = this._renderer._camera.projectionMatrixInverse;
      let pos = this._vPos.clone();
      pos.applyMatrix4(pmat);
      this._renderer._camera.updateMatrixWorld();
      let mvmat = this._renderer._camera.matrixWorld;
      pos.applyMatrix4(mvmat);
      pos.divideScalar(pos.w);
      this._renderer._axisMesh.position.fromArray([pos.x, pos.y, pos.z]);
      this._renderer._axisMesh.scale.fromArray([_cameraPersfAxisSize, _cameraPersfAxisSize, _cameraPersfAxisSize]);
      this._renderer._axisMesh.updateMatrixWorld(true);
      this._aCenter = new three_module_Vector3();
      this._renderer._axisMesh.getWorldPosition(this._aCenter);
      this._apx = new three_module_Vector3(8, 0, 0).applyMatrix4(this._renderer._axisMesh.matrixWorld);
      this._apy = new three_module_Vector3(0, 8, 0).applyMatrix4(this._renderer._axisMesh.matrixWorld);
      this._apz = new three_module_Vector3(0, 0, 8).applyMatrix4(this._renderer._axisMesh.matrixWorld);
    } else {
      // orthogonal camera
      this._renderer._camera.updateProjectionMatrix();
      let pmat = this._renderer._camera.projectionMatrixInverse;
      let pos = this._vPos.clone();
      pos.applyMatrix4(pmat);
      this._renderer._camera.updateMatrixWorld();
      let mvmat = this._renderer._camera.matrixWorld;
      pos.applyMatrix4(mvmat);
      pos.divideScalar(pos.w);
      let size = _cameraOrthoAxisSize / this._renderer._camera.zoom;
      //rayLog(3, "camera : " + this._renderer._camera.zoom);

      //size = 1.01;
      this._renderer._axisMesh.position.fromArray([pos.x, pos.y, pos.z]);
      this._renderer._axisMesh.scale.fromArray([size, size, size]);
      let t = 32;
      this._aCenter = new three_module_Vector3();
      this._renderer._axisMesh.getWorldPosition(this._aCenter);
      this._apx = new three_module_Vector3(8, 0, 0).applyMatrix4(this._renderer._axisMesh.matrixWorld);
      this._apy = new three_module_Vector3(0, 8, 0).applyMatrix4(this._renderer._axisMesh.matrixWorld);
      this._apz = new three_module_Vector3(0, 0, 8).applyMatrix4(this._renderer._axisMesh.matrixWorld);
    }
  }

  /**
  * Axis를 그릴 geometry를 cone, cylinder 를 사용하여 생성한다.  
  * @returns 생성된 Three.js Mesh 클래스를 리턴
  */
  createAxisGeometry() {
    let geometryArrow, meshXArrow, geometryXAxis, materialXAxis, meshXAxis, meshYArrow, geometryYAxis, materialYAxis, meshYAxis, meshZArrow, geometryZAxis, materialZAxis, meshZAxis, radius, height;
    let params = null;
    // This function allows for the changing of parameters for all the axis helpers. I have used .2 as radius
    // and 10 for height for this assignment because it makes the helpers the most visible for my scene
    if (params == null) {
      params = {};
    }
    if (!radius) radius = 0.1;
    if (!height) height = 5;
    let scene = this._renderer._scene;
    geometryArrow = new CylinderGeometry(0, 7 * radius, height / 3, 32);

    // This part defines and adds the X axis helper
    materialXAxis = new MeshBasicMaterial({
      color: 0xFF0000
    });
    geometryXAxis = new CylinderGeometry(radius, radius, height, 32);
    meshXAxis = new three_module_Mesh(geometryXAxis, materialXAxis);
    meshXArrow = new three_module_Mesh(geometryArrow, materialXAxis);
    meshXAxis.add(meshXArrow);
    meshXArrow.position.y += height / 2; // 원뿔에 한해서 위치 조정
    meshXAxis.rotation.z -= 90 * Math.PI / 180; // z 축에 대해서 -90도 회전
    meshXAxis.position.x += height / 2; // 화살표 위치 조정 

    // This part defines and adds the Y axis helper
    materialYAxis = new MeshBasicMaterial({
      color: 0x00FF00
    });
    geometryYAxis = new CylinderGeometry(radius, radius, height, 32);
    meshYAxis = new three_module_Mesh(geometryYAxis, materialYAxis);
    meshYArrow = new three_module_Mesh(geometryArrow, materialYAxis);
    meshYAxis.add(meshYArrow);
    meshYArrow.position.y += height / 2;
    meshYAxis.position.y += height / 2;

    // This part defines and adds the Z axis helper
    materialZAxis = new MeshBasicMaterial({
      color: 0x0000FF
    });
    geometryZAxis = new CylinderGeometry(radius, radius, height, 32);
    meshZAxis = new three_module_Mesh(geometryZAxis, materialZAxis);
    meshZArrow = new three_module_Mesh(geometryArrow, materialZAxis);
    meshZAxis.add(meshZArrow);
    meshZAxis.rotation.x += 90 * Math.PI / 180;
    meshZArrow.position.y += height / 2;
    meshZAxis.position.z += height / 2;
    this._renderer._axisMesh = new Group();
    this._renderer._axisMesh.add(meshXAxis);
    this._renderer._axisMesh.add(meshYAxis);
    this._renderer._axisMesh.add(meshZAxis);
    this._renderer._axisMesh.position.set(0, 0, 0);
    this._renderer._axisMesh.scale.set(0.1, 0.1, 0.1);
    this._renderer._axisMesh.name = "axis mesh";
    return this._renderer._axisMesh;
  }

  /**
   * 축 모델을 생성한다.
   * @param {Number} radius 반지름
   * @param {Number} height 길이
   */
  createAxis(radius, height) {
    let geometryArrow, meshXArrow, geometryXAxis, materialXAxis, meshXAxis, meshYArrow, geometryYAxis, materialYAxis, meshYAxis, meshZArrow, geometryZAxis, materialZAxis, meshZAxis;
    let params = null;
    // This function allows for the changing of parameters for all the axis helpers. I have used .2 as radius
    // and 10 for height for this assignment because it makes the helpers the most visible for my scene
    if (params == null) {
      params = {};
    }
    if (!radius) radius = 1;
    if (!height) height = 10;
    let scene = this._renderer._scene;
    geometryArrow = new CylinderGeometry(0, 2 * radius, height / 5, 32);

    // This part defines and adds the X axis helper
    materialXAxis = new MeshBasicMaterial({
      color: 0xFF0000
    });
    geometryXAxis = new CylinderGeometry(radius, radius, height, 32);
    meshXAxis = new three_module_Mesh(geometryXAxis, materialXAxis);
    meshXArrow = new three_module_Mesh(geometryArrow, materialXAxis);
    meshXAxis.add(meshXArrow);
    meshXArrow.position.y += height / 2; // 원뿔에 한해서 위치 조정
    meshXAxis.rotation.z -= 90 * Math.PI / 180; // z 축에 대해서 -90도 회전
    meshXAxis.position.x += height / 2; // 화살표 위치 조정 
    scene.add(meshXAxis);

    // This part defines and adds the Y axis helper
    materialYAxis = new MeshBasicMaterial({
      color: 0x00FF00
    });
    geometryYAxis = new CylinderGeometry(radius, radius, height, 32);
    meshYAxis = new three_module_Mesh(geometryYAxis, materialYAxis);
    meshYArrow = new three_module_Mesh(geometryArrow, materialYAxis);
    meshYAxis.add(meshYArrow);
    meshYArrow.position.y += height / 2;
    meshYAxis.position.y += height / 2;
    scene.add(meshYAxis);

    // This part defines and adds the Z axis helper
    materialZAxis = new MeshBasicMaterial({
      color: 0x0000FF
    });
    geometryZAxis = new CylinderGeometry(radius, radius, height, 32);
    meshZAxis = new three_module_Mesh(geometryZAxis, materialZAxis);
    meshZArrow = new three_module_Mesh(geometryArrow, materialZAxis);
    meshZAxis.add(meshZArrow);
    meshZAxis.rotation.x += 90 * Math.PI / 180;
    meshZArrow.position.y += height / 2;
    meshZAxis.position.z += height / 2;
    scene.add(meshZAxis);
  }

  /**
   * X, Y, Z 벡터를 사용하여 축 모델을 생성한다.
   * @param {THREE.Vector3} vector_x x축 벡터
   * @param {THREE.Vector3} vector_y y축 벡터
   * @param {THREE.Vector3} vector_z z축 벡터
   * @returns {THREE.Mesh} 모델 메쉬
   */
  createAxisMeshWithVectors(vector_x = new three_module_Vector3(1, 0, 0), vector_y = new three_module_Vector3(0, 1, 0), vector_z = new three_module_Vector3(0, 0, 1)) {
    let radius, height;
    if (!radius) radius = 0.1;
    if (!height) height = 5;
    let nx = vector_x.clone().normalize();
    let ny = vector_y.clone().normalize();
    let nz = vector_z.clone().normalize();

    // y축으로 부터의 quaternion을 구한다.
    let standard = new three_module_Vector3(0, 1, 0);
    let quaternionX = new Quaternion();
    quaternionX.setFromUnitVectors(standard.clone(), nx.clone());
    let quaternionY = new Quaternion();
    quaternionY.setFromUnitVectors(standard.clone(), ny.clone());
    let quaternionZ = new Quaternion();
    quaternionZ.setFromUnitVectors(standard.clone(), nz.clone());
    let geometryXAxis = new CylinderGeometry(radius, radius, height, 32);
    let geometryXArrow = new CylinderGeometry(0, 7 * radius, height / 5, 32);
    //let geometryXLabel = new THREE.SphereBufferGeometry(radius, 15, 15);

    let geometryYAxis = new CylinderGeometry(radius, radius, height, 32);
    let geometryYArrow = new CylinderGeometry(0, 7 * radius, height / 5, 32);
    //let geometryYLabel = new THREE.SphereBufferGeometry(radius, 15, 15);

    let geometryZAxis = new CylinderGeometry(radius, radius, height, 32);
    let geometryZArrow = new CylinderGeometry(0, 7 * radius, height / 5, 32);
    //let geometryZLabel = new THREE.SphereBufferGeometry(radius, 15, 15);

    let materialX = new MeshBasicMaterial({
      color: 0xff0000
    });
    let materialY = new MeshBasicMaterial({
      color: 0x00ff00
    });
    let materialZ = new MeshBasicMaterial({
      color: 0x0000ff
    });
    let meshXAxis = new three_module_Mesh(geometryXAxis, materialX);
    let meshXArrow = new three_module_Mesh(geometryXArrow, materialX);
    //let meshXLabel = new THREE.Mesh(geometryXLabel, materialX);

    meshXAxis.add(meshXArrow);
    //meshXAxis.add(meshXLabel);
    meshXArrow.position.y += height / 2;
    //meshXLabel.position.y += height;
    meshXAxis.applyQuaternion(quaternionX);
    meshXAxis.position.add(nx.clone().multiplyScalar(height / 2));
    //this._meshXLabel = meshXLabel;

    let meshYAxis = new three_module_Mesh(geometryYAxis, materialY);
    let meshYArrow = new three_module_Mesh(geometryYArrow, materialY);
    meshYAxis.add(meshYArrow);
    meshYArrow.position.y += height / 2;
    meshYAxis.applyQuaternion(quaternionY);
    meshYAxis.position.add(ny.clone().multiplyScalar(height / 2));
    let meshZAxis = new three_module_Mesh(geometryZAxis, materialZ);
    let meshZArrow = new three_module_Mesh(geometryZArrow, materialZ);
    meshZAxis.add(meshZArrow);
    meshZArrow.position.y += height / 2;
    meshZAxis.applyQuaternion(quaternionZ);
    meshZAxis.position.add(nz.clone().multiplyScalar(height / 2));
    this._renderer._axisMesh = new Group();
    this._renderer._axisMesh.add(meshXAxis);
    this._renderer._axisMesh.add(meshYAxis);
    this._renderer._axisMesh.add(meshZAxis);
    this._renderer._axisMesh.position.set(0, 0, 0);
    this._renderer._axisMesh.scale.set(0.1, 0.1, 0.1);
    this._renderer._axisMesh.name = "axis mesh";
    this._nx = vector_x.clone().normalize();
    this._ny = vector_y.clone().normalize();
    this._nz = vector_z.clone().normalize();
    return this._renderer._axisMesh;
  }

  /**
   * x축 끝점 좌표를 반환한다.
   * @returns {THREE.Vector3} x축 끝점 좌표
   * */
  getXPoint() {
    return this._renderer._axisMesh.position.clone().add(this._nx);
  }

  /**
   * y축 끝점 좌표를 반환한다.
   * @returns {THREE.Vector3} y축 끝점 좌표
   * */
  getYPoint() {
    return this._renderer._axisMesh.position.clone().add(this._ny);
  }

  /**
   * z축 끝점 좌표를 반환한다.
   * @returns {THREE.Vector3} z축 끝점 좌표
   * */
  getZPoint() {
    return this._renderer._axisMesh.position.clone().add(this._nz);
  }

  /**
   * Axis 렌더링 뷰포트 위치를 지정한다.
   * @param {Number} x 뷰포트 x값
   * @param {Number} y 뷰포트 y값
   * @param {Number} z 뷰포트 z값
   * @param {Number} w 뷰포트 w값
   */
  setViewportPosition(x, y, z, w) {
    this._vPos = new Vector4(x, y, z, w);
  }
}
;// CONCATENATED MODULE: ./Renderer/jsm/math/Lut.js

class Lut {
  constructor(colormap, count = 32) {
    this.lut = [];
    this.map = [];
    this.n = 0;
    this.minV = 0;
    this.maxV = 1;
    this.setColorMap(colormap, count);
  }
  set(value) {
    if (value.isLut === true) {
      this.copy(value);
    }
    return this;
  }
  setMin(min) {
    this.minV = min;
    return this;
  }
  setMax(max) {
    this.maxV = max;
    return this;
  }
  setColorMap(colormap, count = 32) {
    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
    this.n = count;
    const step = 1.0 / this.n;
    this.lut.length = 0;
    for (let i = 0; i <= 1; i += step) {
      for (let j = 0; j < this.map.length - 1; j++) {
        if (i >= this.map[j][0] && i < this.map[j + 1][0]) {
          const min = this.map[j][0];
          const max = this.map[j + 1][0];
          const minColor = new Color(this.map[j][1]);
          const maxColor = new Color(this.map[j + 1][1]);
          const color = minColor.lerp(maxColor, (i - min) / (max - min));
          this.lut.push(color);
        }
      }
    }
    return this;
  }
  copy(lut) {
    this.lut = lut.lut;
    this.map = lut.map;
    this.n = lut.n;
    this.minV = lut.minV;
    this.maxV = lut.maxV;
    return this;
  }
  getColor(alpha) {
    if (alpha <= this.minV) {
      alpha = this.minV;
    } else if (alpha >= this.maxV) {
      alpha = this.maxV;
    }
    alpha = (alpha - this.minV) / (this.maxV - this.minV);
    let colorPosition = Math.round(alpha * this.n);
    colorPosition == this.n ? colorPosition -= 1 : colorPosition;
    return this.lut[colorPosition];
  }
  addColorMap(name, arrayOfColors) {
    ColorMapKeywords[name] = arrayOfColors;
    return this;
  }
  createCanvas() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = this.n;
    this.updateCanvas(canvas);
    return canvas;
  }
  updateCanvas(canvas) {
    const ctx = canvas.getContext('2d', {
      alpha: false
    });
    const imageData = ctx.getImageData(0, 0, 1, this.n);
    const data = imageData.data;
    let k = 0;
    const step = 1.0 / this.n;
    for (let i = 1; i >= 0; i -= step) {
      for (let j = this.map.length - 1; j >= 0; j--) {
        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {
          const min = this.map[j - 1][0];
          const max = this.map[j][0];
          const minColor = new Color(this.map[j - 1][1]);
          const maxColor = new Color(this.map[j][1]);
          const color = minColor.lerp(maxColor, (i - min) / (max - min));
          data[k * 4] = Math.round(color.r * 255);
          data[k * 4 + 1] = Math.round(color.g * 255);
          data[k * 4 + 2] = Math.round(color.b * 255);
          data[k * 4 + 3] = 255;
          k += 1;
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
}
Lut.prototype.isLut = true;
const ColorMapKeywords = {
  'rainbow': [[0.0, 0x0000FF], [0.2, 0x00FFFF], [0.5, 0x00FF00], [0.8, 0xFFFF00], [1.0, 0xFF0000]],
  'cooltowarm': [[0.0, 0x3C4EC2], [0.2, 0x9BBCFF], [0.5, 0xDCDCDC], [0.8, 0xF6A385], [1.0, 0xB40426]],
  'blackbody': [[0.0, 0x000000], [0.2, 0x780000], [0.5, 0xE63200], [0.8, 0xFFFF00], [1.0, 0xFFFFFF]],
  'grayscale': [[0.0, 0x000000], [0.2, 0x404040], [0.5, 0x7F7F80], [0.8, 0xBFBFBF], [1.0, 0xFFFFFF]]
};

;// CONCATENATED MODULE: ./Renderer/jsm/shaders/CopyShader.js
/**
 * Full-screen textured quad shader
 */

var CopyShader = {
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'opacity': {
      value: 1.0
    }
  },
  vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`
};

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/Pass.js

class Pass {
  constructor() {
    // if set to true, the pass is processed by the composer
    this.enabled = true;

    // if set to true, the pass indicates to swap read and write buffer after rendering
    this.needsSwap = true;

    // if set to true, the pass clears its buffer before rendering
    this.clear = false;

    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
    this.renderToScreen = false;
  }
  setSize( /* width, height */) {}
  render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
  ) {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}

// Helper for passes that need to fill the viewport with a single quad.

const Pass_camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

// https://github.com/mrdoob/three.js/pull/21358

const Pass_geometry = new BufferGeometry();
Pass_geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
Pass_geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
class FullScreenQuad {
  constructor(material) {
    this._mesh = new three_module_Mesh(Pass_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, Pass_camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/ShaderPass.js


class ShaderPass extends Pass {
  constructor(shader, textureID) {
    super();
    this.textureID = textureID !== undefined ? textureID : 'tDiffuse';
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/MaskPass.js

class MaskPass extends Pass {
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
    const context = renderer.getContext();
    const state = renderer.state;

    // don't update color or depth

    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);

    // lock buffers

    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);

    // set up stencil

    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);

    // draw into the stencil buffer

    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);

    // unlock color and depth buffer for subsequent rendering

    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);

    // only render where stencil is set to 1

    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
}
class ClearMaskPass extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/EffectComposer.js





class EffectComposer {
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    if (renderTarget === undefined) {
      const parameters = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      };
      const size = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
      renderTarget.texture.name = 'EffectComposer.rt1';
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = 'EffectComposer.rt2';
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];

    // dependencies

    if (CopyShader === undefined) {
      console.error('THREE.EffectComposer relies on CopyShader');
    }
    if (ShaderPass === undefined) {
      console.error('THREE.EffectComposer relies on ShaderPass');
    }
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    // deltaTime value is in seconds

    if (deltaTime === undefined) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false) continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;

          //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
          stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

          //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
          stencil.setFunc(context.EQUAL, 1, 0xffffffff);
        }
        this.swapBuffers();
      }
      if (MaskPass !== undefined) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === undefined) {
      const size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
}
class EffectComposer_Pass {
  constructor() {
    // if set to true, the pass is processed by the composer
    this.enabled = true;

    // if set to true, the pass indicates to swap read and write buffer after rendering
    this.needsSwap = true;

    // if set to true, the pass clears its buffer before rendering
    this.clear = false;

    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
    this.renderToScreen = false;
  }
  setSize( /* width, height */) {}
  render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
  ) {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}

// Helper for passes that need to fill the viewport with a single quad.

const EffectComposer_camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

// https://github.com/mrdoob/three.js/pull/21358

const EffectComposer_geometry = new BufferGeometry();
EffectComposer_geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
EffectComposer_geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
class EffectComposer_FullScreenQuad {
  constructor(material) {
    this._mesh = new Mesh(EffectComposer_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, EffectComposer_camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/math/SimplexNoise.js
// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com
//
// Added 4D noise

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
class SimplexNoise {
  constructor(r = Math) {
    this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
    this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
    this.p = [];
    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(r.random() * 256);
    }

    // To remove the need for index wrapping, double the permutation table length
    this.perm = [];
    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }

    // A lookup table to traverse the simplex around a given point in 4D.
    // Details can be found where this table is used, in the 4D noise method.
    this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
  }
  dot(g, x, y) {
    return g[0] * x + g[1] * y;
  }
  dot3(g, x, y, z) {
    return g[0] * x + g[1] * y + g[2] * z;
  }
  dot4(g, x, y, z, w) {
    return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
  }
  noise(xin, yin) {
    let n0; // Noise contributions from the three corners
    let n1;
    let n2;
    // Skew the input space to determine which simplex cell we're in
    const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
    const s = (xin + yin) * F2; // Hairy factor for 2D
    const i = Math.floor(xin + s);
    const j = Math.floor(yin + s);
    const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
    const t = (i + j) * G2;
    const X0 = i - t; // Unskew the cell origin back to (x,y) space
    const Y0 = j - t;
    const x0 = xin - X0; // The x,y distances from the cell origin
    const y0 = yin - Y0;

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    let i1; // Offsets for second (middle) corner of simplex in (i,j) coords

    let j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;

      // lower triangle, XY order: (0,0)->(1,0)->(1,1)
    } else {
      i1 = 0;
      j1 = 1;
    } // upper triangle, YX order: (0,0)->(0,1)->(1,1)

    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
    const y2 = y0 - 1.0 + 2.0 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    const ii = i & 255;
    const jj = j & 255;
    const gi0 = this.perm[ii + this.perm[jj]] % 12;
    const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
    const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
    // Calculate the contribution from the three corners
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0.0;else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
    }

    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0.0;else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) n2 = 0.0;else {
      t2 *= t2;
      n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
    }

    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70.0 * (n0 + n1 + n2);
  }

  // 3D simplex noise
  noise3d(xin, yin, zin) {
    let n0; // Noise contributions from the four corners
    let n1;
    let n2;
    let n3;
    // Skew the input space to determine which simplex cell we're in
    const F3 = 1.0 / 3.0;
    const s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
    const i = Math.floor(xin + s);
    const j = Math.floor(yin + s);
    const k = Math.floor(zin + s);
    const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
    const t = (i + j + k) * G3;
    const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
    const Y0 = j - t;
    const Z0 = k - t;
    const x0 = xin - X0; // The x,y,z distances from the cell origin
    const y0 = yin - Y0;
    const z0 = zin - Z0;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    let i1; // Offsets for second corner of simplex in (i,j,k) coords

    let j1;
    let k1;
    let i2; // Offsets for third corner of simplex in (i,j,k) coords
    let j2;
    let k2;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;

        // X Y Z order
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 0;
        k2 = 1;

        // X Z Y order
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      } // Z X Y order
    } else {
      // x0<y0

      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 0;
        j2 = 1;
        k2 = 1;

        // Z Y X order
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 0;
        j2 = 1;
        k2 = 1;

        // Y Z X order
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      } // Y X Z order
    }

    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
    const y1 = y0 - j1 + G3;
    const z1 = z0 - k1 + G3;
    const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
    const y2 = y0 - j2 + 2.0 * G3;
    const z2 = z0 - k2 + 2.0 * G3;
    const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
    const y3 = y0 - 1.0 + 3.0 * G3;
    const z3 = z0 - 1.0 + 3.0 * G3;
    // Work out the hashed gradient indices of the four simplex corners
    const ii = i & 255;
    const jj = j & 255;
    const kk = k & 255;
    const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
    const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
    const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
    const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
    // Calculate the contribution from the four corners
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0) n0 = 0.0;else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0) n1 = 0.0;else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
    }
    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t2 < 0) n2 = 0.0;else {
      t2 *= t2;
      n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0) n3 = 0.0;else {
      t3 *= t3;
      n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
    }

    // Add contributions from each corner to get the final noise value.
    // The result is scaled to stay just inside [-1,1]
    return 32.0 * (n0 + n1 + n2 + n3);
  }

  // 4D simplex noise
  noise4d(x, y, z, w) {
    // For faster and easier lookups
    const grad4 = this.grad4;
    const simplex = this.simplex;
    const perm = this.perm;

    // The skewing and unskewing factors are hairy again for the 4D case
    const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
    const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
    let n0; // Noise contributions from the five corners
    let n1;
    let n2;
    let n3;
    let n4;
    // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
    const s = (x + y + z + w) * F4; // Factor for 4D skewing
    const i = Math.floor(x + s);
    const j = Math.floor(y + s);
    const k = Math.floor(z + s);
    const l = Math.floor(w + s);
    const t = (i + j + k + l) * G4; // Factor for 4D unskewing
    const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
    const Y0 = j - t;
    const Z0 = k - t;
    const W0 = l - t;
    const x0 = x - X0; // The x,y,z,w distances from the cell origin
    const y0 = y - Y0;
    const z0 = z - Z0;
    const w0 = w - W0;

    // For the 4D case, the simplex is a 4D shape I won't even try to describe.
    // To find out which of the 24 possible simplices we're in, we need to
    // determine the magnitude ordering of x0, y0, z0 and w0.
    // The method below is a good way of finding the ordering of x,y,z,w and
    // then find the correct traversal order for the simplex we’re in.
    // First, six pair-wise comparisons are performed between each possible pair
    // of the four coordinates, and the results are used to add up binary bits
    // for an integer index.
    const c1 = x0 > y0 ? 32 : 0;
    const c2 = x0 > z0 ? 16 : 0;
    const c3 = y0 > z0 ? 8 : 0;
    const c4 = x0 > w0 ? 4 : 0;
    const c5 = y0 > w0 ? 2 : 0;
    const c6 = z0 > w0 ? 1 : 0;
    const c = c1 + c2 + c3 + c4 + c5 + c6;

    // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
    // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
    // impossible. Only the 24 indices which have non-zero entries make any sense.
    // We use a thresholding to set the coordinates in turn from the largest magnitude.
    // The number 3 in the "simplex" array is at the position of the largest coordinate.
    const i1 = simplex[c][0] >= 3 ? 1 : 0;
    const j1 = simplex[c][1] >= 3 ? 1 : 0;
    const k1 = simplex[c][2] >= 3 ? 1 : 0;
    const l1 = simplex[c][3] >= 3 ? 1 : 0;
    // The number 2 in the "simplex" array is at the second largest coordinate.
    const i2 = simplex[c][0] >= 2 ? 1 : 0;
    const j2 = simplex[c][1] >= 2 ? 1 : 0;
    const k2 = simplex[c][2] >= 2 ? 1 : 0;
    const l2 = simplex[c][3] >= 2 ? 1 : 0;
    // The number 1 in the "simplex" array is at the second smallest coordinate.
    const i3 = simplex[c][0] >= 1 ? 1 : 0;
    const j3 = simplex[c][1] >= 1 ? 1 : 0;
    const k3 = simplex[c][2] >= 1 ? 1 : 0;
    const l3 = simplex[c][3] >= 1 ? 1 : 0;
    // The fifth corner has all coordinate offsets = 1, so no need to look that up.
    const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
    const y1 = y0 - j1 + G4;
    const z1 = z0 - k1 + G4;
    const w1 = w0 - l1 + G4;
    const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
    const y2 = y0 - j2 + 2.0 * G4;
    const z2 = z0 - k2 + 2.0 * G4;
    const w2 = w0 - l2 + 2.0 * G4;
    const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
    const y3 = y0 - j3 + 3.0 * G4;
    const z3 = z0 - k3 + 3.0 * G4;
    const w3 = w0 - l3 + 3.0 * G4;
    const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
    const y4 = y0 - 1.0 + 4.0 * G4;
    const z4 = z0 - 1.0 + 4.0 * G4;
    const w4 = w0 - 1.0 + 4.0 * G4;
    // Work out the hashed gradient indices of the five simplex corners
    const ii = i & 255;
    const jj = j & 255;
    const kk = k & 255;
    const ll = l & 255;
    const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
    const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
    const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
    const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
    const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
    // Calculate the contribution from the five corners
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
    if (t0 < 0) n0 = 0.0;else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
    if (t1 < 0) n1 = 0.0;else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
    }
    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
    if (t2 < 0) n2 = 0.0;else {
      t2 *= t2;
      n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
    if (t3 < 0) n3 = 0.0;else {
      t3 *= t3;
      n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
    }
    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
    if (t4 < 0) n4 = 0.0;else {
      t4 *= t4;
      n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
    }

    // Sum up and scale the result to cover the range [-1,1]
    return 27.0 * (n0 + n1 + n2 + n3 + n4);
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/shaders/SSAOShader.js


/**
 * References:
 * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
 * https://learnopengl.com/Advanced-Lighting/SSAO
 * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl
 */

const SSAOShader = {
  defines: {
    'PERSPECTIVE_CAMERA': 1,
    'KERNEL_SIZE': 32
  },
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'tNormal': {
      value: null
    },
    'tDepth': {
      value: null
    },
    'tNoise': {
      value: null
    },
    'kernel': {
      value: null
    },
    'cameraNear': {
      value: null
    },
    'cameraFar': {
      value: null
    },
    'resolution': {
      value: new Vector2()
    },
    'cameraProjectionMatrix': {
      value: new Matrix4()
    },
    'cameraInverseProjectionMatrix': {
      value: new Matrix4()
    },
    'kernelRadius': {
      value: 8
    },
    'minDistance': {
      value: 0.005
    },
    'maxDistance': {
      value: 0.05
    }
  },
  vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
			vec3 viewNormal = getViewNormal( vUv );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

					occlusion += 1.0;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

		}`
};
const SSAODepthShader = {
  defines: {
    'PERSPECTIVE_CAMERA': 1
  },
  uniforms: {
    'tDepth': {
      value: null
    },
    'cameraNear': {
      value: null
    },
    'cameraFar': {
      value: null
    }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`
};
const SSAOBlurShader = {
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'resolution': {
      value: new Vector2()
    }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`
};

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/SSAOPass.js







class SSAOPass extends Pass {
  constructor(scene, camera, width, height) {
    super();
    this.width = width !== undefined ? width : 512;
    this.height = height !== undefined ? height : 512;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.kernelRadius = 8;
    this.kernelSize = 32;
    this.kernel = [];
    this.noiseTexture = null;
    this.output = 0;
    this.minDistance = 0.005;
    this.maxDistance = 0.1;
    this._visibilityCache = new Map();

    //

    this.generateSampleKernel();
    this.generateRandomKernelRotations();

    // beauty render target

    const depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    });

    // normal render target with depth buffer

    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      depthTexture: depthTexture
    });

    // ssao render target

    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    });
    this.blurRenderTarget = this.ssaoRenderTarget.clone();

    // ssao material

    if (SSAOShader === undefined) {
      console.error('THREE.SSAOPass: The pass relies on SSAOShader.');
    }
    this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    });
    this.ssaoMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
    this.ssaoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;
    this.ssaoMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;
    this.ssaoMaterial.uniforms['tNoise'].value = this.noiseTexture;
    this.ssaoMaterial.uniforms['kernel'].value = this.kernel;
    this.ssaoMaterial.uniforms['cameraNear'].value = this.camera.near;
    this.ssaoMaterial.uniforms['cameraFar'].value = this.camera.far;
    this.ssaoMaterial.uniforms['resolution'].value.set(this.width, this.height);
    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);

    // normal material

    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;

    // blur material

    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;
    this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height);

    // material for rendering the depth

    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAODepthShader.defines),
      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
      vertexShader: SSAODepthShader.vertexShader,
      fragmentShader: SSAODepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;
    this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far;

    // material for rendering the content of a render target

    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    // dispose render targets

    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.ssaoRenderTarget.dispose();
    this.blurRenderTarget.dispose();

    // dispose materials

    this.normalMaterial.dispose();
    this.blurMaterial.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();

    // dipsose full screen quad

    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */) {
    // render beauty

    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);

    // render normals and depth (honor only meshes, points and lines do not contribute to SSAO)

    this.overrideVisibility();
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);
    this.restoreVisibility();

    // render SSAO

    this.ssaoMaterial.uniforms['kernelRadius'].value = this.kernelRadius;
    this.ssaoMaterial.uniforms['minDistance'].value = this.minDistance;
    this.ssaoMaterial.uniforms['maxDistance'].value = this.maxDistance;
    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);

    // render blur

    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);

    // output result to screen

    switch (this.output) {
      case SSAOPass.OUTPUT.SSAO:
        this.copyMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Blur:
        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Normal:
        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Default:
        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = CustomBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn('THREE.SSAOPass: Unknown output type.');
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    // save original state
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);

    // setup pass state
    renderer.autoClear = false;
    if (clearColor !== undefined && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0.0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);

    // restore original state
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== undefined && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0.0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;

    // restore original state

    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.beautyRenderTarget.setSize(width, height);
    this.ssaoRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.ssaoMaterial.uniforms['resolution'].value.set(width, height);
    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms['resolution'].value.set(width, height);
  }
  generateSampleKernel() {
    const kernelSize = this.kernelSize;
    const kernel = this.kernel;
    for (let i = 0; i < kernelSize; i++) {
      const sample = new three_module_Vector3();
      sample.x = Math.random() * 2 - 1;
      sample.y = Math.random() * 2 - 1;
      sample.z = Math.random();
      sample.normalize();
      let scale = i / kernelSize;
      scale = MathUtils.lerp(0.1, 1, scale * scale);
      sample.multiplyScalar(scale);
      kernel.push(sample);
    }
  }
  generateRandomKernelRotations() {
    const width = 4,
      height = 4;
    if (SimplexNoise === undefined) {
      console.error('THREE.SSAOPass: The pass relies on SimplexNoise.');
    }
    const simplex = new SimplexNoise();
    const size = width * height;
    const data = new Float32Array(size * 4);
    for (let i = 0; i < size; i++) {
      const stride = i * 4;
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const z = 0;
      const noise = simplex.noise3d(x, y, z);
      data[stride] = noise;
      data[stride + 1] = noise;
      data[stride + 2] = noise;
      data[stride + 3] = 1;
    }
    this.noiseTexture = new DataTexture(data, width, height, RGBAFormat, FloatType);
    this.noiseTexture.wrapS = RepeatWrapping;
    this.noiseTexture.wrapT = RepeatWrapping;
  }
  overrideVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function (object) {
      cache.set(object, object.visible);
      if (object.isPoints || object.isLine) object.visible = false;
    });
  }
  restoreVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function (object) {
      const visible = cache.get(object);
      object.visible = visible;
    });
    cache.clear();
  }
}
SSAOPass.OUTPUT = {
  'Default': 0,
  'SSAO': 1,
  'Blur': 2,
  'Beauty': 3,
  'Depth': 4,
  'Normal': 5
};

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/RenderPass.js


class RenderPass extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== undefined) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);

    // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
    if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== undefined) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/shaders/SAOShader.js


/**
 * TODO
 */

const SAOShader = {
  defines: {
    'NUM_SAMPLES': 7,
    'NUM_RINGS': 4,
    'NORMAL_TEXTURE': 0,
    'DIFFUSE_TEXTURE': 0,
    'DEPTH_PACKING': 1,
    'PERSPECTIVE_CAMERA': 1
  },
  uniforms: {
    'tDepth': {
      value: null
    },
    'tDiffuse': {
      value: null
    },
    'tNormal': {
      value: null
    },
    'size': {
      value: new Vector2(512, 512)
    },
    'cameraNear': {
      value: 1
    },
    'cameraFar': {
      value: 100
    },
    'cameraProjectionMatrix': {
      value: new Matrix4()
    },
    'cameraInverseProjectionMatrix': {
      value: new Matrix4()
    },
    'scale': {
      value: 1.0
    },
    'intensity': {
      value: 0.1
    },
    'bias': {
      value: 0.5
    },
    'minResolution': {
      value: 0.0
    },
    'kernelRadius': {
      value: 100.0
    },
    'randomSeed': {
      value: 0.0
    }
  },
  vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,
  fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`
};

;// CONCATENATED MODULE: ./Renderer/jsm/shaders/DepthLimitedBlurShader.js


/**
 * TODO
 */

const DepthLimitedBlurShader = {
  defines: {
    'KERNEL_RADIUS': 4,
    'DEPTH_PACKING': 1,
    'PERSPECTIVE_CAMERA': 1
  },
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'size': {
      value: new Vector2(512, 512)
    },
    'sampleUvOffsets': {
      value: [new Vector2(0, 0)]
    },
    'sampleWeights': {
      value: [1.0]
    },
    'tDepth': {
      value: null
    },
    'cameraNear': {
      value: 10
    },
    'cameraFar': {
      value: 1000
    },
    'depthCutoff': {
      value: 10
    }
  },
  vertexShader: /* glsl */`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,
  fragmentShader: /* glsl */`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`
};
const BlurShaderUtils = {
  createSampleWeights: function (kernelRadius, stdDev) {
    const weights = [];
    for (let i = 0; i <= kernelRadius; i++) {
      weights.push(gaussian(i, stdDev));
    }
    return weights;
  },
  createSampleOffsets: function (kernelRadius, uvIncrement) {
    const offsets = [];
    for (let i = 0; i <= kernelRadius; i++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i));
    }
    return offsets;
  },
  configure: function (material, kernelRadius, stdDev, uvIncrement) {
    material.defines['KERNEL_RADIUS'] = kernelRadius;
    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    material.needsUpdate = true;
  }
};
function gaussian(x, stdDev) {
  return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);
}

;// CONCATENATED MODULE: ./Renderer/jsm/shaders/UnpackDepthRGBAShader.js
/**
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

const UnpackDepthRGBAShader = {
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'opacity': {
      value: 1.0
    }
  },
  vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`
};

;// CONCATENATED MODULE: ./Renderer/jsm/postprocessing/SAOPass.js








/**
 * SAO implementation inspired from bhouston previous SAO work
 */

class SAOPass extends Pass {
  constructor(scene, camera, depthTexture, useNormals, resolution) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;
    this.supportsNormalTexture = useNormals !== undefined ? useNormals : false;
    this.originalClearColor = new Color();
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.params = {
      output: 0,
      saoBias: 0.5,
      saoIntensity: 0.18,
      saoScale: 1,
      saoKernelRadius: 100,
      saoMinResolution: 0,
      saoBlur: true,
      saoBlurRadius: 8,
      saoBlurStdDev: 4,
      saoBlurDepthCutoff: 0.01
    };
    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    });
    this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    this.beautyRenderTarget = this.saoRenderTarget.clone();
    this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat
    });
    this.depthRenderTarget = this.normalRenderTarget.clone();
    if (this.supportsDepthTextureExtension) {
      const depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      this.beautyRenderTarget.depthTexture = depthTexture;
      this.beautyRenderTarget.depthBuffer = true;
    }
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.depthPacking = RGBADepthPacking;
    this.depthMaterial.blending = NoBlending;
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    if (SAOShader === undefined) {
      console.error('THREE.SAOPass relies on SAOShader');
    }
    this.saoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SAOShader.defines),
      fragmentShader: SAOShader.fragmentShader,
      vertexShader: SAOShader.vertexShader,
      uniforms: UniformsUtils.clone(SAOShader.uniforms)
    });
    this.saoMaterial.extensions.derivatives = true;
    this.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
    this.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;
    this.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;
    this.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;
    this.saoMaterial.blending = NoBlending;
    if (DepthLimitedBlurShader === undefined) {
      console.error('THREE.SAOPass relies on DepthLimitedBlurShader');
    }
    this.vBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
    this.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;
    this.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
    this.vBlurMaterial.blending = NoBlending;
    this.hBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
    this.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;
    this.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
    this.hBlurMaterial.blending = NoBlending;
    if (CopyShader === undefined) {
      console.error('THREE.SAOPass relies on CopyShader');
    }
    this.materialCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: NoBlending
    });
    this.materialCopy.transparent = true;
    this.materialCopy.depthTest = false;
    this.materialCopy.depthWrite = false;
    this.materialCopy.blending = CustomBlending;
    this.materialCopy.blendSrc = DstColorFactor;
    this.materialCopy.blendDst = ZeroFactor;
    this.materialCopy.blendEquation = AddEquation;
    this.materialCopy.blendSrcAlpha = DstAlphaFactor;
    this.materialCopy.blendDstAlpha = ZeroFactor;
    this.materialCopy.blendEquationAlpha = AddEquation;
    if (UnpackDepthRGBAShader === undefined) {
      console.error('THREE.SAOPass relies on UnpackDepthRGBAShader');
    }
    this.depthCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
      vertexShader: UnpackDepthRGBAShader.vertexShader,
      fragmentShader: UnpackDepthRGBAShader.fragmentShader,
      blending: NoBlending
    });
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive*/) {
    // Rendering readBuffer first when rendering to screen
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms['bias'].value = this.params.saoBias;
    this.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;
    this.saoMaterial.uniforms['scale'].value = this.params.saoScale;
    this.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms['cameraNear'].value = this.camera.near;
    this.saoMaterial.uniforms['cameraFar'].value = this.camera.far;
    // this.saoMaterial.uniforms['randomSeed'].value = Math.random();

    const depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;
    this.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;
    this.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;
    this.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;
    this.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;
    this.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));
      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }

    // Rendering scene to depth texture
    renderer.setClearColor(0x000000);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);

    // Re-render scene if depth texture extension is not supported
    if (!this.supportsDepthTextureExtension) {
      // Clear rule : far clipping plane in both RGBA and Basic encoding
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);
    }
    if (this.supportsNormalTexture) {
      // Clear rule : default normal is facing the camera
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);
    }

    // Rendering SAO texture
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0);

    // Blurring SAO texture
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);
    }
    let outputMaterial = this.materialCopy;
    // Setting up SAO rendering
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }

    // Blending depends on output, only want a CustomBlending when showing SAO
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }

    // Rendering SAOPass result on top of previous pass
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    // save original state
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);

    // setup pass state
    renderer.autoClear = false;
    if (clearColor !== undefined && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0.0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);

    // restore original state
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== undefined && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0.0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;

    // restore original state
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms['size'].value.set(width, height);
    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms['size'].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms['size'].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
}
SAOPass.OUTPUT = {
  'Beauty': 1,
  'Default': 0,
  'SAO': 2,
  'Depth': 3,
  'Normal': 4
};

;// CONCATENATED MODULE: ./Renderer/CameraCubeGeom.js




/**
 * Camera Cube Geometry 클래스
 * */
class CameraCubeGeom {
  /**
   * 클래스 생성자
   * @param {Renderer} renderer 렌더러 참조
   */
  constructor(renderer) {
    this._renderer = renderer;
    this._pnormals = [];
    this._pnormals.push(new three_module_Vector3(1, 0, 0));
    this._pnormals.push(new three_module_Vector3(-1, 0, 0));
    this._pnormals.push(new three_module_Vector3(0, 1, 0));
    this._pnormals.push(new three_module_Vector3(0, -1, 0));
    this._pnormals.push(new three_module_Vector3(0, 0, 1));
    this._pnormals.push(new three_module_Vector3(0, 0, -1));
    this._pupvs = [];
    this._pupvs.push(new three_module_Vector3(0, 1, 0));
    this._pupvs.push(new three_module_Vector3(0, 1, 0));
    this._pupvs.push(new three_module_Vector3(0, 0, 1));
    this._pupvs.push(new three_module_Vector3(0, 0, 1));
    this._pupvs.push(new three_module_Vector3(0, 1, 0));
    this._pupvs.push(new three_module_Vector3(0, 1, 0));
    this._pnames = [];
    this._pnames.push("Right");
    this._pnames.push("Left");
    this._pnames.push("Back");
    this._pnames.push("Front");
    this._pnames.push("Top");
    this._pnames.push("Bottom");
    this._raycaster = new Raycaster();
    this._size = 9;
    this._opacity = 0.6;
    this._vPos = new Vector4(-0.89, 0.8, -0.9, 1);
    this._startDownClick = false;
  }

  /**
  * axis mesh를 현재 카메라를 기준으로 정해진 뷰포트에 렌더링되도록 조정한다.
  */
  updateAxisMesh() {
    if (!this._renderer._isOrthoCamera) {
      // perspective camera
      this._renderer._camera.updateProjectionMatrix();
      let pmat = this._renderer._camera.projectionMatrixInverse;
      let pos = this._vPos.clone();
      pos.applyMatrix4(pmat);
      this._renderer._camera.updateMatrixWorld();
      let mvmat = this._renderer._camera.matrixWorld;
      pos.applyMatrix4(mvmat);
      pos.divideScalar(pos.w);
      this._cube.position.fromArray([pos.x, pos.y, pos.z]);
      this._cube.scale.fromArray([_cameraPersfAxisSize, _cameraPersfAxisSize, _cameraPersfAxisSize]);
      this._cube.updateMatrixWorld(true);
      this._aCenter = new three_module_Vector3();
      this._cube.getWorldPosition(this._aCenter);
    } else {
      // orthogonal camera
      this._renderer._camera.updateProjectionMatrix();
      let pmat = this._renderer._camera.projectionMatrixInverse;
      let pos = this._vPos.clone();
      pos.applyMatrix4(pmat);
      this._renderer._camera.updateMatrixWorld();
      let mvmat = this._renderer._camera.matrixWorld;
      pos.applyMatrix4(mvmat);
      pos.divideScalar(pos.w);
      let size = _cameraOrthoAxisSize / this._renderer._camera.zoom;
      //rayLog(3, "camera : " + this._renderer._camera.zoom);

      //size = 1.01;
      this._cube.position.fromArray([pos.x, pos.y, pos.z]);
      this._cube.scale.fromArray([size, size, size]);
      let t = 32;
      this._aCenter = new three_module_Vector3();
      this._cube.getWorldPosition(this._aCenter);
    }
  }

  /**
   * Cube 메쉬를 생성한다.
   */
  createMesh() {
    this._cube = new Group();
    this._pmeshs = [];
    for (let i = 0; i < this._pnormals.length; i++) {
      let mat = new MeshLambertMaterial({
        color: 0x808080,
        opacity: this._opacity,
        side: DoubleSide,
        transparent: true
      });
      let pg = new PlaneGeometry(this._size, this._size);
      let mesh = new three_module_Mesh(pg, mat);
      mesh._pIndex = i;

      //let bbwire = new THREE.WireframeGeometry(pg);
      //let bboxWire = new THREE.LineSegments(bbwire);
      //bboxWire.material.opacity = this._opacity;
      //bboxWire.material.color.r = 1;
      //bboxWire.material.color.g = 1;
      //bboxWire.material.color.b = 1;
      //bboxWire.material.transparent = true;
      //bboxWire.visible = false;

      let shapes = this._renderer._font.generateShapes(this._pnames[i], 1.5);
      let tg = new ShapeGeometry(shapes);
      tg.computeBoundingBox();
      const xMid = -0.5 * (tg.boundingBox.max.x - tg.boundingBox.min.x);
      const yMid = -0.25 * (tg.boundingBox.max.y - tg.boundingBox.min.y);
      let matText = new MeshLambertMaterial({
        color: 0xFFFFFF
      });
      let meshText = new three_module_Mesh(tg, matText);
      meshText.position.set(xMid, yMid, 0);
      let lp = new Group();
      lp.add(mesh);
      lp.add(meshText);

      //lp.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), this._pnormals[i].clone().normalize()));

      let zv = this._pnormals[i];
      let yv = this._pupvs[i];
      let xv = this._pupvs[i].clone().cross(this._pnormals[i]).normalize();
      let tmat = new Matrix4().makeBasis(xv, yv, zv);
      lp.setRotationFromMatrix(tmat);
      let ppos = this._pnormals[i].clone().normalize().multiplyScalar(this._size * 0.5);
      lp.position.set(ppos.x, ppos.y, ppos.z);
      this._pmeshs.push(mesh);
      this._cube.add(lp);
      this._renderer._scene2.add(this._cube);
    }
    this._cube.position.set(0, 0, 0);
    this._cube.scale.set(0.1, 0.1, 0.1);
    this._cube.name = "camera_cube";
    return this._cube;
  }

  /**
   * Camera Cube 렌더링 뷰포트 위치를 지정한다.
   * @param {Number} x 뷰포트 x값
   * @param {Number} y 뷰포트 y값
   * @param {Number} z 뷰포트 z값
   * @param {Number} w 뷰포트 w값
   */
  setViewportPosition(x, y, z, w) {
    this._vPos = new Vector4(x, y, z, w);
  }

  /**
   * Camera Cube 평면을 피킹한다.
   * @param {THREE.Vector2} normalizedPosition normalized 좌표
   * @returns {Number} 피킹된 평면 인덱스
   */
  pickCubeObject(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._renderer._camera);
    let borigin = this._raycaster.ray.origin.clone().sub(this._raycaster.ray.direction.clone().multiplyScalar(10000));
    this._raycaster.ray.origin = borigin;
    this._intersectedObjects = this._raycaster.intersectObjects(this._renderer._scene2.children, true);
    this._pickedObject = null;

    //console.log("raycast get on np " + normalizedPosition.x + "," + normalizedPosition.y + " : " + this._intersectedObjects.length);
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (obj && obj._pIndex !== undefined) {
        console.log("pick cube plane index " + obj._pIndex);
        return obj._pIndex;
      }
    }
    return undefined;
  }

  /**
   * 마우스 이동 이벤트를 처리한다.
   * @param {THREE.Vector2} normalizedPosition normalized 좌표
   * @returns {Boolean} 이벤트 핸들 결과
   */
  handleMouseMove(normalizedPosition) {
    for (let mesh of this._pmeshs) {
      mesh.material.color.r = 0.6;
      mesh.material.color.g = 0.6;
      mesh.material.color.b = 0.6;
    }
    let pickIndex = this.pickCubeObject(normalizedPosition);
    if (pickIndex !== undefined) {
      let pm = this._pmeshs[pickIndex];
      pm.material.color.r = 0.3;
      pm.material.color.g = 1;
      pm.material.color.b = 1;
    }
  }

  /**
   * 마우스 버튼 다운 이벤트를 처리한다.
   * @param {THREE.Vector2} normalizedPosition normalized 좌표
   * @returns {Boolean} 이벤트 핸들 결과
   */
  handleMouseDown(normalizedPosition) {
    let pickIndex = this.pickCubeObject(normalizedPosition);
    if (pickIndex !== undefined) {
      this._downClickNP = normalizedPosition.clone();
      this._startDownClick = true;
      return true;
    }
    return false;
  }

  /**
   * 마우스 클릭 이벤트를 처리한다.
   * @param {THREE.Vector2} normalizedPosition normalized 좌표
   * @returns {Boolean} 이벤트 핸들 결과
   */
  handleMouseClick(normalizedPosition) {
    if (this._startDownClick) {
      let pickIndex = this.pickCubeObject(normalizedPosition);
      if (pickIndex !== undefined) {
        this._pickPlaneNormal = this._pnormals[pickIndex].clone().multiplyScalar(-1);
        this._pickPlaneUp = this._pupvs[pickIndex].clone();
        this._startDownClick = false;
        return true;
      }
    }
    this._startDownClick = false;
    return false;
  }
}
;// CONCATENATED MODULE: ./Renderer/Renderer.js
















/**
 * Three.js을 사용하여 3D 모델을 렌더링하고 가시화 하는데 필요한 기능을 모아둔 클래스
 * */
class Renderer {
  static _font = null;
  static _renderer = null;
  static _lightCameraIntensity1 = 0.6;
  static _lightCameraIntensity2 = 1;
  static _lightCameraIntensity3 = 0.4;

  /**
   * 폰트 데이터를 로드한다.
   * @param {Function} callback 콜백 함수
   */
  LoadFont(callback) {
    this._font_loader = new FontLoader();
    const fn = '../_resources/helvetiker_bold.typeface.json';
    let I = this;
    this._font_loader.load(fn, function (font) {
      I._font = font;
      if (callback) callback(font);
    });
  }

  /**
   * Renderer.js 생성자. Three.js의 Renderer와 기타 변수등을 초기화 한다. 
   * @param {any} div 렌더링 될 창의 div 포인터
   * @param {Boolean} preserve_screen 화면을 저장하기 위한 버퍼를 생성할지 여부
   * @param {Boolean} is_main 생성된 렌더러가 메인 렌더러인지 여부
   */
  constructor(div, preserve_screen, is_main) {
    this._enableFog = false;
    Renderer._renderer = this;
    if (!preserve_screen) preserve_screen = false;
    this._div = div;
    if (is_main) {
      Renderer.I = this;
    }
    this._camera = null;
    this._cameraOrthoTop = 0;
    this._cameraOrthoBottom = 0;
    this._cameraZoomO = 1;
    this._cameraZoomP = 1;
    this._scene = null;
    this._renderer = null;
    this._clock = new Clock();
    this._container = null;
    this._backgroundColor = new Color(0.5, 0.5, 0.5);
    this._lightMode = 0;
    this._group = null;
    this._container = document.createElement('div');
    this._div.appendChild(this._container);
    this._sceneUI = new Scene();
    this._sceneAxis = new Scene();
    this._scene = new Scene();
    //this._scene.background = new THREE.Color(0xffffff);
    this._scene.background = this._backgroundColor;

    // add scene2
    this._scene2 = new Scene();
    this._windowWidth = 100;
    this._windowHeight = 100;
    this._vx = new three_module_Vector3(1, 0, 0);
    this._vy = new three_module_Vector3(0, 1, 0);
    this._vz = new three_module_Vector3(0, 0, 1);

    //var scr_width = window.innerWidth;
    //var scr_height = window.innerHeight;
    var scr_width = this._div.offsetWidth;
    var scr_height = this._div.offsetHeight;
    this._renderer = new WebGLRenderer({
      antialias: true,
      preserveDrawingBuffer: preserve_screen
    });
    if (preserve_screen) this._renderer.setPixelRatio(1.0);else this._renderer.setPixelRatio(window.devicePixelRatio);
    this._renderer.setSize(scr_width, scr_height);
    //        this._renderer.outputEncoding = THREE.sRGBEncoding;
    this._renderer.shadowMap.enabled = true;
    this._renderer.antialias = true;
    this._renderer.setClearColor(0x6f6f6f, 1);
    //window.addEventListener('resize', this.onWindowResize, false);

    this._container.appendChild(this._renderer.domElement);
    this._raycaster = new Raycaster();
    this._intersectedObjects = [];

    // axisGeom 추가
    this._axes = [];
    this._axisGeom = new AxisGeom(this);
    this._axisMesh = this._axisGeom.createAxisMeshWithVectors();
    // this._axisMesh = this._axisGeom.createAxisGeometry();
    this._scene2.add(this._axisMesh);
    this._scene.fog = new Fog(this._backgroundColor, 30, 40);
    this._scene.fog = null;
    this._effectComposer = new EffectComposer(this._renderer);
    this._useEffectComposer = false; // normal
    this._renderPassMode = 0;
  }
  /**
   * 앤티 얼라이어싱 옵션을 설정한다.
   * @param {Boolean} enable 앤티 얼라이어스 옵션 사용 여부
   */
  setAntialias(enable) {
    this._renderer.antialias = enable;
  }

  // 렌더링 모드를 가져옴. 

  /**
   * Fog 효과 파라메터를 설정한다.
   * @param {Number} near Fog near
   * @param {Number} far Fog far
   */
  setFogDistance(near, far) {
    this._fogNear = near;
    this._fogFar = far;
    this.enableFog(this._enableFog);
  }

  /**
   * 현재 렌더링 모드를 반환한다.
   * @returns {Number} 렌더링 모드
   * */
  getRenderMode() {
    return this._renderPassMode;
  }
  toScreenPosition(mesh) {
    let obj = mesh;
    var vector = new three_module_Vector3();
    var widthHalf = 0.5 * this._renderer.getContext().canvas.clientWidth;
    var heightHalf = 0.5 * this._renderer.getContext().canvas.clientHeight;
    obj.updateMatrixWorld();
    vector.setFromMatrixPosition(obj.matrixWorld);
    vector.project(this._camera);
    vector.x = vector.x * widthHalf + widthHalf;
    vector.y = -(vector.y * heightHalf) + heightHalf;
    return [vector.x, vector.y];
  }
  // 렌더링 모드를 설정
  // 0: 일반 렌더링
  // 1: Screen Space ambient occlusion
  // 2: Scalable ambient occlusion

  /**
   * 렌더링 모드를 설정한다.
   * @param {Number} mode 렌더링 모드
   */
  setRenderMode(mode) {
    switch (mode) {
      case 0:
        this.setRenderPassDefault();
        break;
      case 1:
        this.setRenderPassSSAO();
        break;
      case 2:
        this.setRenderPassSAO();
        break;
    }
  }

  /**
   * 기본 Render Pass 를 설정한다.
   * */
  setRenderPassDefault() {
    this.RemoveAllPasses();
    this._useEffectComposer = false; // normal
    this._renderPassMode = 0;
  }

  /**
   * SSAO Render Pass를 설정한다.
   * */
  setRenderPassSSAO() {
    this.RemoveAllPasses();
    const width = window.innerWidth;
    const height = window.innerHeight;
    this._ssaoPass = new SSAOPass(this._scene, this._camera, width, height);
    this._ssaoPass.kernelRadius = 64;
    this._effectComposer.addPass(this._ssaoPass);
    this._useEffectComposer = true; // normal
    this._renderPassMode = 1;
  }

  /**
   * SAO Render Pass를 설정한다.
   * */
  setRenderPassSAO() {
    this.RemoveAllPasses();
    const width = window.innerWidth;
    const height = window.innerHeight;
    this._renderPass = new RenderPass(this._scene, this._camera);
    this._effectComposer.addPass(this._renderPass);
    this._saoPass = new SAOPass(this._scene, this._camera, false, true);
    this._saoPass.params.saoBias = 0.25;
    this._saoPass.params.saoIntensity = 0.15;
    this._saoPass.params.saoScale = 80;
    this._saoPass.params.saoKernelRadius = 100;
    this._saoPass.params.saoMinResolution = 0;
    this._saoPass.params.saoBlur = true;
    this._saoPass.params.saoBlurRadius = 8;
    this._saoPass.params.saoBlurStdDev = 4;
    this._saoPass.params.saoBlurDepthCutoff = 0.01;
    this._effectComposer.addPass(this._saoPass);
    this._useEffectComposer = true; // normal
    this._renderPassMode = 2;
  }

  /**
   * 기존 Render Pass를 삭제한다.
   * */
  RemoveAllPasses() {
    if (this._ssaoPass) {
      this._effectComposer.removePass(this._ssaoPass);
      this._ssaoPass = null;
    }
    if (this._saoPass) {
      this._effectComposer.removePass(this._saoPass);
      this._saoPass = null;
    }
    if (this._renderPass) {
      this._effectComposer.removePass(this._renderPass);
      this._renderPass = null;
    }
  }

  /**
  * 포그를 enable/disable 한다. 
  * @param {Boolean} enable enable/disable여부
  */
  enableFog(enable) {
    this._enableFog = enable;
    if (enable) {
      this._scene.fog = new Fog(this._backgroundColor, this._fogNear, this._fogFar);
      if (this._cameraP) {
        this._cameraP.near = 0.1;
        this._cameraP.updateProjectionMatrix();
      }
    } else {
      this._scene.fog = null;
      if (this._cameraP) {
        this._cameraP.near = 0.1;
        this._cameraP.updateProjectionMatrix();
      }
    }
  }

  /**
  * 특정 Three.js Geometry의 vertex color를 설정한다. 
  * @param {Three.Geometry} geom vretex color를 설정할 geometry
  * @param {Number} r red color [0,1]
  * @param {Number} g green color [0,1]
  * @param {Number} b blue color [0,1]
  */
  setGeometryVertexColor(geom, r, g, b) {
    let colors = new Float32Array([r, g, b]);
    geom.setAttribute('color', new BufferAttribute(colors, 3, true));
  }

  /**
  * Axis를 그릴 geometry를 cone, cylinder 를 사용하여 생성한다.  
  * @returns 생성된 Three.js Mesh 클래스를 리턴
  */
  /*
   createAxisGeometry(axis1 = new THREE.Vector3(0,1,0), axis2 = new THREE.Vector3(1,0,0), axis3 = new THREE.Vector3(0,0,1)) {
   
       let defaultQuaternion = new THREE.Quaternion();
         const cr = 0.1;
       const clen = 3;
       var mergedGeo = new THREE.Geometry();
         var mat1 = new THREE.Matrix4();
         mat1.identity();
       mat1.compose(new THREE.Vector3(), 
           defaultQuaternion.clone().setFromUnitVectors(new THREE.Vector3(0,1,0), axis1), 
           new THREE.Vector3(1,1,1));
         var cylinder = new THREE.CylinderGeometry(cr, cr, clen, 8).translate(0, clen/2, 0);
       var cone = new THREE.ConeGeometry(cr*2, 1, 32).translate(0, clen,0);
       this.setGeometryVertexColor(cylinder, 0, 1, 0);
       this.setGeometryVertexColor(cone, 0, 1, 0);
         mergedGeo.merge(cylinder, mat1);
       mergedGeo.merge(cone, mat1);
         mat1.identity();
       mat1.compose(new THREE.Vector3(),
           defaultQuaternion.clone().setFromUnitVectors(new THREE.Vector3(0,1,0), axis2),
           new THREE.Vector3(1,1,1));
         cylinder = new THREE.CylinderGeometry(cr, cr, clen, 8).translate(0, clen / 2, 0);
       cone = new THREE.ConeGeometry(cr * 2, 1, 32).translate(0, clen, 0);
       this.setGeometryVertexColor(cylinder, 1, 0, 0);
       this.setGeometryVertexColor(cone, 1, 0, 0);
         mergedGeo.merge(cylinder, mat1);
       mergedGeo.merge(cone, mat1);
         mat1.identity();
       mat1.compose(new THREE.Vector3(),
           defaultQuaternion.clone().setFromUnitVectors(new THREE.Vector3(0,1,0), axis3),
           new THREE.Vector3(1,1,1));
         
       cylinder = new THREE.CylinderGeometry(cr, cr, clen, 8).translate(0, clen / 2, 0);
       cone = new THREE.ConeGeometry(cr * 2, 1, 32).translate(0, clen, 0);
       this.setGeometryVertexColor(cylinder, 0, 0, 1);
       this.setGeometryVertexColor(cone, 0, 0, 1);
         mergedGeo.merge(cylinder, mat1);
       mergedGeo.merge(cone, mat1);
       
         var matx = new THREE.MeshLambertMaterial({
           vertexColors: THREE.VertexColors,
           color: 0xffffff
       });
  
       this._axisMesh = new THREE.Mesh(mergedGeo, matx);
       this._axisMesh.scale.set(0.2, 0.2, 0.2);
         return this._axisMesh;
   }
   */

  /**
  * scene으로 받은 모델을 GLTF형식으로 익스포트 한다. 
  * @param {Three.Scene} scene export할 scene 데이터
  * @param {function} callback export되면 호출될 함수
  */
  exportGLTF(scene, callback) {
    const gltfExporter = new GLTFExporter();
    const options = {
      trs: false,
      onlyVisible: true,
      truncateDrawRange: false,
      binary: true,
      maxTextureSize: 40960000
    };
    var output = null;
    gltfExporter.parse(scene, function (result) {
      if (result instanceof ArrayBuffer) {
        //saveArrayBuffer(result, 'scene.glb');
        if (callback) callback(result);
      } else {
        output = JSON.stringify(result, null, 2);
        rayLog(3, "GLTF generated.");
        //saveString(output, 'scene.gltf');
        if (callback) callback(output);
      }
    }, options);
  }

  /**
  * axis mesh를 현재 카메라를 기준으로 화면의 우측 하단에 위치 시킨다. 
  */
  /*
  updateAxisMesh() {
        this._raycaster.setFromCamera(new THREE.Vector2(0.5,0.5), this._camera);
        
      // var pos = this._raycaster.ray.origin.clone();
      // var dir = this._raycaster.ray.direction.clone();
      // dir.multiplyScalar(20);
      // pos.add(dir);
      
        var width = this._div.clientWidth;
      var height = this._div.clientHeight;
      var aspect = width / height;
        var fov = this._camera.fov;
      var cz = 20;
      var cx = cz * Math.tan(fov * Math.PI / 180 / 2) * 0.95 * aspect;
      var cy = cz * Math.tan(fov * Math.PI / 180 / 2) * 0.93;
      
      var forward = new THREE.Vector3(0, 0, 1);
      forward.applyQuaternion(this._camera.quaternion);
      var right = new THREE.Vector3(1, 0, 0);
      right.applyQuaternion(this._camera.quaternion);
      var up = new THREE.Vector3(0, 1, 0);
      up.applyQuaternion(this._camera.quaternion);
        right.multiplyScalar(-cx);
      up.multiplyScalar(-cy);c
      forward.multiplyScalar(-cz);
      var pos = new THREE.Vector3();
      pos.copy(this._camera.position);
        pos.add(right);
      pos.add(up);
      pos.add(forward);
      
        this._axisMesh.position.copy( pos);
  }
  */

  /**
  * Renderer의 배경 색을 정의한다. 
  * @param {Three.Scene} scene export할 scene 데이터
  * @param {Number} r red color [0,1]
  * @param {Number} g green color [0,1]
  * @param {Number} b blue color [0,1]
  */
  setBackgroundColor(r, g, b) {
    this._backgroundColor = new Color(r, g, b);
    this._scene.background = this._backgroundColor;
    this.enableFog(this._enableFog);
  }

  /**
  * Renderer의 현재 배경 색을 가져온다. 
  * @returns 현재 배경색 [r,g,b]
  */
  getBackgroundColor() {
    return [this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b];
  }

  /**
  * Three.js Renderer의 domElement를 리턴한다. 
  * @returns Renderer의 domElement
  */
  getContainer() {
    return this._renderer.domElement;
  }

  /**
   * Ortho 카메라의 방향을 설정한다.
   * @param {THREE.Vector3} direction 방향 벡터
   */
  setOrthoCameraDirection(direction, up) {
    let center = this._controls.target.clone();
    let dir = direction.clone();
    dir.normalize();
    dir.multiplyScalar(-this._ocameraDistance);
    var pos = new three_module_Vector3();
    pos.add(center);
    pos.add(dir);
    let zoom = this._cameraZoomO;
    this._cameraO.position.set(pos.x, pos.y, pos.z);
    this._cameraO.zoom = zoom;
    if (up) {
      this._cameraO.up.set(up.x, up.y, up.z);
    }
    this._controls.position0.set(pos.x, pos.y, pos.z);
    this._controls.target0.set(center.x, center.y, center.z);
    this._controls.zoom0 = zoom;
    this._controls.reset();
  }

  /**
   * Ortho 카메라의 거리를 설정한다.
   * @param {Number} dist 거리 값
   */
  setOrthoCameraDistance(dist) {
    this._ocameraDistance = dist;
    let center = this._controls.target.clone();
    var dir = new three_module_Vector3();
    this._camera.getWorldDirection(dir);
    dir.normalize();
    dir.multiplyScalar(-this._ocameraDistance);
    var pos = new three_module_Vector3();
    pos.add(center);
    pos.add(dir);
    let zoom = this._cameraZoomO;
    this._cameraO.position.set(pos.x, pos.y, pos.z);
    this._cameraO.zoom = zoom;
    this._controls.position0.set(pos.x, pos.y, pos.z);
    this._controls.target0.set(center.x, center.y, center.z);
    this._controls.zoom0 = zoom;
    this._controls.reset();
  }

  // zoom_factor -n~n
  adjustOrthoZoom(zoom_factor) {
    let zoom = this._cameraO.zoom;
    zoom += zoom_factor;
    if (zoom < this._controls.minZoom) zoom = this._controls.minZoom;
    if (zoom > this._controls.maxZoom) zoom = this._controls.maxZoom;
    this._cameraO.zoom = zoom;
  }

  /**
  * 3차원 Three.js 의 Orthographic camera를 생성한다. 
  * @param {Number} left Orthograpic camera의 좌측 x좌표를 정의
  * @param {Number} right Orthograpic camera의 우측 x좌표를 정의
  * @param {Number} top Orthograpic camera의 상단 y좌표를 정의
  * @param {Number} bottom Orthograpic camera의 하단 y좌표를 정의
  * @param {Number} near Orthograpic camera의 가까운 평면을 정의
  * @param {Number} far Orthograpic camera의 먼 평면을 정의
  */
  create3DOrthographicCamera(left, right, top, bottom, near, far) {
    if (this._camera) {
      this._scene.remove(this._camera);
    }
    this._is2DOrthoCamera = false;
    this._isOrthoCamera = true;
    this._cameraOrthoTop = top;
    this._cameraOrthoBottom = bottom;
    var width = this._div.clientWidth;
    var height = this._div.clientHeight;
    var aspect = width / height;
    var ch = top - bottom;
    this._ocameraDistance = 100;
    this._cameraO = new OrthographicCamera(-aspect * ch / 2, aspect * ch / 2, top, bottom, near, far);
    this._cameraO.position.set(100, 100, 100);
    this._camera = this._cameraO;
    this._scene.add(this._camera);
  }

  /**
  * 현재 카메라를 Orthogonal camera로 설정한다. 
  */
  setOrthoCamera() {
    let pmode = this._cameraMode;
    this._cameraMode = "O";
    this._scene.remove(this._cameraP);
    this._scene.add(this._cameraO);

    //this._cameraO.position.set(this._cameraP.position.x, this._cameraP.position.y, this._cameraP.position.z);
    this._camera = this._cameraO;
    this._cameraO.add(this._cameraLight);
    this._isOrthoCamera = true;
    this.onWindowResize(this._windowWidth, this._windowHeight);
    this._controls.object = this._camera;
    this._controls.zoom0 = this._camera.zoom;
    this._controls.reset();
    if (pmode == "P") {
      this._cameraO.position.set(this._cameraP.position.x, this._cameraP.position.y, this._cameraP.position.z);
    }
    this.onWindowResize(this._windowWidth, this._windowHeight);
    //this.autofitCamera();
  }

  /**
  * 현재 카메라를 Perspective camera로 설정한다.
  */
  setPerspectiveCamera() {
    let pmode = this._cameraMode;
    this._cameraMode = "P";
    this._scene.remove(this._cameraO);
    //this._scene.remove(this._cameraP);
    this._scene.add(this._cameraP);
    this._cameraP.add(this._cameraLight);

    //this._cameraP.position.set(this._cameraO.position.x, this._cameraO.position.y, this._cameraO.position.z);
    this._camera = this._cameraP;
    this._controls.zoom0 = this._camera.zoom;
    this._controls.object = this._camera;
    this._controls.reset();
    if (pmode == "O") {
      this._cameraP.position.set(this._cameraO.position.x, this._cameraO.position.y, this._cameraO.position.z);
    }
    this._isOrthoCamera = false;
    this.onWindowResize(this._windowWidth, this._windowHeight);
  }

  /**
  * 2차원 Three.js 의 Orthographic camera를 생성한다.
  * @param {Number} left Orthograpic camera의 좌측 x좌표를 정의
  * @param {Number} right Orthograpic camera의 우측 x좌표를 정의
  * @param {Number} top Orthograpic camera의 상단 y좌표를 정의
  * @param {Number} bottom Orthograpic camera의 하단 y좌표를 정의
  * @param {Number} near Orthograpic camera의 가까운 평면을 정의
  * @param {Number} far Orthograpic camera의 먼 평면을 정의
  */
  createOrthographicCamera(left, right, top, bottom, near, far) {
    if (this._camera) {
      this._scene.remove(this._camera);
    }
    this._is2DOrthoCamera = true;
    this._isOrthoCamera = true;
    this._cameraOrthoTop = top;
    this._cameraOrthoBottom = bottom;
    var width = this._div.clientWidth;
    var height = this._div.clientHeight;
    var aspect = width / height;
    var ch = top - bottom;
    this._cameraO = new OrthographicCamera(-aspect * ch / 2, aspect * ch / 2, top, bottom, near, far);
    this._camera = this._cameraO;
    this._scene.add(this._camera);
    //this._cameraMode = "O";
  }

  /**
  * 3차원 Three.js 의 Perspective camera를 생성한다.
  * @param {Number} x camera의 x좌표를 정의
  * @param {Number} y camera의 y좌표를 정의
  * @param {Number} z camera의 z좌표를 정의
  * @param {Number} fov camera의 fov를 정의
  * @param {Number} aspect camera의 aspect ratio을 정의
  * @param {Number} near camera의 가까운 평면을 정의
  * @param {Number} far camera의 먼 평면을 정의
  */
  createPerspecriveCamera(x, y, z, fov, aspect, near, far) {
    if (this._camera) {
      this._scene.remove(this._camera);
    }
    this._is2DOrthoCamera = false;
    this._isOrthoCamera = false;
    this._cameraP = new PerspectiveCamera(fov, aspect, near, far);
    this._cameraP.position.set(x, y, z);
    this._camera = this._cameraP;
    this._scene.add(this._camera);

    //this._cameraMode = "P";
  }

  /**
  * 카메라를 컨트롤 하는 Three.js의 Trackball control을 생성한다. 
  */
  /*
  createTrackballControl() {
        this._controls = new TrackballControls(this._camera, this._container);
        this._controls.rotateSpeed = 35.0;
      this._controls.zoomSpeed = 1.2;
      this._controls.panSpeed = 0.8;
      this._controls.staticMoving = true;
      this._controls.dynamicDampingFactor = 5;
      this._controls.target.set(0, 0, 0);
      this._controls.update();
  }
  */

  /**
  * 카메라를 컨트롤 하는 Three.js의 Orbit control을 생성한다.
  */
  createOrbitControl() {
    this._controls = new OrbitControls(this._camera, this._container);
    this._controls.target.set(0, 0, 0);
    this._controls.object = this._camera;
    if (this._is2DOrthoCamera) {
      this._controls.enableRotate = false;
    } else {
      this._controls.enableRotate = true;
    }
    this._controls.update();
  }

  /**
  * 카메라를 컨트롤 하는 Three.js의 Orbit control을 생성한다.
  */
  createTrackballControl() {
    this._controls = new TrackballControls(this._camera, this._container);
    this._controls.target.set(0, 0, 0);
    this._controls.rotateSpeed = 35.0;
    this._controls.zoomSpeed = 1.2;
    this._controls.panSpeed = 0.8;
    this._controls.staticMoving = true;
    this._controls.dynamicDampingFactor = 5;
    this._controls.target.set(0, 0, 0);
    this._controls.noZoom = false;
    this._controls.noPan = false;
    this._controls.object = this._camera;
    if (this._is2DOrthoCamera) {
      this._controls.enableRotate = false;
    } else {
      this._controls.enableRotate = true;
    }
    this._controls.update();
  }

  /**
  * Skybox 텍스쳐를 로드하고 설정한다. 
  * @param {String} path 텍스쳐의 위치 URL
  * @param {String} fn 텍스쳐 파일 이름
  * @param {Function} func 로드가 완료되면 호출 될 callback 함수
  */
  loadSkybox(path, fn, func) {
    if (!Renderer.I._pmremGenerator) {
      Renderer.I._pmremGenerator = new PMREMGenerator(Renderer.I._renderer);
      Renderer.I._pmremGenerator.compileEquirectangularShader();
    }
    new RGBELoader().setDataType(UnsignedByteType).setPath(path).load(fn, function (texture) {
      var pmremGenerator = new PMREMGenerator(Renderer.I._renderer);
      pmremGenerator.compileEquirectangularShader();
      var envMap = Renderer.I._pmremGenerator.fromEquirectangular(texture).texture;
      Renderer.I._scene.background = envMap;
      Renderer.I._scene.environment = envMap;
      texture.dispose();
      pmremGenerator.dispose();

      //render();
      if (func) func(texture);
    });
  }

  /**
  * Skybox 메쉬 모델을 로드하는 함수
  * @param {String} path 텍스쳐의 위치 URL
  * @param {String} fn 텍스쳐 파일 이름
  * @param {Function} func 로드가 완료되면 호출 될 callback 함수
  */
  loadModel(path, fn, func) {
    var roughnessMipmapper = new RoughnessMipmapper(Renderer.I._renderer);
    var loader = new GLTFLoader().setPath(path);
    loader.load(fn, function (gltf) {
      var list = [];
      for (var i = 0; i < gltf.scene.children.length; i++) {
        const child = gltf.scene.children[i];
        list.push(child);
      }

      //Renderer.I._scene.add( gltf.scene );

      var i = 0;
      for (i = 0; i < list.length; i++) {
        Renderer.I._group.attach(list[i]);
      }
      roughnessMipmapper.dispose();

      //render();
      if (func) func(gltf);
    });
  }

  /**
  * 바닥 평면 메쉬를 생성한다. 
  */
  createGround() {
    var geometry = new PlaneGeometry(4000, 4000);
    var material = new MeshStandardMaterial({
      color: 0x2e2e2e,
      roughness: 1.0,
      metalness: 0.0
    });
    var floor = new three_module_Mesh(geometry, material);
    floor.position.set(0, -5, 0);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    this._scene.add(floor);
  }

  /**
   * 메쉬에서 사용하는 그래픽 리소스를 해제한다.
   * @param {THREE.Mesh} mesh 메쉬
   */
  disposeMesh(mesh) {
    this.removeMesh(mesh);
  }

  /**
   * 메쉬를 삭제한다.
   * @param {THRE.Mesh} mesh 메쉬
   */
  removeMesh(mesh) {
    if (!mesh) return;
    var list = [];
    mesh.children.forEach(child => list.push(child));
    for (var i = 0; i < list.length; i++) {
      this.removeMesh(list[i]);
    }
    if (mesh.parent) mesh.parent.remove(mesh);
    if (mesh.geometry) {
      if (mesh._disposeGeometry) {
        mesh.geometry.dispose();
        mesh._disposeGeometry = false;
      }
    }
    if (mesh.material) {
      if (mesh._disposeMaterial) {
        mesh.material.dispose();
        mesh._disposeMaterial = false;
      }
    }
  }

  /**
  * 카메라에 붙어 있는 라이트를 생성한다. 
  */
  createCameraLight() {
    this._hemisphereLight = new HemisphereLight(0x909090, 0x707070);
    this._scene.add(this._hemisphereLight);
    this._hemisphereLight2 = new HemisphereLight(0x909090, 0x707070);
    this._scene2.add(this._hemisphereLight2);
    this._cameraLight = new PointLight(0xffffff, 0.6);
    this._camera.add(this._cameraLight);

    //this._cameraLight2 = new THREE.PointLight(0xffffff, 1);
    //this._camera.add(this._cameraLight2);

    this._directionalLight = new DirectionalLight(0xffffff, 1);
    this._scene.add(this._directionalLight);
    this._directionalLight2 = new DirectionalLight(0xffffff, 1);
    this._scene2.add(this._directionalLight2);
    this._ambientLight = new AmbientLight(0x404040); // soft white light
    this._scene.add(this._ambientLight);
    this._ambientLight3 = new AmbientLight(0xffffff); // soft white light
    this._scene.add(this._ambientLight3);
    this._ambientLight2 = new AmbientLight(0xd0d0d0); // soft white light
    this._scene2.add(this._ambientLight2);
    this.setLightMode(0);

    /*
    var light = new THREE.DirectionalLight( 0xffffff );
    light.position.set( 0, 6, 0 );
    light.castShadow = true;
    light.shadow.camera.top = 2;
    light.shadow.camera.bottom = - 2;
    light.shadow.camera.right = 2;
    light.shadow.camera.left = - 2;
    light.shadow.mapSize.set( 4096, 4096 );
    this._scene.add( light );
    */
  }

  /**
  * 라이트 모드를 설정한다. 0,1,2,3,4 5가지 모드가 있다.  
  * @param {Number} mode 라이트 모드
  */
  setLightMode(mode) {
    this._lightMode = mode;
    switch (mode) {
      case 0:
        // camera light + hemi
        this._cameraLight.visible = true;
        this._cameraLight.intensity = Renderer._lightCameraIntensity1;
        this._hemisphereLight.visible = true;
        this._directionalLight.visible = false;
        this._ambientLight.visible = false;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
      case 1:
        // camera 
        this._cameraLight.visible = true;
        this._cameraLight.intensity = Renderer._lightCameraIntensity2;
        this._hemisphereLight.visible = false;
        this._directionalLight.visible = false;
        this._ambientLight.visible = true;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
      case 2:
        // dir + ambient
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = false;
        this._directionalLight.visible = true;
        this._ambientLight.visible = true;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
      case 3:
        // dir
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = false;
        this._directionalLight.visible = true;
        this._ambientLight.visible = false;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
      case 4:
        // no light
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = false;
        this._directionalLight.visible = false;
        this._ambientLight.visible = false;
        this._ambientLight3.visible = true;
        this._ambientLight2.visible = true;
        break;
      case 5:
        // ambient only
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = false;
        this._directionalLight.visible = false;
        this._ambientLight.visible = true;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
      case 6:
        // ambient only
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = true;
        this._directionalLight.visible = true;
        this._ambientLight.visible = true;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = false;
        break;
      case 7:
        // ambient only
        this._cameraLight.visible = false;
        this._hemisphereLight.visible = true;
        this._directionalLight.visible = false;
        this._ambientLight.visible = true;
        this._ambientLight3.visible = false;
        this._ambientLight2.visible = true;
        break;
    }
  }

  /**
  * 현재 브라우져가 어떤 브라우져인지 확인한다. 
  */
  checkBrowser() {
    this._isChromium = window.chrome;
    //this._winNav = window.navigator;
    //this._vendorName = winNav.vendor;
    //this._isOpera = typeof window.opr !== "undefined";
    this._isIEedge = window.navigator.userAgent.indexOf("Edge") > -1;
    this._isIOSChrome = window.navigator.userAgent.match("CriOS");
  }

  /**
   * 콜백 함수를 설정한다.
   * @param {Function} cb_func 콜백 함수
   */
  setCallback(cb_func) {
    this._callback = cb_func;
  }

  /**
  * 한 프레임을 렌더링 한다.
  */
  render() {
    //rayLog(3, "cam pos :" + this._cameraO.position.x + "   " + this._cameraO.position.y + "   " + this._cameraO.position.z + "   " );

    if (this._callback) this._callback(this._clock.getDelta());
    this._renderer.autoClear = true;

    //this._renderer.clear();
    if (this._useEffectComposer) {
      this._effectComposer.render();
    } else {
      this._renderer.render(Renderer.I._scene, Renderer.I._camera);
    }
    this._renderer.autoClear = false;
    this._renderer.clearDepth();
    this._renderer.render(Renderer.I._scene2, Renderer.I._camera);
    if (this._controls) this._controls.update(this._clock.getDelta());

    //this._renderer.render(Renderer.I._sceneUI, Renderer.I._camera);
  }

  /**
  * 현재 Scene의 오브젝트를 모두 지운다.
  */
  clearScene() {
    /*
    while(this._scene.children.length > 0){ 
        this._scene.remove(this._scene.children[0]); 
    }
    */
  }

  /**
  * 한 프레임을 렌더링 할 때 필요한 작업을 한다.
  */
  tick() {
    this._dtime = this._clock.getDelta();
    const delta = this.getDeltaTime();

    // axisGeom update
    this._axisGeom.updateAxisMesh();
    if (this._cubeGeom) this._cubeGeom.updateAxisMesh();
    if (this._cameraMode == "P") {
      let pos = this._cameraP.position;
      this._cameraP.position.set(pos.x, pos.y, pos.z);
    } else if (this._cameraMode == "O") {
      this._cameraO.position.set(this._cameraO.position.x, this._cameraO.position.y, this._cameraO.position.z);
    }
  }

  /**
  * 현재 프레임의 delta time을 구한다.
  * @returns delta time
  */
  getDeltaTime() {
    return this._dtime;
  }

  /**
  * obj Mesh가 화면에 가득 보이도록 카메라의 위치를 조정한다. 
  * @param {Three.Mesh} obj 화면에 보일 Three.js Mesh
  */
  autofitOrthoCamera(obj) {
    //rayLog(3,"prev cam near :" + this._cameraO.near+"   far:" +  this._cameraO.far);
    //rayLog(3,"prev zoom:" + this._cameraO.zoom);
    //rayLog(3,"prev box :" + this._cameraO.left + "  "+this._cameraO.top + "   "+   this._cameraO.right + "  "+this._cameraO.bottom );

    var bbox = new Box3();
    bbox.expandByObject(obj);

    // no object, so bbox is invalid
    if (bbox.min.x > bbox.max.x || bbox.min.y > bbox.max.y) return;
    rayLog(3, "all bbox " + bbox.min.x + "," + bbox.min.y + "," + bbox.max.x + "," + bbox.max.y);
    var center = new three_module_Vector3();
    bbox.getCenter(center);
    var size = new three_module_Vector3();
    bbox.getSize(size);
    var zoom = size.x;
    if (zoom < size.y) zoom = size.y;
    zoom = 1 / zoom * 10;
    var cpos = new three_module_Vector3();
    cpos.x = (this._camera.left + this._camera.right) * 0.5;
    cpos.y = (this._camera.top + this._camera.bottom) * 0.5;
    var dir = new three_module_Vector3();
    this._camera.getWorldDirection(dir);
    dir.normalize();
    dir.multiplyScalar(-this._ocameraDistan);
    var pos = new three_module_Vector3();
    pos.add(center);
    pos.add(dir);
    /*
    console.log+= move.x;
    this._camera.right += move.x;
      this._camera.top += move.y;
    this._camera.bottom += move.y;
    */

    this._camera.position.set(pos.x, pos.y, pos.z);
    this._camera.zoom = zoom;
    this._controls.target.set(center.x, center.y, center.z);
    this._controls.update();
    this._controls.saveState();
    this._controls.zoom0 = zoom;
    this._controls.reset();
    rayLog(3, "new cam near :" + this._cameraO.near + "   far:" + this._cameraO.far);
    rayLog(3, "new zoom:" + this._cameraO.zoom);
    rayLog(3, "new box :" + this._cameraO.left + "  " + this._cameraO.top + "   " + this._cameraO.right + "  " + this._cameraO.bottom);
  }

  /**
  * 카메라를 local 좌표계의 y축을 중심으로 회전시킨다. 
  * @param {Number} delta 회전 시킬 delta time
  */
  doCameraRotate(delta, axis = 0) {
    // up vector 구하기
    // 회전 quaternion구하고 matrix구하기
    // 

    let forward = new three_module_Vector3(0, 0, 1);
    let up = new three_module_Vector3(0, 1, 0);
    let right = new three_module_Vector3(1, 0, 0);
    if (axis == 1) {
      up = right;
    } else if (axis == 2) {
      up = forward;
    }
    var pos = this._camera.position.clone();
    var center = this._controls.target.clone();
    var quaternion = new Quaternion();
    pos.sub(center);
    pos.applyQuaternion(quaternion.setFromAxisAngle(up, delta));
    pos.add(center);
    this._camera.position.set(pos.x, pos.y, pos.z);
    this._controls.target.set(center.x, center.y, center.z);
    this._controls.update();
  }
  autofit3DOrthoCameraBBox(bounding_box, min_dist) {
    var bbox = bounding_box;
    var size = new three_module_Vector3();
    bbox.getSize(size);
    var zoom = size.x;
    if (zoom < size.y) zoom = size.y;
    if (zoom < size.z) zoom = size.z;
    zoom = 1 / zoom * 150;
    var center = new three_module_Vector3();
    bbox.getCenter(center);
    var r = size.length();
    this._ocameraDistance = r * 1.5;
    var dir = new three_module_Vector3();
    this._cameraO.getWorldDirection(dir);
    dir.normalize();
    dir.multiplyScalar(-this._ocameraDistance);
    var pos = new three_module_Vector3();
    pos.add(center);
    pos.add(dir);

    //this._camera.position.set(-0.97,1.59,-8.76);
    //this._controls.update();

    this._cameraZoomO = zoom;
    this._cameraO.position.set(pos.x, pos.y, pos.z);
    this._cameraO.zoom = zoom;
    this._controls.position0.set(pos.x, pos.y, pos.z);
    this._controls.target0.set(center.x, center.y, center.z);
    this._controls.zoom0 = zoom;
    this._controls.reset();
  }

  /**
  * Orthographic camera를 사용하여 obj_list들 모두가 잘 보이도록 설정한다. 
  * @param {Array} obj_list 화면에 보일 Three.js Mesh들의 array
  * @param {Number} min_dist 카메라의 최소 거리
  */
  autofit3DOrthoCameraObjList(obj_list) {
    var bbox = new Box3();
    const len = obj_list.length;
    for (var i = 0; i < len; i++) {
      var obj = obj_list[i];
      bbox.expandByObject(obj);
    }
    this.autofit3DOrthoCameraBBox(bbox);
  }

  /**
   * Orthographic camera를 사용하여 point_list에 포함된 점들 모두가 잘 보이도록 설정한다.
   * @param {Array} point_list 화면에 보일 Point들의 array
   */
  autofit3DOrthoCameraPointList(point_list) {
    var bbox = new Box3();
    const len = point_list.length;
    for (var i = 0; i < len; i++) {
      bbox.expandByPoint(point_list[i]);
    }
    this.autofit3DOrthoCameraBBox(bbox);
  }

  /**
   * 카메라를 bounding box 의 영역에 맞춘다.
   * @param {THREE.Box} bounding_box bounding box
   * @param {Number} min_dist 카메라 최소 거리
   */
  autofitCameraBBox(bounding_box, min_dist) {
    var bbox = bounding_box;
    var center = new three_module_Vector3();
    bbox.getCenter(center);
    var size = new three_module_Vector3();
    bbox.getSize(size);
    var r = size.length();
    let vfov = this._camera.fov;
    let hfov = this._camera.fov * this._windowWidth / this._windowHeight;
    var vdist = -r / Math.tan(vfov * Math.PI / 180) * 0.95;
    var hdist = -r / Math.tan(hfov * Math.PI / 180) * 0.95;
    var dist = hdist;
    if (vdist < hdist) {
      dist = vdist;
    }
    if (min_dist) {
      if (dist > -min_dist) dist = -min_dist;
    }
    var dir = new three_module_Vector3();
    this._camera.getWorldDirection(dir);
    dir.normalize();
    dir.multiplyScalar(dist);
    var pos = new three_module_Vector3();
    pos.add(center);
    pos.add(dir);

    //this._camera.position.set(-0.97,1.59,-8.76);
    //this._controls.update();

    this._camera.position.set(pos.x, pos.y, pos.z);
    this._controls.target.set(center.x, center.y, center.z);
    this._controls.update();
  }

  /**
  * Perspective camera를 사용하여 obj_list들 모두가 잘 보이도록 설정한다.
  * @param {Array} obj_list 화면에 보일 Three.js Mesh들의 array
  * @param {Number} min_dist 카메라의 최소 거리
  */
  autofitCameraObjList(obj_list, min_dist) {
    if (this._isOrthoCamera) {
      this.autofit3DOrthoCameraObjList(obj_list, min_dist);
      return;
    }
    var bbox = new Box3();
    const len = obj_list.length;
    for (var i = 0; i < len; i++) {
      var obj = obj_list[i];
      bbox.expandByObject(obj);
    }
    this.autofitCameraBBox(bbox, min_dist);
  }

  /**
   * Perspective camera를 사용하여 point_list에 포함된 점들 모두가 잘 보이도록 설정한다.
   * @param {Array} point_list 화면에 보일 Point들의 array
   * @param {any} min_dist 카메라의 최소 거리
   */
  autofitCameraPointList(point_list, min_dist) {
    if (this._isOrthoCamera) {
      this.autofit3DOrthoCameraPointList(point_list, min_dist);
      return;
    }
    var bbox = new Box3();
    const len = point_list.length;
    for (var i = 0; i < len; i++) {
      bbox.expandByPoint(point_list[i]);
    }
    this.autofitCameraBBox(bbox, min_dist);
  }

  /**
  * 카메라가 분자를 다 볼 수 있도록 분자의 위치를 계산한다.
  * @param {Three.Mesh} obj 화면에 보일 Three.js Mesh
  */
  autofitCamera(obj) {
    var obj_list = [obj];
    if (this._isOrthoCamera) {
      return this.autofitOrthoCamera(obj);
      //this.autofit3DOrthoCameraObjList(obj_list);
    } else {
      return this.autofitCameraObjList(obj_list, 0.1);
    }
  }

  /**
  * 윈도우 크기가 변경되었을 때 필요한 처리를 한다.
  * @param {Number} innerWidth - 윈도우 width
  * @param {Number} innerHeight - 윈도우 height
  */
  onWindowResize(width, height) {
    //console.log(this._camera);
    //console.log(this._renderer);

    //var width = document.getElementById(this._appname + "_rbase").clientWidth;
    //var height = document.getElementById(this._appname + "_rbase").clientHeight;
    //var width = this._div.clientWidth;
    //var height = this._div.clientHeight;

    //this._container.style.width = width + "px";
    //this._container.style.height = height + "px";

    if (this._camera) {
      if (this._is2DOrthoCamera || this._isOrthoCamera) {
        var aspect = width / height;
        var ch = this._cameraOrthoTop - this._cameraOrthoBottom;
        this._camera.left = -aspect * ch / 2;
        this._camera.right = aspect * ch / 2;
        this._camera.bottom = -ch / 2;
        this._camera.top = ch / 2;
        this._camera.updateProjectionMatrix();
        this._camera.updateMatrix();
        this._camera.updateMatrixWorld(true);
      } else {
        this._camera.aspect = width / height;
        this._camera.updateProjectionMatrix();
        this._camera.updateMatrix();
        this._camera.updateMatrixWorld(true);
      }
    }
    if (this._controls) {
      //this._controls.handleResize();
      this._controls.update();
    }
    this._renderer.setSize(width, height);
    this._windowWidth = width;
    this._windowHeight = height;
    this._effectComposer.setSize(width, height);

    //this.setResizeUI(innerWidth, innerHeight);
  }

  /**
  * 렌더러를 사용하여 한 프레임을 렌더링 한다. 주로 렌더 화면을 export할 때 사용한다. 
  * @param {Renderer} orenderer 렌더링에 사용될 Renderer클래스
  */
  renderFrameFromOtherRenderer(orenderer) {
    this._renderer.clear();
    this._renderer.render(orenderer._scene, orenderer._camera);
  }

  /**
  * 현재 렌더링 된 화면을 이미지로 추출하여 저장한다.
  * @param {String} filename 저장할 파일 이름
  */
  saveScreenshot(filename) {
    var dataURL = this._renderer.domElement.toDataURL();

    //var data = dataURL.replace(strMime, strDownloadMime);

    var link = document.createElement('a');
    if (typeof link.download === 'string') {
      document.body.appendChild(link); //Firefox requires the link to be in the body
      link.download = filename;
      link.href = dataURL;
      link.click();
      document.body.removeChild(link); //remove the link when done
    } else {
      location.replace(uri);
    }
  }

  /**
  * 렌더 버퍼에 사용될 렌더 타켓  WebGLRenderTarget 을 생성한다.
  * @param {Number} width RenderTarget의 width
  * @param {Number} height RenderTarget의 height
  * @returns 생성된 WebGLRenderTarget
  */
  createRenderTarget(width, height) {
    var bufferTexture = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter
    });
    return bufferTexture;
  }

  /**
  * WebGLRenderTarget 버퍼를 삭제한다. 
  * @param {Three.WebGLRenderTarget} texture 삭제할 버퍼
  */
  deleteRenderTarget(texture) {
    texture.dispose();
  }

  /**
  * 파라메터로 받은 버퍼 텍스쳐에 렌더링한다. 
  * @param {Three.WebGLRenderTarget} texture 렌더링에 사용될 버퍼 텍스쳐
  */
  renderToTexture(texture) {
    this._renderer.render(Renderer.I._scene, Renderer.I._camera, texture);
  }

  /**
  * 물체를 피킹 하는 함수
  * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
  * @returns 피킹된 Three.js Mesh 클래스를 리턴
  */
  pickObject(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    this._intersectedObjects = this._raycaster.intersectObjects(this._scene.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      if (obj._canPick) {
        this._pickedObject = obj;
        return obj;
      }
    }
    return null;
  }

  /**
  * 물체를 피킹 하는 함수. 메쉬의 피킹 가능 여부를 비교하지 않고 모든 물체를 비교한다. 
  * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
  * @returns 피킹된 Three.js Mesh 클래스를 리턴
  */
  pickObjectAny(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    this._intersectedObjects = this._raycaster.intersectObjects(this._scene.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      this._pickedObject = obj;
      return obj;
    }
    return null;
  }

  /**
  * 단백질의 아톰 메쉬를 피킹 하는 함수
  * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
  * @returns 피킹된 Three.js Mesh 클래스를 리턴
  */
  pickObjectAtom(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    this._intersectedObjects = this._raycaster.intersectObjects(this._scene.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      if (!obj._isAtom && !obj._instancedAtom) continue;
      this._pickedObject = obj;
      var paObj = {};
      paObj._obj = obj;
      paObj._PVID = obj._PVID;
      paObj._symmIdx = obj._symmIdx;
      if (obj._instancedAtom) {
        paObj._instancedAtom = true;
        paObj._instanceId = this._intersectedObjects[i].instanceId;
        paObj._iatom = obj._iprotein.getIAtomWithIndex(paObj._instanceId);
        let pos = paObj._iatom.getWorldPosition();
        console.log("intersection idx : " + paObj._instanceId);
        console.log("intersection point : " + this._intersectedObjects[i].point.x + "," + this._intersectedObjects[i].point.y + "," + this._intersectedObjects[i].point.z);
        console.log("atom point : " + pos.x + "," + pos.y + "," + pos.z);
      } else {
        paObj._instancedAtom = false;
        paObj._iatom = obj._iatom;
      }
      return paObj;
    }
    return null;
  }

  /**
  * CAD 물체를 피킹 하는 함수
  * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
  * @returns 피킹된 Three.js Mesh 클래스를 리턴
  */
  pickObjectCAD(normalizedPosition, group) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    let borigin = this._raycaster.ray.origin.clone().sub(this._raycaster.ray.direction.clone().multiplyScalar(1000));
    this._raycaster.ray.origin = borigin;
    this._intersectedObjects = this._raycaster.intersectObjects(group.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      if (obj._canPick) {
        this._pickedObject = obj;
        return obj;
      }
    }
    return null;
  }

  /**
  * 물체를 피킹 하는 함수
  * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
  * @returns 피킹된 Three.js Mesh 클래스를 리턴
  */
  pickObjectPosition(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    this._intersectedObjects = this._raycaster.intersectObjects(this._scene.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      if (obj._canPick) {
        let pos = this._intersectedObjects[i].point;
        //rayLog(3, "pick obj id " + obj._id + " on pos " + pos.x + "," + pos.y + "," + pos.z);
        return pos;
      }
    }

    //rayLog(3, "no pick obj pos " + Date.now());
    return null;
  }

  /**
   * Crystal Shape Face를 피킹 하는 함수.
   * @param {Array} normalizedPosition 좌표 : ([-1,1], [-1,1]) 좌표계, y축 반전임.
   * @returns 피킹된 Three.js Face 클래스를 리턴
   */
  pickObjectCrystalFace(normalizedPosition) {
    this._raycaster.setFromCamera(normalizedPosition, this._camera);
    this._intersectedObjects = this._raycaster.intersectObjects(this._scene.children, true);
    this._pickedObject = null;
    for (var i = 0; i < this._intersectedObjects.length; i++) {
      var obj = this._intersectedObjects[i].object;
      if (!this.isObjVisible(obj)) continue;
      if (obj._crystalFace) {
        let face = this._intersectedObjects[i].face;
        let posarr = obj.geometry.attributes.position.array;
        let v1 = new three_module_Vector3(posarr[3 * face.a], posarr[3 * face.a + 1], posarr[3 * face.a + 2]);
        let v2 = new three_module_Vector3(posarr[3 * face.b], posarr[3 * face.b + 1], posarr[3 * face.b + 2]);
        let v3 = new three_module_Vector3(posarr[3 * face.c], posarr[3 * face.c + 1], posarr[3 * face.c + 2]);
        let mp = v1.clone().add(v2).add(v3).multiplyScalar(1.0 / 3.0);
        face.v1 = v1;
        face.v2 = v2;
        face.v3 = v3;
        face.midpoint = mp;
        return face;
      }
    }
    return null;
  }

  /**
  * 주어진 Mesh가 visible한지 판단한다. 
  * @param {Three.Mesh} obj Three.js Mesh
  * @returns 가시화 여부
  */
  isObjVisible(obj) {
    if (!obj) return true;
    if (!obj.visible) {
      return false;
    }
    return this.isObjVisible(obj.parent);
  }

  /**
   * Axis 표시 뷰포트 영역을 설정한다.
   * @param {Number} x 뷰포트 영역 x값
   * @param {Number} y 뷰포트 영역 y값
   * @param {Number} z 뷰포트 영역 z값
   * @param {Number} w 뷰포트 영역 w값
   */
  setAxisViewportPosition(x, y, z, w) {
    if (this._axisGeom) {
      this._axisGeom.setViewportPosition(x, y, z, w);
    }
  }

  /**
   * 
   * */
  createCameraCubeGeom() {
    if (this._cubeGeom) {
      this._scene2.remove(this._cubeGeom._cube);
      this._cubeGeom = null;
    }
    this._cubeGeom = new CameraCubeGeom(this);
    this._cubeGeom.createMesh();
  }
}
;
;// CONCATENATED MODULE: ./Renderer/GeomMole.js









/**
 * Geom을 렌더링하는 클래스
 * */
class GeomMole {
  static AtomRadius = {
    "H": 1.2,
    "He": 1.4,
    "Li": 1.82,
    "Be": 1.53,
    "B": 1.92,
    "C": 1.7,
    "N": 1.55,
    "O": 1.52,
    "F": 1.47,
    "Ne": 1.54,
    "Na": 2.27,
    "Mg": 1.73,
    "Al": 1.84,
    "Si": 2.1,
    "P": 1.8,
    "S": 1.8,
    "Cl": 1.75,
    "Ar": 1.88,
    "K": 2.75,
    "Ca": 2.31,
    "Ni": 1.63,
    "Cu": 1.4,
    "Zn": 1.39,
    "Ga": 1.87,
    "Ge": 2.11,
    "As": 1.85,
    "Se": 1.9,
    "Br": 1.85,
    "Kr": 2.02,
    "Rb": 3.03,
    "Sr": 2.49,
    "Pd": 1.63,
    "Ag": 1.72,
    "Cd": 1.58,
    "In": 1.93,
    "Sn": 2.17,
    "Sb": 2.06,
    "Te": 2.06,
    "I": 1.98,
    "Xe": 2.16,
    "Cs": 3.43,
    "Ba": 2.68,
    "Pt": 1.75,
    "Au": 1.66,
    "Hg": 1.55,
    "Tl": 1.96,
    "Pb": 2.02,
    "Bi": 2.07,
    "Po": 1.97,
    "At": 2.02,
    "Rn": 2.20,
    "Fr": 3.48,
    "Ra": 2.83,
    "U": 1.86
  };
  static _renderType = 0;
  static _bondCylinder = null;
  static _bondDotCylinder = null;
  static _iBondCylinder = null;
  static _atomSphere = null;
  static _letterAtomGeom = {};
  static _atomRenderType = 0;
  static _geomQuality = 1;

  /**
   * GeomRenderer 생성자
   * @param {any} api 다른 외부 라이브러리와 연동하기 위한 api 객체
   * @param {any} renderer 렌더러
   * @param {any} point_tex_fn 
   */
  static init(atom_render_type) {
    if (!atom_render_type) atom_render_type = 0;
    GeomMole.generateGeometry();
    let shade = 1;
    let len = GeomMole._sphere.attributes.position.array.length / 3;
    let colors = [];
    for (let i = 0; i < len; i++) {
      colors[i * 3 + 0] = shade;
      colors[i * 3 + 1] = shade;
      colors[i * 3 + 2] = shade;
    }
    GeomMole._sphere.setAttribute("color", new Float32BufferAttribute(colors, 3));
    GeomMole._atomRenderType = atom_render_type;
  }

  /**
   * Mesh Qualitry 값을 반환한다.
   * @returns {Number} Mesh Quality 값
   * */
  static getMeshQuality() {
    return GeomMole._geomQuality * 30 + 20;
  }

  //mesh quality
  //low: 0
  //medium: 1
  //high: 2
  //very high: 3

  /**
  * Geometry를 생성한다.
  * */
  static generateGeometry() {
    GeomMole.generateBondCylinder();
    let div = GeomMole.getMeshQuality();
    GeomMole._sphere = new SphereGeometry(1, div, div / 2);
  }

  /**
   * Mesh Quality 값을 설정한다.
   * @param {Number} quality 설정값
   */
  static setQuality(quality) {
    GeomMole._geomQuality = quality;
    GeomMole.generateGeometry();
  }

  /**
   * 현재 Mesh Quality 설정값을 반환한다.
   * @returns {Number} 현재 Mesh Quality 설정값
   * */
  static getQuality() {
    return GeomMole._geomQuality;
  }

  /**
   * 결합 실린더 geometry 를 생성한다.
   * */
  static generateBondCylinder() {
    let div = GeomMole.getMeshQuality() / 4;
    GeomMole._iBondCylinder = new CylinderGeometry(1, 1, 1, div).lookAt(new three_module_Vector3(0, 10, 0));
    GeomMole._iBondCylinder.applyMatrix4(new Matrix4().makeTranslation(0, 0, 0.5));
    GeomMole._bondCylinder = new CylinderGeometry(1, 1, 1, div).lookAt(new three_module_Vector3(0, 10, 0));
    GeomMole._bondCylinder.applyMatrix4(new Matrix4().makeTranslation(0, 0, 0.5));
    GeomMole._bondCylinder.computeBoundingSphere();
    let dot1 = new CylinderGeometry(1, 1, 1, div).lookAt(new three_module_Vector3(0, 10, 0));
    let mat2 = new Matrix4().makeScale(1, 1, .2);
    let mat1 = new Matrix4().makeTranslation(0, 0, 0.1 + 0.3).multiply(mat2);
    dot1.applyMatrix4(mat1);
    let dot2 = new CylinderGeometry(1, 1, 1, div).lookAt(new three_module_Vector3(0, 10, 0));
    mat2.makeScale(1, 1, .2);
    mat1.makeTranslation(0, 0, 0.1 + 0.3 + 0.4).multiply(mat2);
    dot2.applyMatrix4(mat1);
    GeomMole._bondDotCylinder = BufferGeometryUtils.mergeBufferGeometries([dot1, dot2], false);
  }

  /**
   * 원소 렌더링 타입 설정값을 반환한다.
   * @returns {Number} 원소 렌더링 타입 설정값
   * */
  static getAtomRenderType() {
    return GeomMole._atomRenderType;
  }

  /**
   * 원소 렌더링 타입 값을 설정한다.
   * @param {Number} type 렌더링 타입
   */
  static setAtomRenderType(type) {
    GeomMole._atomRenderType = type;
  }

  /**
   * 분자를 하나의 메쉬로 생성한다.
   * @param {any} geom_renderer Geom Renderer
   * @param {any} atom_list 원자 리스트
   * @param {any} bond_list 본드 리스트
   */
  static generateOneMeshMole(geom_renderer, atom_list, bond_list) {}

  /**
   * 분자를 여러개의 메쉬로 생성한다.
   * @param {any} alist 원자 리스트
   * @param {any} blist 본드 리스트
   */
  static generateMoleWithMultipleMesh(alist, blist) {}

  /**
   * 본드 메쉬를 생성한다.
   * @param {any} pos1 본드 끝점 1 위치
   * @param {any} pos2 본드 끝점 2 위치
   * @param {any} atomADef Atom A 정의
   * @param {any} atomBDef Atom B 정의
   * @param {any} is_ionic Ionic 플래그
   * @param {any} dpos displacement pos
   * @param {any} radius_scale 본드 실린더 스케일
   * @param {any} materials 렌더링 매터리얼
   */
  static createBondMesh(pos1, pos2, atomADef, atomBDef, is_ionic, dpos, radius_scale, materials) {
    let a = pos1.clone();
    let b = pos2.clone();
    let center = new three_module_Vector3(a.x, a.y, a.z).add(b).multiplyScalar(0.5);
    ;
    let vba = b.clone();
    const len = vba.sub(a).length() / 2;
    var vn = vba.clone();
    var vup = new three_module_Vector3(0, 1, 0);
    vn.cross(vup);
    vn.normalize();
    var disp = vn.clone();
    disp.multiplyScalar(dpos);
    a.add(disp);
    b.add(disp);
    center.add(disp);
    let ionic = is_ionic;
    let geometry = GeomMole._bondCylinder;
    if (ionic) {
      if (ionic == 1) {
        geometry = GeomMole._bondDotCylinder;
      }
    }
    var mat1 = null;
    var mat2 = null;
    if (materials) {
      mat1 = materials[0];
      mat2 = materials[1];
    } else {
      mat1 = new MeshLambertMaterial();
      mat2 = new MeshLambertMaterial();
    }
    var mesh1 = new three_module_Mesh(geometry, mat1);
    mesh1.position.copy(a);
    mesh1.lookAt(center);
    mat1.color = new Color(atomADef._color[0], atomADef._color[1], atomADef._color[2]);
    mesh1._mat = mat1;
    mesh1._originalColorR = atomADef._color[0];
    mesh1._originalColorG = atomADef._color[1];
    mesh1._originalColorB = atomADef._color[2];
    mesh1._first = true;
    mesh1._atomDef = atomADef;
    var radius = radius_scale;
    mesh1.scale.set(radius, radius, len);
    mesh1._radiusScale = radius_scale;
    var mesh2 = new three_module_Mesh(geometry, mat2);
    mesh2.position.copy(b);
    mesh2.lookAt(center);
    mat2.color = new Color(atomBDef._color[0], atomBDef._color[1], atomBDef._color[2]);
    mesh2._mat = mat2;
    mesh2._originalColorR = atomBDef._color[0];
    mesh2._originalColorG = atomBDef._color[1];
    mesh2._originalColorB = atomBDef._color[2];
    mesh2._atomDef = atomBDef;
    mesh2._radiusScale = radius_scale;
    mesh2.scale.set(radius, radius, len);
    return [mesh1, mesh2];
  }

  /**
   * Bond를 생성한다
   * @param {any} gr geom renderer
   * @param {any} geom geom 객체
   * @param {any} parent geom의 parent
   * @param {any} dpos displacement pos
   * @param {any} radius_scale 본드 실린더 스케일
   * @param {any} rep_bond 
   * @returns {THREE.Mesh} 생성된 메쉬
   */
  static generateBond(gr, geom, parent, dpos, radius_scale, rep_bond) {
    const atomA_id = geom.GetAtom1ID();
    const atomA = gr._geomDic[atomA_id];
    if (!atomA) {
      return null;
    }
    const atomB_id = geom.GetAtom2ID();
    const atomB = gr._geomDic[atomB_id];
    if (!atomB) {
      return null;
    }
    let atomADef = AtomDef_AtomDef.GetDefWithNumber(atomA.GetAtomNumber());
    let atomBDef = AtomDef_AtomDef.GetDefWithNumber(atomB.GetAtomNumber());
    let aa = new three_module_Vector3(atomA.GetX(), atomA.GetY(), atomA.GetZ());
    let bb = new three_module_Vector3(atomB.GetX(), atomB.GetY(), atomB.GetZ());
    let ionic = geom.GetTag("i");
    let meshes = GeomMole.createBondMesh(aa, bb, atomADef, atomBDef, ionic, dpos, radius_scale);
    let mesh1 = meshes[0];
    let mesh2 = meshes[1];
    if (rep_bond) {
      gr.updateMeshWithID(mesh1, 0, geom, parent);
      gr.updateMeshWithID(mesh2, 0, geom, parent);
      rep_bond._children.push(mesh1);
      rep_bond._children.push(mesh2);
    } else {
      gr.updateMesh(mesh1, geom, parent);
      gr.updateMeshWithID(mesh2, 0, geom, parent);
      mesh1._children = [];
      mesh1._children.push(mesh2);
    }
    return mesh1;
  }

  /**
   * Bond를 메쉬를 생성한다
   * @param {any} gr geom renderer
   * @param {any} geom geom 객체
   * @param {any} parent geom의 parent
   * @returns {THREE.Mesh} 생성된 메쉬
   */
  static genBond(gr, geom, parent) {
    const type = geom.GetBondType();
    var mesh1;
    switch (type) {
      case 1:
        mesh1 = GeomMole.generateBond(gr, geom, parent, 0, 0.15);
        break;
      case 2:
        mesh1 = GeomMole.generateBond(gr, geom, parent, 0.15, 0.15);
        GeomMole.generateBond(gr, geom, parent, -0.15, 0.15, mesh1);
        break;
      case 3:
        mesh1 = GeomMole.generateBond(gr, geom, parent, 0.15, 0.15);
        GeomMole.generateBond(gr, geom, parent, 0, 0.15, mesh1);
        GeomMole.generateBond(gr, geom, parent, -0.15, 0.15, mesh1);
        break;
    }
    return mesh1;
  }

  /**
   * 원자 메쉬를 생성한다.
   * @param {any} pos 원자 위치
   * @param {any} radius 반지름
   * @param {any} atom_def 원소 정의
   * @param {any} mat 매터리얼
   */
  static createAtomMesh(pos, radius, atom_def, mat) {
    let material = null;
    if (mat) {
      material = mat;
    } else {
      material = new MeshLambertMaterial({
        color: 0x0000ff,
        vertexColors: false
      });
    }
    material.color = new Color(atom_def._color[0], atom_def._color[1], atom_def._color[2]);
    let geometry = GeomMole.getAtomGeometry(atom_def._atom_number, Renderer._renderer);
    const mesh = new three_module_Mesh(geometry, material);
    mesh._mat = material;
    mesh.position.copy(pos);
    mesh.scale.set(radius, radius, radius);
    mesh._originalColorR = atom_def._color[0];
    mesh._originalColorG = atom_def._color[1];
    mesh._originalColorB = atom_def._color[2];
    mesh._disposeMaterial = true;
    mesh._disposeGeometry = false;
    mesh._isAtom = true;
    mesh._atomType = atom_def._atom_number;
    mesh._atomDef = atom_def;
    return mesh;
  }

  /**
   * 유닛 셀 메쉬를 생성한다.
   * @param {any} geom geom 객체
   * @param {any} renderer 렌더러
   */
  static createUnitcellMesh(geom, renderer) {
    let mesh = renderer._geomRenderer.generateOne(geom, null);
    return mesh;
  }

  /**
   * Atom을 생성한다
   * @param {any} gr geom renderer
   * @param {any} geom geom 객체
   * @param {any} parent geom의 parent
   * @returns {THREE.Mesh} 생성된 메쉬
   */
  static genAtom(gr, geom, parent) {
    const atomid = geom.GetAtomNumber();
    let adef = AtomDef_AtomDef._atomNumList[atomid];
    const center = geom.GetCenter();
    let pos = new three_module_Vector3(center[0], center[1], center[2]);
    let mesh = GeomMole.createAtomMesh(pos, 0.3, adef);
    mesh._id = geom.GetID();
    gr.updateMesh(mesh, geom, parent);
    return mesh;
  }

  /**
   * 원자 구 지오메트리를 반환한다.
   * @returns {THREE.Geometry} Geometry
   * */
  static getAtomSphereGeometry() {
    return GeomMole._sphere;
  }

  /**
   * 원소 Geometry 를 반환한다.
   * @param {any} atomid
   * @param {any} renderer
   * @returns {THREE.Geometry} 원소 Geometry
   */
  static getAtomGeometry(atomid, renderer) {
    let geometry = GeomMole._sphere;
    if (GeomMole._atomRenderType == 1) {
      geometry = GeomMole._letterAtomGeom[atomid];
      if (!geometry) {
        let adef = AtomDef_AtomDef.GetDefWithNumber(atomid);
        geometry = GeomMole.createAtomGeometryWithLetter(adef._atom_id, renderer._font);
        GeomMole._letterAtomGeom[atomid] = geometry;
      }
    }
    return geometry;
  }

  /**
   * 원소 기호 모델이 포함된 원소 Geometry 를 생성한다.
   * @param {any} atom_letter
   * @param {any} font
   * @returns {THREE.Geometry} 원소 Geometry
   */
  static createAtomGeometryWithLetter(atom_letter, font) {
    // atom sphere geometry 생성하기
    //let atomSphere = new THREE.SphereBufferGeometry(1, 64, 64);
    let atomSphere = GeomMole._sphere.clone();

    // atom letter geometry 생성하기
    const id = atom_letter;
    const size = 1;
    const depth = 1;
    let fsize = 1;
    let atomFrontLetter = new TextGeometry(id, {
      font: font,
      size: 0.8 * fsize,
      height: 0.1 * fsize,
      curveSegments: 12,
      bevelEnabled: false,
      bevelThickness: 0.005 * fsize,
      bevelSize: 0.01 * fsize,
      bevelOffset: 0,
      bevelSegments: 5
    });
    let fIndex = [];
    for (let i = 0; i < atomFrontLetter.attributes.position.count; ++i) {
      fIndex.push(i);
    }
    atomFrontLetter.index = new Uint16BufferAttribute(fIndex, 1);
    let shade = 0.3;
    let len = atomFrontLetter.attributes.position.array.length / 3;
    let colors = [];
    for (let i = 0; i < len; i++) {
      colors[i * 3 + 0] = shade;
      colors[i * 3 + 1] = shade;
      colors[i * 3 + 2] = shade;
    }
    atomFrontLetter.setAttribute("color", new Float32BufferAttribute(colors, 3));
    atomFrontLetter.scale(size, size, size);
    atomFrontLetter.center();
    atomFrontLetter.translate(0, 0, depth);
    let atomBackLetter = new TextGeometry(id, {
      font: font,
      size: 0.8 * fsize,
      height: 0.1 * fsize,
      curveSegments: 12,
      bevelEnabled: false,
      bevelThickness: 0.005 * fsize,
      bevelSize: 0.01 * fsize,
      bevelOffset: 0,
      bevelSegments: 5
    });
    let bIndex = [];
    for (let i = 0; i < atomBackLetter.attributes.position.count; ++i) {
      bIndex.push(i);
    }
    atomBackLetter.index = new Uint16BufferAttribute(bIndex, 1);

    //shade = 0.3;
    len = atomBackLetter.attributes.position.array.length / 3;
    colors = [];
    for (let i = 0; i < len; i++) {
      colors[i * 3 + 0] = shade;
      colors[i * 3 + 1] = shade;
      colors[i * 3 + 2] = shade;
    }
    atomBackLetter.setAttribute("color", new Float32BufferAttribute(colors, 3));
    atomBackLetter.rotateY(180 * 3.1415 / 180);
    atomBackLetter.scale(size, size, size);
    atomBackLetter.center();
    atomBackLetter.translate(0, 0, -depth);
    let mergedGeometry = BufferGeometryUtils.mergeBufferGeometries([atomSphere, atomBackLetter, atomFrontLetter], false);
    return mergedGeometry;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/LatticeAxis.js



const _axisX = new three_module_Vector3(1, 0, 0);
const _axisY = new three_module_Vector3(0, 1, 0);
const _axisZ = new three_module_Vector3(0, 0, 1);
const _degree2radian = 3.1415927 / 180;

/**
 * Lattice Axis 클래스
 * */
class LatticeAxis {
  /**
   * 생성자
   * @param {Number} a alpha
   * @param {Number} b beta
   * @param {Number} c gamma
   * @param {Number} la length a
   * @param {Number} lb length b
   * @param {Number} lc length c
   */
  constructor(a, b, c, la, lb, lc) {
    this._va = new three_module_Vector3();
    this._vb = new three_module_Vector3();
    this._vc = new three_module_Vector3();
    this.set(a, b, c, la, lb, lc);
  }

  /**
   * miller index를 계산한다.
   * @param {Number} h 
   * @param {Number} s
   * @param {Number} v
   * @returns {THREE.Vector3}
   */
  calcMillerIndices(h, s, v) {
    if (h == 0 && s == 0 && v == 0) {
      return null;
    }
    if (h != 0 && s != 0 && v != 0) {
      let _h = 1 / h;
      let _s = 1 / s;
      let _v = 1 / v;
      let a = this._va.clone();
      let b = this._vb.clone();
      let c = this._vc.clone();
      a.multiplyScalar(_h);
      b.multiplyScalar(_s);
      c.multiplyScalar(_v);
      a.add(b);
      a.add(c);
      return a;
    } else if (h == 0 && s != 0 && v != 0) {
      let _s = 1 / s;
      let _v = 1 / v;
      let b = this._vb.clone();
      let c = this._vc.clone();
      b.multiplyScalar(_s);
      c.multiplyScalar(_v);
      b.add(c);
      return b;
    } else if (h != 0 && s == 0 && v != 0) {
      let _h = 1 / h;
      let _v = 1 / v;
      let a = this._va.clone();
      let c = this._vc.clone();
      a.multiplyScalar(_h);
      c.multiplyScalar(_v);
      a.add(c);
      return a;
    } else if (h != 0 && s != 0 && v == 0) {
      let _h = 1 / h;
      let _s = 1 / s;
      let a = this._va.clone();
      let b = this._vb.clone();
      a.multiplyScalar(_h);
      b.multiplyScalar(_s);
      a.add(b);
      return a;
    } else if (h == 0 && s == 0 && v != 0) {
      let _v = 1 / v;
      let c = this._vc.clone();
      c.multiplyScalar(_v);
      return c;
    } else if (h == 0 && s != 0 && v == 0) {
      let _s = 1 / s;
      let b = this._vb.clone();
      b.multiplyScalar(_s);
      return b;
    } else if (h != 0 && s == 0 && v == 0) {
      let _h = 1 / h;
      let a = this._va.clone();
      a.multiplyScalar(_h);
      return a;
    } else {}
    return null;
  }

  /**
   * clone method
   * @returns {LatticeAxis} cloned lattice axis
   * */
  clone() {
    let clone = new LatticeAxis();
    clone._a = this._a;
    clone._b = this._b;
    clone._c = this._c;
    clone._la = this._la;
    clone._lb = this._lb;
    clone._lc = this._lc;
    clone.calculate();
    return clone;
  }

  /**
   * lattice axis 설정
   * @param {Number} a alpha
   * @param {Number} b beta 
   * @param {Number} c gamma
   * @param {Number} la length a
   * @param {Number} lb length b
   * @param {Number} lc length c
   */
  set(a, b, c, la, lb, lc) {
    this._a = a;
    this._b = b;
    this._c = c;
    this._la = la;
    this._lb = lb;
    this._lc = lc;
    this.calculate();
  }

  /**
   * lattice axis의 length를 설정한다.
   * @param {Number} la length a
   * @param {Number} lb length b
   * @param {Number} lc length c
   */
  setLength(la, lb, lc) {
    this._la = la;
    this._lb = lb;
    this._lc = lc;
    this.calculate();
  }

  /**
   * lattice axis의 angle를 설정한다.
   * @param {Number} a alpha
   * @param {Number} b beta
   * @param {Number} c gamma
   */
  setAngle(a, b, c) {
    this._a = a;
    this._b = b;
    this._c = c;
    this.calculate();
  }

  /**
   * lattice axis transform
   * @param {THREE.Vector3} v1 transform을 나타내는 vector
   * @returns {THREE.Vector3}
   */
  transform(v1) {
    let va = this._va.clone();
    let vb = this._vb.clone();
    let vc = this._vc.clone();
    va.multiplyScalar(v1.x);
    vb.multiplyScalar(v1.y);
    vc.multiplyScalar(v1.z);
    va.add(vb).add(vc);
    return va;
  }

  /**
   * lattice axis calculate
   * @returns {THREE.Vector3}
   * */
  calculate_() {
    this._va.fromArray([this._la, 0, 0], 0);
    this._vb.fromArray([this._lb, 0, 0], 0);
    this._vc.fromArray([0, 0, this._lc], 0);
    let q = new Quaternion();
    q.setFromAxisAngle(_axisZ, this._c * _degree2radian);
    this._vb.applyQuaternion(q);
    let cos1 = Math.cos(this._b * _degree2radian);
    let cos2 = Math.cos(this._a * _degree2radian);
    let v1 = this._va.clone();
    v1.normalize();
    let v2 = this._vb.clone();
    v2.normalize();
    let x1 = v1.x;
    let y1 = v1.y;
    let z1 = v1.z;
    let x2 = v2.x;
    let y2 = v2.y;
    let z2 = v2.z;
    let a = cos1 / x1;
    let bb = Math.sqrt(4 * z2 * z2 * cos2 * cos2 - 4 * (z2 * z2 + y2 * y2) * (cos2 * cos2 + a * a * y2 * y2 - y2 * y2));
    let c = (2 * z2 * cos2 + bb) / (2 * (z2 * z2 + y2 * y2));
    let b = (cos2 - c * z2) / y2;
    this._vc.fromArray([a * this._lc, b * this._lc, c * this._lc], 0);
  }

  /**
   * lattice axis calculate
   * */
  calculateAB() {
    this._va.fromArray([this._la, 0, 0], 0);
    this._vc.fromArray([0, 0, this._lc], 0);
    this._vb.fromArray([this._lb, 0, 0], 0);
    let q = new Quaternion();
    q.setFromAxisAngle(_axisZ, this._c * _degree2radian);
    this._vb.applyQuaternion(q);
  }

  /**
   * lattice axis calculate
   * */
  calculateAC() {
    this._va.fromArray([this._la, 0, 0], 0);
    this._vb.fromArray([0, this._lb, 0], 0);
    this._vc.fromArray([this._lc, 0, 0], 0);
    let q = new Quaternion();
    q.setFromAxisAngle(_axisY, -this._b * _degree2radian);
    this._vc.applyQuaternion(q);
  }

  /**
   * lattice axis calculate
   * */
  calculateBC() {
    this._va.fromArray([this._la, 0, 0], 0);
    this._vb.fromArray([0, this._lb, 0], 0);
    this._vc.fromArray([0, this._lc, 0], 0);
    let q = new Quaternion();
    q.setFromAxisAngle(_axisX, this._a * 3.14159 / 180);
    this._vc.applyQuaternion(q);
  }

  /**
   * lattice axis calculate
   * */
  calculateABC() {
    this._va.fromArray([this._la, 0, 0], 0);
    this._vb.fromArray([0, this._lb, 0], 0);
    this._vc.fromArray([0, 0, this._lc], 0);
  }

  /**
   * lattice axis calculate
   * @returns {THREE.Vector3}
   * */
  calculate() {
    if (this._a == 90) {
      if (this._b == 90) {
        if (this._c == 90) {
          return this.calculateABC();
        } else {
          return this.calculateAB();
        }
      }
      if (this._c == 90) {
        return this.calculateAC();
      }
    }
    return this.calculate_();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalVariable.js
var cryst = null;

/**
 * crystal editor app 변수 및 자주 쓰이는 기능 함수 클래스
 * */
class crystalVariable {
  /**
   * 생성자
   * 
   * 변수를 초기 설정 값으로 지정한다.
   * */
  constructor() {
    cryst = this;
    this.RestoreDefault();
  }

  /**
   * crystalVariable을 초기 설정값으로 지정한다.
   * */
  RestoreDefault() {
    this.Boundary = [];
    this.Boundary['minX'] = 0;
    this.Boundary['minY'] = 0;
    this.Boundary['minZ'] = 0;
    this.Boundary['maxX'] = 1;
    this.Boundary['maxY'] = 1;
    this.Boundary['maxZ'] = 1;
    this.Tool = {};
    this.Tool.RotationMode = 0;
    this.Tool.OrientationMode = 0;
    this.Style = {};
    this.Style.ShowModel = true;
    this.Style.ShowDotSurface = false;
    this.Style.StructuralMode = 0;
    this.Style.VolumetricSection = true;
    this.Style.VolumetricIsoSurface = false;
    this.Style.VolumetricSurfaceColor = false;
    this.Style.VolumetricMode = 0;
    this.Style.ShowCrystalShape = true;
    this.Style.CrystalMode = 0;
    this.Name = {};
    this.Name.Axis = {};
    this.Name.Axis.X = "a";
    this.Name.Axis.Y = "b";
    this.Name.Axis.Z = "c";
    this.Unitcell = {};
    this.Unitcell.a = 5;
    this.Unitcell.b = 5;
    this.Unitcell.c = 5;
    this.Unitcell.alpha = 90;
    this.Unitcell.beta = 90;
    this.Unitcell.gamma = 90;
    this.Mode = {};
    this.Mode.Boundary = 1;
    this.Mode.Search = 0;
    this.Mode.AddVector = 0;
    this.Mode.ModifyVector = 1;
    this.RenderOptionDefault = {};
    this.RenderOptionDefault.BackgroundColor = [1, 1, 1];
    this.RenderOptionDefault.ShowAxis = 1;
    this.RenderOptionDefault.LightingMode = 1;
    this.RenderOptionDefault.CameraType = 0;
    this.RenderOptionDefault.Antialiasing = 1;
    this.RenderOptionDefault.AtomStyle = 1;
    this.RenderOptionDefault.BondStyle = 1;
    this.StructurePropertyDefault = {};
    this.StructurePropertyDefault.UnitCell = {};
    this.StructurePropertyDefault.UnitCell.ShowLine = true;
    this.StructurePropertyDefault.UnitCell.Color = [0, 0, 0];
    this.StructurePropertyDefault.Crystal = {};
    this.StructurePropertyDefault.Crystal.ShowColor = true;
    this.StructurePropertyDefault.Crystal.ShowLine = true;
    this.StructurePropertyDefault.Atom = {};
    this.StructurePropertyDefault.Atom.Shininess = 30;
    this.StructurePropertyDefault.Atom.ShowLabel = false;
    this.StructurePropertyDefault.Bond = {};
    this.StructurePropertyDefault.Bond.Shininess = 30;
    this.StructurePropertyDefault.Bond.MeshDetail = 30;
    this.StructurePropertyDefault.Polyhedron = {};
    this.StructurePropertyDefault.Polyhedron.Shininess = 30;
    this.StructurePropertyDefault.Polyhedron.ShowLine = false;
    this.ZoomIn = 3;
    this.ZoomOut = -3;
  }

  /**
   * color array를 html hex 문자열로 바꾼다.
   * @param {Array} color 0~1 사이의 값을 원소로 갖는 길이 3짜리 rgb 배열
   * @return {String} hex color string
   */
  static HTMLColorRGB(color) {
    if (!color) return "000000";
    let r = Math.floor(color[0] * 255).toString(16);
    let g = Math.floor(color[1] * 255).toString(16);
    let b = Math.floor(color[2] * 255).toString(16);
    if (r.length < 2) r = "0" + r;
    if (g.length < 2) g = "0" + g;
    if (b.length < 2) b = "0" + b;
    return r + g + b;
  }

  /**
   * 16진법 문자열을 배열로 바꾼다.
   * @param {String} hex hex color string
   * @return {Array} color array
   */
  static HexStringtoColor(hex) {
    let r = hex.substr(0, 2);
    let g = hex.substr(2, 2);
    let b = hex.substr(4, 2);
    let color = [];
    color.push(Number("0x" + r) / 255);
    color.push(Number("0x" + g) / 255);
    color.push(Number("0x" + b) / 255);
    return color;
  }

  /**
   * color rgb값을 hex number로 바꾼다.
   * @param {Array} color color array (0~1의 값을 가짐)
   */
  static ColorRGBtoHexNum(color) {
    let r = Math.floor(color[0] * 255);
    let g = Math.floor(color[1] * 255);
    let b = Math.floor(color[2] * 255);
    let h = r * 256 * 256 + g * 256 + b;
    return h;
  }

  /**
   * 키워드 파싱
   * @param {String} txt 파싱할 문자열
   * @return {Array} 파싱된 문자열 배열
   */
  static parse(txt) {
    function nextWord() {
      end++;
      start = end;
      wordCount++;
    }
    function nextLine() {
      wordCount = 0;
      let temp = {};
      Object.assign(temp, st);
      ret.push(temp);
    }
    function find(data) {
      if (txt[end] === "(") {
        st[data] = txt.slice(start, end);
        for (let spacePos = 1; spacePos < txt.length - end; spacePos++) {
          if (txt[end + spacePos] === " ") {
            end += spacePos;
            break;
          }
        }
        nextWord();
        if (data === "SOF") {
          nextLine();
        }
      } else if (txt[end] === " ") {
        if (data === "name") {
          if (txt[end - 1] >= 0 && txt[end - 1] < 10)
            //이름 뒤에 숫자가 있으면 한자리 수로 가정함
            st["atom"] = txt.slice(start, end - 1);else st["atom"] = txt.slice(start, end);
        }
        st[data] = txt.slice(start, end);
        nextWord();
        if (data === "SOF") {
          nextLine();
        }
      }
    }
    let ret = [];
    let end = 1;
    let start = 0;
    let wordCount = 0;
    let st = [];
    for (; end < txt.length; end++) {
      if (wordCount === 0) find("name"); //atom, name 받음        
      else if (wordCount === 1) find("item");else if (wordCount === 2) find("a");else if (wordCount === 3) find("b");else if (wordCount === 4) find("c");else if (wordCount === 5) find("u");else if (wordCount === 6) find("SOF");
    }
    return ret;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/UnitCell.js






/**
 * Unitcell 클래스
 * */
class UnitCell {
  /**
   * 생성자
   * */
  constructor() {
    this._system = 0;
    this._spacegroup = 0;
    this._setting = 0;
    if (cryst) this._axis = new LatticeAxis(cryst.Unitcell.alpha, cryst.Unitcell.beta, cryst.Unitcell.gamma, cryst.Unitcell.a, cryst.Unitcell.b, cryst.Unitcell.c);else this._axis = new LatticeAxis(90, 90, 90, 1, 1, 1);
    this._type = 0; // atom number
    this._geom = new kVisLib.api.Group();
    this._mesh = null;
  }

  /**
   * clone method
   * @returns {UnitCell} cloned unitcell
   * */
  clone() {
    let clone = new UnitCell();
    clone._system = this._system;
    clone._spacegroup = this._spacegroup;
    clone._setting = this._setting;
    clone._axis = this._axis.clone();
    clone._type = this._type;
    return clone;
  }

  /**
   * lattice axis 설정
   * @param {Number} a alpha
   * @param {Number} b beta 
   * @param {Number} c gamma
   * @param {Number} la length a
   * @param {Number} lb length b
   * @param {Number} lc length c
   */
  set(a, b, c, la, lb, lc) {
    this._axis.set(a, b, c, la, lb, lc);
  }
  update() {}

  /**
   * unitcell transform
   * @param {THREE.Vector3} pos transform vector
   * @returns {THREE.Vector3} transformed position
   */
  transform(pos) {
    let tpos = this._axis.transform(pos);
    return tpos;
  }

  /**
   * unitcell의 line mesh를 생성한다.
   * @param {Number} x1 
   * @param {Number} y1
   * @param {Number} z1
   * @param {Number} x2
   * @param {Number} y2
   * @param {Number} z2
   * @returns {THREE.Mesh} line mesh
   */
  createMesh(x1, y1, z1, x2, y2, z2) {
    const points = [];
    //const p1 = geom.GetPoint(0);
    //const p2 = geom.GetPoint(1);

    let tp = new three_module_Vector3(x1, y1, z1);
    points.push(tp);
    tp = new three_module_Vector3(x2, y2, z2);
    points.push(tp);
    const geometry = new BufferGeometry().setFromPoints(points);
    var material = new MeshBasicMaterial({
      color: 0x000000
    });
    const mesh = new Line(geometry, material);
    mesh._mat = material;
    return mesh;
  }

  /**
   * unitcell geometry를 생성한다.
   * @returns {THREE.Group} 
   * */
  generateGeom() {
    this._geom.Clear();
    let group = new Group();
    let l1 = null;
    l1 = this.createMesh(0, 0, 0, this._axis._va.x, this._axis._va.y, this._axis._va.z);
    group.add(l1);
    l1 = this.createMesh(0, 0, 0, this._axis._vb.x, this._axis._vb.y, this._axis._vb.z);
    group.add(l1);
    l1 = this.createMesh(0, 0, 0, this._axis._vc.x, this._axis._vc.y, this._axis._vc.z);
    group.add(l1);
    let p1;
    let p2;
    let ab = this._axis._va.clone().add(this._axis._vb);
    let bc = this._axis._vb.clone().add(this._axis._vc);
    let ca = this._axis._va.clone().add(this._axis._vc);
    let abc = this._axis._va.clone().add(this._axis._vb).add(this._axis._vc);
    p1 = this._axis._va;
    p2 = ab;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = this._axis._vb;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = this._axis._vb;
    p2 = bc;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = this._axis._vc;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = this._axis._va;
    p2 = ca;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = this._axis._vc;
    p2 = ca;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = ab;
    p2 = abc;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = bc;
    p2 = abc;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    p1 = ca;
    p2 = abc;
    l1 = this.createMesh(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    group.add(l1);
    return group;
  }

  /**
   * geometry 삭제
   * */
  clearGeom() {
    this._geom.Clear();
  }

  /**
   * 주어진 unitcell을 복사한다.
   * @param {UnitCell} unitcell 복사하려는 unitcell
   * @returns {UnitCell} this
   */
  cloneFromUnitcell(unitcell) {
    Object.assign(this, unitcell);

    // axis
    this._axis = new LatticeAxis(this._axis._a, this._axis._b, this._axis._c, this._axis._la, this._axis._lb, this._axis._lc);
    // geom
    this._geom = new kVisLib.api.Group();
    this.generateGeom();
    return this;
  }

  /**
   * unitcell을 저장하려는 형태로 변환한다.
   * @returns {Object}
   * */
  createData4Save() {
    let dat = new UnitCell();
    delete dat._axis._va;
    delete dat._axis._vb;
    delete dat._axis._vc;
    dat._axis._a = this._axis._a;
    dat._axis._b = this._axis._b;
    dat._axis._c = this._axis._c;
    dat._axis._la = this._axis._la;
    dat._axis._lb = this._axis._lb;
    dat._axis._lc = this._axis._lc;
    dat._type = this._type;
    dat._system = this._system;
    dat._setting = this._setting;
    dat._spacegroup = this._spacegroup;
    return dat;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/Boundary.js


/**
 * Crystal Structure 경계 클래스
 * */
class Boundary {
  /**
   * 생성자
   * */
  constructor() {
    this._min = new Vector3(0, 0, 0);
    this._max = new Vector3(1, 1, 1);
    this._imin = new Vector3();
    this._imax = new Vector3();
    this._cutoffPlanes = [];
  }

  /**
   * cutoff 평면을 추가한다.
   * @param {Plane} plane 추가할 plane
   */
  addPlane(plane) {
    this._cutoffPlanes.push(plane);
  }

  /**
   * cutoff 평면을 제거한다.
   * @param {Plane} plane 제거할 plane
   */
  removePlane(plane) {
    const idx = this._cutoffPlanes.indexOf(plane);
    if (idx > -1) this._cutoffPlanes.splice(idx, 1);
  }

  /**
   * cutoff 평면을 모두 삭제한다.
   * */
  clearPlane() {
    this._cutoffPlanes = [];
  }

  /**
   * clone method
   * @returns {Boundary} cloned Boundary
   * */
  clone() {
    let clone = new Boundary();
    clone._min = this._min.clone();
    clone._max = this._max.clone();
    clone._imin = this._imin.clone();
    clone._imax = this._imax.clone();
    return clone;
  }

  /**
   * boundary min, max를 설정한다.
   * @param {Vector3} lt left top
   * @param {Vector3} rb right bottom
   */
  set(lt, rb) {
    this._min = lt.clone();
    this._max = rb.clone();
    this.update();
  }

  /**
   * imin, imax 값을 갱신한다.
   * */
  update() {
    this._imin._x = Math.floor(this._min._x) - 1;
    this._imin._y = Math.floor(this._min._y) - 1;
    this._imin._z = Math.floor(this._min._z) - 1;
    this._imax._x = Math.floor(this._max._x) + 1;
    this._imax._y = Math.floor(this._max._y) + 1;
    this._imax._z = Math.floor(this._max._z) + 1;
  }

  /**
   * 주어진 boundary를 복제한다.
   * @param {Boundary} boundary
   * @returns {Boundary} this
   */
  cloneFromBoundary(boundary) {
    Object.assign(this, boundary);
    this._min = new Vector3(this._min._x, this._min._y, this._min._z);
    this._max = new Vector3(this._max._x, this._max._y, this._max._z);
    this._imin = new Vector3(this._imin._x, this._imin._y, this._imin._z);
    this._imax = new Vector3(this._imax._x, this._imax._y, this._imax._z);
    return this;
  }

  /**
   * boundary를 저장하려는 형태로 반환한다. 
   * @returns {Object} boundary data
   * */
  createData4Save() {
    let dat = {};
    dat._min = this._min.clone();
    dat._max = this._max.clone();
    dat._cutoffPlanes = [];
    for (let i = 0; i < this._cutoffPlanes.length; i++) {
      let pp = this._cutoffPlanes[i];
      let pp2 = pp.clone();
      dat._cutoffPlanes.push(pp2);
    }
    return dat;
  }
  isIn(pos, pos2) {
    for (let i = 0; i < this._cutoffPlanes.length; i++) {
      let pp = this._cutoffPlanes[i];
      if (!pp.isIn(pos2)) {
        return false;
      }
    }
    if (this._min._x <= pos.x && pos.x <= this._max._x && this._min._y <= pos.y && pos.y <= this._max._y && this._min._z <= pos.z && pos.z <= this._max._z) {
      return true;
    }
    return false;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/iAtom.js







var _dotSurfaceGeom = null;

/**
 * Instanced Atom 클래스
 * */
class iAtom {
  /**
   * 초기화
   * */
  static init() {
    if (_dotSurfaceGeom) return;
    const r = 1;
    const bsize = 0.02;
    _dotSurfaceGeom = new BoxGeometry(bsize, bsize, bsize);
    _dotSurfaceGeom.translate(0, r, 0);
    const pi = 3.1415927;
    const pi2 = 3.1415927 * 2;
    const delta = pi / 20;
    let x;
    let y;
    let z;
    let geom;
    let geoms = [];
    for (let s = 0; s < pi2; s += delta) {
      for (let t = 0; t < pi; t += delta) {
        x = r * Math.cos(s) * Math.sin(t);
        y = r * Math.sin(s) * Math.sin(t);
        z = r * Math.cos(t);
        geom = new BoxGeometry(bsize, bsize, bsize);
        geom.translate(x, y, z);
        geoms.push(geom);
      }
    }
    _dotSurfaceGeom = BufferGeometryUtils.mergeBufferGeometries(geoms);
  }

  /**
   * 주어진 iAtom과의 거리를 구한다.
   * @param {iAtom} iatom
   * @returns {Number} position과 iatom과의 거리
   */
  distance(iatom) {
    let pos = this._position.clone();
    pos.sub(iatom._position);
    return pos.length();
  }

  /**
   * unitcell 상에서의 위치와 index를 설정한다.
   * @param {Number} x x 좌표
   * @param {Number} y y 좌표
   * @param {Number} z z 좌표
   * @param {Number} idx index
   */
  setUnitcellLoc(x, y, z, idx) {
    this._unitcellLoc = [x, y, z];

    // catom의 index
    this._index = idx;
  }

  /**
   * 생성자
   * iAtom의 cAtom, position을 설정한다.
   * @param {cAtom} catom iAtom의 definition
   * @param {THREE.Vector3} position iAtom position
   */
  constructor(catom, position) {
    this._def = catom;
    if (position) this._position = position.clone(); // three.vector3

    this._mesh = null;
    this._visible = true;
    this._cvisible = true;
    this._exist = true;
    this._vectorMeshes = new Group();
    this._ivectors = [];

    // catom의 index
    this._index = 0;
    this._selected = false;
    this._canPick = this._visible;
  }
  select(select) {
    this._selected = select;
    if (this._mesh) {
      if (select) {
        this._mesh.material.color.fromArray([1, 0, 0], 0);
      } else {
        this._mesh.material.color.fromArray(this._def._color, 0);
      }
    }
  }

  /**
   * cAtom의 index4cstructure를 반환한다.
   * @returns {Number}
   * */
  getIndex() {
    return this._def._index4cstructure;
  }

  /**
   * iAtom의 mesh를 반환한다.
   * @returns {THREE.Mesh}
   * */
  getMesh() {
    return this._mesh;
  }

  /**
   * vector mesh를 반환한다.
   * @returns {Array} 
   * */
  getVectorMesh() {
    return this._vectorMeshes;
  }

  /**
   * dot surface mesh를 반환한다.
   * @returns {THREE.Mesh}
   * */
  getDotSurface() {
    return this._dotSurfaceMesh;
  }

  /**
   * dot surface mesh 가시화 여부를 설정한다.
   * @param {Boolean} show 가시화 여부
   */
  showDotSurface(show) {
    this._dotSurfaceMesh.visible = show;
  }

  /**
   * iVector를 추가한다.
   * @param {iVector} iv 추가할 iVector
   */
  addiVector(iv) {
    this._ivectors.push(iv);
  }

  /**
   * iVector 메쉬를 생성한다.
   * @param {CStructure} cs
   */
  generateMesh4iVectors(cs) {
    let vectors = this._ivectors;
    if (this._visible) {
      for (let i = 0; i < vectors.length; i++) {
        let iv = vectors[i];
        let vmesh = iv.generateMesh(cs);
        this._vectorMeshes.add(vmesh);
      }
    }
  }

  /**
   * iAtom의 shininess를 설정한다.
   * @param {Number} value shininess
   */
  setShininess(value) {
    if (this._mesh) this._mesh.material.shininess = value;
  }
  setMaterialType(type) {
    if (!this._mesh) return;
    switch (type) {
      case 0:
        this._mesh.material = this._mat1;
        break;
      case 1:
        this._mesh.material = this._mat2;
        break;
    }
  }
  calcPos2(cs) {
    this._position2 = cs._unitcell._axis.transform(this._position);
  }

  /**
   * iAtom을 생성한다.
   * @param {CStructure} cs
   */
  generate(cs) {
    //this._vectorMeshes.clear();

    this.calcPos2(cs);
    if (!this._visible) return;
    this._mat1 = new MeshBasicMaterial({
      color: 0x0000ff
    });
    this._mat2 = new MeshPhongMaterial({
      color: 0x0000ff,
      specular: 0x505050,
      vertexColors: false,
      shininess: 30
    });
    let mat = null;
    switch (cs._ROatom) {
      case 0:
        mat = this._mat1;
        break;
      case 1:
        mat = this._mat1;
        break;
    }
    this._mesh = GeomMole.createAtomMesh(this._position2, 0.3, this._def._def, mat);
    this._mesh.name = "atom";
    this._mesh._canPick = true;
    this._mat1.color.fromArray(this._def._color, 0);
    this._mat2.color.fromArray(this._def._color, 0);
    this._mesh._iatom = this;
    this._ivectors = [];
    let vectors = this._def._avectors;
    for (let i = 0; i < vectors.length; i++) {
      let av = vectors[i];
      let iv = av.generateIVector(this, cs);
      this._ivectors.push(iv);
    }
    let dssize = this._mesh.scale.x * 2;
    this._dotSurfaceMesh = new three_module_Mesh(_dotSurfaceGeom, this._mesh.material);
    this._dotSurfaceMesh.scale.fromArray([dssize, dssize, dssize], 0);
    this._dotSurfaceMesh.position.copy(this._position2);
    this._dotSurfaceMesh.visible = false;
    this.generateMesh4iVectors(cs);
  }

  /**
   * iAtom의 radius를 설정한다.
   * @param {Number} radius iAtom 반지름
   */
  setRadius(radius) {
    if (!this._mesh) return false;
    this._mesh.scale.set(radius, radius, radius);
  }

  /**
   * cAtom의 정의를 바탕으로 iAtom의 반지름을 설정한다.
   * @param {Number} ratio iAtom radius 비율
   */
  setNormalRadius(ratio) {
    let radius = this._def._def._radius * ratio;
    this.setRadius(radius);
  }

  /**
   * iAtom의 wireframe 여부를 설정한다.
   * @param {Boolean} w wireframe 여부
   * @returns {Boolean} 메쉬가 존재하지 않는 경우 false return 값 발생
   */
  setWireframe(w) {
    if (!this._mesh) return false;
    this._mesh.material.wireframe = w;
  }

  /**
   * iAtom 가시화 여부를 반환한다.
   * @returns {Boolean} 메쉬의 가시화 여부 반환
   * */
  getVisible() {
    if (!this._mesh) return false;
    return this._mesh.visible;
  }

  /**
   * iAtom 가시화 여부를 설정한다.
   * @param {Boolean} visible 가시화 여부
   */
  setVisible(visible) {
    this._visible = visible;
    this._canPick = this._visible;
    if (!this._mesh) return;
    this._mesh.visible = visible;
    this._vectorMeshes.visible = visible;
    this._visible = visible;
  }

  /**
   * 주어진 iAtom을 복사한다.
   * @param {CStructure} cs 재생성할 CStructure
   * @param {iAtom} iAtom 복사할 iAtom
   * @returns {iAtom} 복제한 iAtom
   */
  cloneFromIAtom(cs, iAtom) {
    Object.assign(this, iAtom);
    this._axis = new LatticeAxis(this._axis._a, this._axis._b, this._axis._c, this._axis._la, this._axis._lb, this._axis._lc);
    for (let i = 0; i < this._def._ivectors.length; ++i) {
      this._def._ivectors[i] = new iVector().cloneFromiVector(this._def._ivectors[i]);
    }
    for (let i = 0; i < this._def._position.length; ++i) {
      this._def._position[i] = new Vector3(this._def._position[i]._x, this._def._position[i]._y, this._def._position[i]._z);
    }
    this._vectorMeshes = new Group();
    this.generate(cs);
    return this;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/iBond.js



/**
 * Instance Bond 클래스
 * */
class iBond {
  /**
   * 생성자
   * atom1과 atom2를 연결하는 bond를 생성한다.
   * @param {iAtom} atom1 결합의 첫번째 원소
   * @param {iAtom} atom2 결합의 두번째 원소
   * @param {cBond} bond cBond
   */
  constructor(atom1, atom2, bond) {
    this._a1 = atom1; // iAtom
    this._a2 = atom2; // iAtom
    this._def = bond;
    //this._geom = null;
    this._meshes = null;
    this._visible = true;
    this._selected = false;
  }
  select(select) {
    this._selected = select;
    if (this._meshes) {
      if (select) {
        this._mat1[0].color.fromArray([1, 0, 0], 0);
        this._mat1[1].color.fromArray([1, 0, 0], 0);
        this._mat2[0].color.fromArray([1, 0, 0], 0);
        this._mat2[1].color.fromArray([1, 0, 0], 0);
      } else {
        this._mat1[0].color.copy(this._a1._mat1.color);
        this._mat1[1].color.copy(this._a2._mat1.color);
        this._mat2[0].color.copy(this._a1._mat1.color);
        this._mat2[1].color.copy(this._a2._mat1.color);
      }
    }
  }

  /**
   * bond의 첫번째 원소와 두번째 원소를 설정한다.
   * @param {iAtom} atom1 결합의 첫번째 원소
   * @param {iAtom} atom2 결합의 두번째 원소
   */
  setAtom(atom1, atom2) {
    this._a1 = atom1;
    this._a2 = atom2;
  }

  /**
   * cBond를 설정한다.
   * @param {cBond} bond iBond의 정의, cBond
   */
  setBond(bond) {
    this._def = bond;
  }

  /**
   * iBond의 메쉬를 반환한다.
   * @returns {Array}
   * */
  getMesh() {
    return this._meshes;
  }

  /**
   * wireframe 여부를 설정한다.
   * @param {Boolean} w wireframe 여부
   */
  setWireframe(w) {
    if (!this._meshes) return;
    for (let i = 0; i < this._meshes.length; i++) {
      this._meshes[i].material.wireframe = w;
    }
  }

  /**
   * bond의 radius를 설정한다.
   * @param {Number} radius bond의 반지름
   */
  setRadius(radius) {
    this._radius = radius;
    if (!this._meshes) return;
    for (let i = 0; i < this._meshes.length; i++) {
      let len = this._meshes[i].scale.z;
      this._meshes[i].scale.set(radius, radius, len);
    }
  }
  setShininess(value) {
    if (this._mat1) {
      this._mat1[0].shininess = value;
      this._mat1[1].shininess = value;
      this._mat2[0].shininess = value;
      this._mat2[1].shininess = value;
    }
  }

  /**
   * material 타입을 설정한다.
   * @param {Number} type material type 옵션
   */
  setMaterialType(type) {
    if (!this._meshes) return;
    switch (type) {
      case 0:
        this._meshes[0].material = this._mat1[0];
        this._meshes[1].material = this._mat1[1];
        break;
      case 1:
        this._meshes[0].material = this._mat2[0];
        this._meshes[1].material = this._mat2[1];
        break;
    }
  }

  /**
   * iBond를 생성한다.
   * @param {CStructure} cs
   * @returns {Array} Mesh 배열
   */
  generate(cs) {
    if (!this._visible) return;
    let atomdefA = this._a1._def._def;
    let atomdefB = this._a2._def._def;
    let posA = new three_module_Vector3(this._a1._position2.x, this._a1._position2.y, this._a1._position2.z);
    let posB = new three_module_Vector3(this._a2._position2.x, this._a2._position2.y, this._a2._position2.z);
    this._radius = 0.07;
    this._mat1 = [];
    this._mat1[0] = new MeshBasicMaterial({
      color: 0x0000ff
    });
    this._mat1[1] = new MeshBasicMaterial({
      color: 0x0000ff
    });
    this._mat1[0].color.copy(this._a1._mat1.color);
    this._mat1[1].color.copy(this._a2._mat1.color);
    this._mat2 = [];
    this._mat2[0] = new MeshPhongMaterial({
      color: 0x0000ff,
      vertexColors: false,
      shininess: 30
    });
    this._mat2[1] = new MeshPhongMaterial({
      color: 0x0000ff,
      vertexColors: false,
      shininess: 30
    });
    this._mat2[0].color.copy(this._a1._mat1.color);
    this._mat2[1].color.copy(this._a2._mat1.color);
    let mats = null;
    switch (cs._RObond) {
      case 0:
        mats = this._mat1;
        break;
      case 1:
        mats = this._mat2;
        break;
    }
    this._meshes = GeomMole.createBondMesh(posA, posB, atomdefA, atomdefB, false, 0, this._radius, mats);
    this._meshes[0].name = "bond0";
    this._meshes[0]._ibond = this;
    this._meshes[0]._canPick = true;
    this._meshes[1].name = "bond1";
    this._meshes[1]._ibond = this;
    this._meshes[1]._canPick = true;
    return this._meshes;
  }

  /**
   * 가시화 여부를 설정한다.
   * @param {Boolean} visible mesh 가시화 여부
   */
  setVisible(visible) {
    this._visible = visible;
    if (!this._meshes) return;
    this._meshes[0].visible = visible;
    this._meshes[1].visible = visible;
  }

  /**
   * 주어진 iBond를 복사한다. 
   * @param {iBond} iBond 복사할 iBond
   */
  cloneFromBond(iBond) {
    Object.assign(this, iBond);
    this.generate();
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/iVector.js




var geom1 = new CylinderGeometry(1, 1, 1, 32);
var geom2 = new ConeGeometry(1, 1, 32);

/**
 * Instanced Vector 클래스
 * */
class iVector_iVector {
  /**
   * 생성자
   * iAtom과 tVector에 매칭되는 iVector를 생성한다.
   * @param {any} tvector
   * @param {any} iatom
   * @param {any} cs
   */
  constructor(tvector, iatom, cs) {
    this._number = 0;
    this._iatom = iatom;
    this._parent = null;
    this._tvector = tvector;
    this._number = 0;
  }

  /**
   * iVector mesh를 생성한다.
   * @param {CStructure} cs
   * @returns {THREE.Mesh} 생성된 iVector Mesh
   */
  generateMesh(cs) {
    let color = new Color();
    color.fromArray(this._tvector._color, 0);
    let v1 = new three_module_Vector3();
    v1.fromArray(this._tvector._vector, 0);
    v1 = cs._unitcell._axis.transform(v1);
    let mat = new MeshLambertMaterial({
      color: color,
      transparent: false,
      vertexColors: false
    });
    let mesh = new Group();
    const len = v1.length();
    let mesh1 = new three_module_Mesh(geom1, mat);
    mesh1.scale.fromArray([this._tvector._radius, len * 2, this._tvector._radius], 0);
    mesh.add(mesh1);
    let mesh2 = new three_module_Mesh(geom2, mat);
    mesh.add(mesh2);
    let radius = this._tvector._radius * 3;
    mesh2.scale.fromArray([radius, radius, radius], 0);
    mesh2.position.fromArray([0, len, 0], 0);
    mesh.lookAt(v1);
    mesh.position.copy(this._iatom._position2);
    return mesh;
  }

  /**
   * 주어진 iVector를 복사한다.
   * @param {iVector} iVector 복사하려는 iVector
   * @returns {iVector} this
   */
  cloneFromiVector(iVector) {
    Object.assign(this, iVector);
    //this._vector = new THREE.Vector3(this._vector.x, this._vector.y, this._vector.z);
    //this._color = new THREE.Color(this._color.x, this._color.y, this._color.z);

    return this;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/aVector.js




// tVector를 사용하여 실제 벡터를 정의
// tvector와 unitcell과 index를 사용하여 정의

/**
 * tVector 클래스를 통해 iVector를 생성하는데 필요한 클래스
 * */
class aVector {
  /**
   * tvector를 지정한다.
   * @param {tVector} tvector aVector에 대한 정의
   */
  constructor(tvector) {
    this._def = tvector;
    this._index = -1;
    this._catom = null;
  }

  /**
   * catom을 지정한다.
   * @param {cAtom} catom
   */
  setCAtom(catom) {
    this._catom = catom;
    this._unitcellPos = null;
  }

  /**
   * vector가 추가될 위치와 인덱스를 지정한다.
   * @param {Array} opos unitcell 상의 위치
   * @param {Number} index iAtom index
   */
  setiAtomPos(opos, index) {
    this._index = index;
    this._unitcellPos = opos;
  }

  /**
   * tvector를 지정한다.
   * @param {tVector} tvector aVector의 정의
   */
  setDef(tvector) {
    this._def = tvector;
  }

  /**
   * number를 지정한다.
   * @param {Number} number
   */
  setNumber(number) {
    this._number = number;
  }

  /**
   * unitcell 위치를 지정한다.
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   */
  setUnitcellLoc(x, y, z) {
    this._unitcellPos = [x, y, z];
  }

  /**
   * aVector 비교 함수
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   * @param {Number} index
   * @returns {Boolean} 일치 여부
   */
  isIt(x, y, z, index) {
    return this._unitcellPos[0] == x && this._unitcellPos[1] == y && this._unitcellPos[2] == z && this._iatom._index == index;
  }

  /**
   * ivector를 생성한다.
   * @param {iAtom} iatom
   * @param {CStructure} cs
   * @returns {iVector} 생성된 ivector
   */
  generateIVector(iatom, cs) {
    let iv = new iVector_iVector(this._def, iatom, cs);
    return iv;
  }

  /**
   * aVector를 통해 iVector를 생성한다.
   * @returns {iVector} 생성된 ivector
   * */
  generate() {
    let iv = new iVector_iVector(this._def, this._color);
    return iv;
  }

  /**
   * clone method
   * @param {CAtom} catom
   * @returns {CAtom} cloned catom
   */
  clone(catom) {
    let clone = new aVector(this._def.clone());
    clone._catom = catom;
    clone._index = this._index;
    if (this._unitcellPos) clone._unitcellPos = this._unitcellPos.clone();else clone._unitcellPos = null;
    clone._number = this._number;
    return clone;
  }

  /**
   * aVector를 저장하려는 형태로 반환한다.
   * @returns {Object} aVector 데이터
   * */
  createData4Save() {
    let dat = {};
    dat._def = this._def;
    dat._index = this._index;
    dat._unitcellPos = this._unitcellPos;
    return dat;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/CAtom.js





/**
 * Crystal Atom 클래스
 * */
class CAtom {
  /**
   * 생성자
   * */
  constructor() {
    this._position = new Vector3();
    this._id = 0; // id
    this._idx = -1; // 테이블 상에서 구분하기 위한 id
    this._index4cstructure = -1; // cstructure의 index
    this._def = null;
    this._type = 0;
    this._label = "";
    this._charge = 0;
    this._visible = true;
    this._avectors = [];
    this._vectorIdx = [];
    this._occ = null;
    this._anisotype = null;
    this._isotype = null;
    this._su = [];
    this._anisoU = [];
    this._anisoBeta = [];
    this._isoU = null;
    this._isoB = null;
    this._color = [1, 1, 1];
  }

  /**
   * clone method
   * @returns {CAtom} cloned catom
   * */
  clone() {
    this.prepare4Save();
    let clone = new CAtom();
    clone._position = this._position.clone();
    clone._id = this._id;
    clone._idx = this._idx;
    clone._def = this._def;
    clone._type = this._type;
    clone._label = this._label;
    clone._charge = this._charge;
    clone._visible = this._visible;
    clone._vectorIdx = this._vectorIdx;
    clone._index4cstructure = this._index4cstructure;
    clone._occ = this._occ;
    clone._anisotype = this._anisotype;
    clone._isotype = this._isotype;
    clone._su = this._su;
    clone._anisoU = this._anisoU;
    clone._anisoBeta = this._anisoBeta;
    clone._isoU = this._isoU;
    clone._isoB = this._isoB;
    clone._color = this._color.slice();
    for (let i = 0; i < this._avectors.length; i++) {
      clone._avectors.push(this._avectors[i].clone(this));
    }
    return clone;
  }

  /**
   * 데이터 저장을 위한 선행 과정
   * */
  prepare4Save() {
    this._vectorIdx = [];
    for (let i = 0; i < this._avectors.length; i++) {
      this._vectorIdx.push(this._avectors[i]._number);
    }
  }

  /**
   * cstructure로부터 avector를 추출한다.
   * @param {CStructure} cstructure 
   */
  restoreFromLoad(cstructure) {
    this._avectors = [];
    for (let i = 0; i < this._vectorIdx.length; i++) {
      let idx = this._vectorIdx[i];
      this._avectors.push(cstructure._avectors[idx]);
    }
  }

  /**
   * tvector를 사용하는 avector를 모두 제거한다.
   * @param {tVector} tvector aVector가 참조하는 tVector
   * @returns {Boolean} aVector의 정의가 주어진 tVector와 일치하는 경우
   */
  removeVectorWithTemplate(tvector) {
    for (let i = 0; i < this._avectors.length; i++) {
      if (this._avectors[i]._def == tvector) {
        this._avectors.splice(i, 1);
        return true;
      }
    }
    return false;
  }

  /**
   * avector를 추가한다.
   * @param {aVector} avector 추가할 aVector
   */
  addVector(avector) {
    for (let i = 0; i < this._avectors.length; i++) {
      if (this._avectors[i] === avector) return;
    }
    this._avectors.push(avector);
  }

  /**
   * avector를 제거한다.
   * @param {any} avector
   */
  removeVector(avector) {
    const idx = this._avectors.indexOf(avector);
    if (idx > -1) this._avectors.splice(idx, 1);
  }

  /**
   * atom id와 def를 설정한다.
   * @param {any} atom_id
   */
  setAtomID(atom_number) {
    this._id = atom_number;
    this._def = AtomDef.GetDefWithNumber(atom_number);
    this._color = this._def._color.slice();
  }
  setAtomNumber(atom_number) {
    this._id = atom_number;
    this._def = AtomDef.GetDefWithNumber(atom_number);
    this._color = this._def._color.slice();
  }

  /**
   * symbol에 해당하는 atom으로 데이터를 설정한다.
   * @param {any} atom_symbol
   */
  setAtomWithSymbol(atom_symbol) {
    let def = AtomDef.GetDefWithID(atom_symbol);
    this._id = def._atom_number;
    this._def = def;
  }

  /**
   * json으로부터 catom 데이터를 설정한다.
   * @param {any} atom_json
   */
  setFromJSON(atom_json) {
    this._position = new THREE.Vector3(atom_json._position.x, atom_json._position.y, atom_json.position.z);
    this._id = atom_json._id;
    this._idx = atomjson._idx;
    this._def = atom_json._def;
    this._type = atom_json._type;
    this._label = atom_json._label;
    this._charge = atom_json._charge;
    this._visible = atom_json._visible;
    this._avectors = [];
    for (let i = 0; i < atom_json._avectors.length; ++i) {
      let v = new Vector3(atom_json._avectors[i]._vector._x, atom_json._avectors[i]._vector._y, atom_json._avectors[i]._vector._z);
    }
    this._vectorIdx = atom_json._vectorIdx;
  }

  /**
   * atom으로부터 데이터를 설정한다.
   * @param {CAtom} atom
   * @returns {CAtom} this
   */
  cloneFromAtom(atom) {
    Object.assign(this, atom);
    this._position = new Vector3(this._position._x, this._position._y, this._position._z);
    return this;
  }

  /**
   * 벡터 데이터를 모두 삭제한다.
   * */
  clearVectors() {
    this._avectors = [];
    this._vectorIdx = [];
  }

  /**
   * catom을 저장하려는 형태로 변환한다.
   * @returns {Object} CAtom data
   * */
  createData4Save() {
    let dat = {};
    dat._id = this._id;
    // dat._idx = this._idx;
    dat._def = this._def;
    dat._type = this._type;
    dat._label = this._label;
    dat._charge = this._charge;
    dat._visible - this._visible;
    dat._position = this._position;
    dat._vectorIdx = this._vectorIdx;
    dat._index4cstructure = this._index4cstructure;
    dat._occ = this._occ;
    dat._anisotype = this._anisotype;
    dat._isotype = this._isotype;
    dat._su = this._su;
    dat._anisoU = this._anisoU;
    dat._anisoBeta = this._anisoBeta;
    dat._isoU = this._isoU;
    dat._isoB = this._isoB;
    dat._color = this._color.slice();
    dat._avectors = [];
    for (let i = 0; i < this._avectors.length; ++i) dat._avectors.push(this._avectors[i].createData4Save());
    return dat;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/CBond.js





/**
 * Crystal Bond 클래스
 * */
class CBond {
  /**
   * 생성자
   * */
  constructor() {
    this._A1 = ""; // atom number 
    this._A2 = ""; // atom number 

    this._A1Idx = -1;
    this._A2Idx = -1;
    this._minLength = 0; // 결합의 최소 길이
    this._maxLength = 0; // 결합의 최대 길이

    this._boundaryMode = 0;
    this._searchMode = 0;
    this._showPolyhedral = true;
    this._idx = -1; // 테이블 상에서 구분하기 위한 id
  }

  /**
   * clone method
   * @returns {CBond} cloned bond
   * */
  clone() {
    let clone = new CBond();
    clone._idx = this._idx;
    clone._A1 = this._A1;
    clone._A2 = this._A2;
    clone._A1Idx = this._A1Idx;
    clone._A2Idx = this._A2Idx;
    clone._minLength = this._minLength;
    clone._maxLength = this._maxLength;
    clone._boundaryMode = this._boundaryMode;
    clone._searchMode = this._searchMode;
    clone._showPolyhedral = this._showPolyhedral;
    return clone;
  }
  touch() {
    if (this._A1) this._A1Idx = this._A1._idx;
    if (this._A2) this._A2Idx = this._A2._idx;
  }

  /**
   * 최소, 최대 길이를 설정한다
   * @param {Vector3} min 최소 길이
   * @param {Vector3} max 최대 길이
   */
  setLength(min, max) {
    this._minLength = min;
    this._maxLength = max;
  }

  /**
   * bond와 연결되는 atom을 설정한다.
   * @param {CAtom} atom1 첫번째 결합 원자
   * @param {CAtom} atom2 두번째 결합 원자
   */
  setAtom(atom1, atom2) {
    this._A1Idx = atom1._idx;
    this._A2Idx = atom2._idx;
    this._A1 = atom1._id;
    this._A2 = atom2._id;
  }

  /**
   * 결합된 원자를 비교한다.
   * @param {CAtom} atom1 첫번째 결합 원자
   * @param {CAtom} atom2 두번째 결합 원자
   * @returns {Boolean} 매칭 여부
   */
  condition(atom1, atom2) {
    let res = false;
    let adef1 = AtomDef_AtomDef.GetDefWithNumber(this._A1);
    let adef2 = AtomDef_AtomDef.GetDefWithNumber(this._A2);
    if (isNaN(atom1._def._id) && atom1._def._id === AtomDef_AtomDef.GetDefWithID(this._A1)._atom_number && isNaN(atom2._def._id) && atom2._def._id === AtomDef_AtomDef.GetDefWithID(this._A2)._atom_number) res = true;else {
      if (adef1 && adef2) {
        if (atom1._def._id === adef1._atom_number && atom2._def._id === adef2._atom_number) res = true;else if (atom1._def._id === adef2._atom_number && atom2._def._id === adef1._atom_number) {
          res = true;
        }
      }
    }

    /*
    if (cs._atoms[this._A1Idx] === atom1._def && cs._atoms[this._A2Idx] === atom2._def)
        res = true;
      if (cs._atoms[this._A1Idx] === atom2._def && cs._atoms[this._A2Idx] === atom1._def)
        res = true;
     */
    if (res) {
      const len = Vector3.distance(atom1._position2, atom2._position2);
      return len >= this._minLength && len <= this._maxLength;
    }
    return false;
  }

  /**
   * 주어진 bond를 복사한다.
   * @param {cBond} bond 복사하려는 cBond
   * @returns {CBond} this
   */
  cloneFromBond(bond) {
    Object.assign(this, bond);
    return this;
  }

  /**
   * cbond를 저장하려는 형태로 변환한다.
   * @returns {Object} CBond data
   * */
  createData4Save() {
    let dat = new CBond();
    Object.assign(dat, this);
    delete dat._idx;
    return dat;
  }
}
;// CONCATENATED MODULE: ./Renderer/jsm/math/ConvexHull.js


/**
 * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)
 */

const Visible = 0;
const Deleted = 1;
const ConvexHull_v1 = new three_module_Vector3();
const _line3 = new Line3();
const _plane = new Plane();
const _closestPoint = new three_module_Vector3();
const ConvexHull_triangle = new Triangle();
class ConvexHull {
  constructor() {
    this.tolerance = -1;
    this.faces = []; // the generated faces of the convex hull
    this.newFaces = []; // this array holds the faces that are generated within a single iteration

    // the vertex lists work as follows:
    //
    // let 'a' and 'b' be 'Face' instances
    // let 'v' be points wrapped as instance of 'Vertex'
    //
    //     [v, v, ..., v, v, v, ...]
    //      ^             ^
    //      |             |
    //  a.outside     b.outside
    //
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = []; // vertices of the hull (internal representation of given geometry data)
  }

  setFromPoints(points) {
    if (Array.isArray(points) !== true) {
      console.error('THREE.ConvexHull: Points parameter is not an array.');
    }
    if (points.length < 4) {
      console.error('THREE.ConvexHull: The algorithm needs at least four points.');
    }
    this.makeEmpty();
    for (let i = 0, l = points.length; i < l; i++) {
      this.vertices.push(new VertexNode(points[i]));
    }
    this.compute();
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function (node) {
      const geometry = node.geometry;
      if (geometry !== undefined) {
        if (geometry.isGeometry) {
          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');
          return;
        } else if (geometry.isBufferGeometry) {
          const attribute = geometry.attributes.position;
          if (attribute !== undefined) {
            for (let i = 0, l = attribute.count; i < l; i++) {
              const point = new three_module_Vector3();
              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
              points.push(point);
            }
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];

      // compute signed distance and check on what half space the point lies

      if (face.distanceToPoint(point) > this.tolerance) return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    // based on "Fast Ray-Convex Polyhedron Intersection"  by Eric Haines, GRAPHICS GEMS II

    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];

      // interpret faces as planes for the further computation

      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);

      // if the origin is on the positive side of a plane (so the plane can "see" the origin) and
      // the ray is turned away or parallel to the plane, there is no intersection

      if (vN > 0 && vD >= 0) return null;

      // compute the distance from the ray’s origin to the intersection with the plane

      const t = vD !== 0 ? -vN / vD : 0;

      // only proceed if the distance is positive. a negative distance means the intersection point
      // lies "behind" the origin

      if (t <= 0) continue;

      // now categorized plane as front-facing or back-facing

      if (vD > 0) {
        //  plane faces away from the ray, so this plane is a back-face

        tFar = Math.min(t, tFar);
      } else {
        // front-face

        tNear = Math.max(t, tNear);
      }
      if (tNear > tFar) {
        // if tNear ever is greater than tFar, the ray must miss the convex hull

        return null;
      }
    }

    // evaluate intersection point

    // always try tNear first since its the closer intersection point

    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, ConvexHull_v1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }

  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face

  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }

  // Removes a vertex from the 'assigned' list of vertices and from the given face

  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      // fix face.outside link

      if (vertex.next !== null && vertex.next.face === face) {
        // face has at least 2 outside vertices, move the 'outside' reference

        face.outside = vertex.next;
      } else {
        // vertex was the only outside vertex that face had

        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }

  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list

  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      // reference to the first and last vertex of this face

      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);

      // fix references

      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }

  // Removes all the visible vertices that 'face' is able to see

  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== undefined) {
      if (absorbingFace === undefined) {
        // mark the vertices to be reassigned to some other face

        this.unassigned.appendChain(faceVertices);
      } else {
        // if there's an absorbing face try to assign as many vertices as possible to it

        let vertex = faceVertices;
        do {
          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
          // will be changed by upcoming method calls

          const nextVertex = vertex.next;
          const distance = absorbingFace.distanceToPoint(vertex.point);

          // check if 'vertex' is able to see 'absorbingFace'

          if (distance > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }

          // now assign next vertex

          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }

  // Reassigns as many vertices as possible from the unassigned list to the new faces

  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        // buffer 'next' reference, see .deleteFaceVertices()

        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i = 0; i < newFaces.length; i++) {
          const face = newFaces[i];
          if (face.mark === Visible) {
            const distance = face.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              maxFace = face;
            }
            if (maxDistance > 1000 * this.tolerance) break;
          }
        }

        // 'maxFace' can be null e.g. if there are identical vertices

        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }

  // Computes the extremes of a simplex which will be the initial hull

  computeExtremes() {
    const min = new three_module_Vector3();
    const max = new three_module_Vector3();
    const minVertices = [];
    const maxVertices = [];

    // initially assume that the first vertex is the min/max

    for (let i = 0; i < 3; i++) {
      minVertices[i] = maxVertices[i] = this.vertices[0];
    }
    min.copy(this.vertices[0].point);
    max.copy(this.vertices[0].point);

    // compute the min/max vertex on all six directions

    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = this.vertices[i];
      const point = vertex.point;

      // update the min coordinates

      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) < min.getComponent(j)) {
          min.setComponent(j, point.getComponent(j));
          minVertices[j] = vertex;
        }
      }

      // update the max coordinates

      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) > max.getComponent(j)) {
          max.setComponent(j, point.getComponent(j));
          maxVertices[j] = vertex;
        }
      }
    }

    // use min/max vectors to compute an optimal epsilon

    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
    return {
      min: minVertices,
      max: maxVertices
    };
  }

  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull

  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min = extremes.min;
    const max = extremes.max;

    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
    // (max.x - min.x)
    // (max.y - min.y)
    // (max.z - min.z)

    let maxDistance = 0;
    let index = 0;
    for (let i = 0; i < 3; i++) {
      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
      if (distance > maxDistance) {
        maxDistance = distance;
        index = i;
      }
    }
    const v0 = min[index];
    const v1 = max[index];
    let v2;
    let v3;

    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

    maxDistance = 0;
    _line3.set(v0.point, v1.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance = _closestPoint.distanceToSquared(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          v2 = vertex;
        }
      }
    }

    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'

    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
        const distance = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance > maxDistance) {
          maxDistance = distance;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron

      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));

      // set the twin edge

      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;

        // join face[ i ] i > 0, with the first face

        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));

        // join face[ i ] with face[ i + 1 ], 1 <= i <= 3

        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
      }
    } else {
      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron

      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));

      // set the twin edge

      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;

        // join face[ i ] i > 0, with the first face

        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));

        // join face[ i ] with face[ i + 1 ]

        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
      }
    }

    // the initial hull is the tetrahedron

    for (let i = 0; i < 4; i++) {
      this.faces.push(faces[i]);
    }

    // initial assignment of vertices to the faces of the tetrahedron

    for (let i = 0, l = vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j = 0; j < 4; j++) {
          const distance = this.faces[j].distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            maxFace = this.faces[j];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }

  // Removes inactive faces

  reindexFaces() {
    const activeFaces = [];
    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }

  // Finds the next vertex to create faces with the current hull

  nextVertexToAdd() {
    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'

    if (this.assigned.isEmpty() === false) {
      let eyeVertex,
        maxDistance = 0;

      // grap the first available face and start with the first visible vertex of that face

      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;

      // now calculate the farthest vertex that face can see

      do {
        const distance = eyeFace.distanceToPoint(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }

  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.

  computeHorizon(eyePoint, crossEdge, face, horizon) {
    // moves face's vertices to the 'unassigned' vertex list

    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      // start from the next edge since 'crossEdge' was already analyzed
      // (actually 'crossEdge.twin' was the edge who called this method recursively)

      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          // the opposite face can see the vertex, so proceed with next edge

          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          // the opposite face can't see the vertex, so this edge is part of the horizon

          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }

  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order

  addAdjoiningFace(eyeVertex, horizonEdge) {
    // all the half edges are created in ccw order thus the face is always pointing outside the hull

    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);

    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0); // the half edge whose vertex is the eyeVertex
  }

  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right

  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i = 0; i < horizon.length; i++) {
      const horizonEdge = horizon[i];

      // returns the right side edge

      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )

        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }

    // perform final join of new faces

    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }

  // Adds a vertex to the hull

  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();

    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);

    // reassign 'unassigned' vertices to the new faces

    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();

    // add all available vertices gradually to the hull

    while ((vertex = this.nextVertexToAdd()) !== undefined) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
}

//

class Face {
  constructor() {
    this.normal = new three_module_Vector3();
    this.midpoint = new three_module_Vector3();
    this.area = 0;
    this.constant = 0; // signed distance from face to the origin
    this.outside = null; // reference to a vertex in a vertex list this face can see
    this.mark = Visible;
    this.edge = null;
  }
  static create(a, b, c) {
    const face = new Face();
    const e0 = new HalfEdge(a, face);
    const e1 = new HalfEdge(b, face);
    const e2 = new HalfEdge(c, face);

    // join edges

    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;

    // main half edge reference

    face.edge = e0;
    return face.compute();
  }
  getEdge(i) {
    let edge = this.edge;
    while (i > 0) {
      edge = edge.next;
      i--;
    }
    while (i < 0) {
      edge = edge.prev;
      i++;
    }
    return edge;
  }
  compute() {
    const a = this.edge.tail();
    const b = this.edge.head();
    const c = this.edge.next.head();
    ConvexHull_triangle.set(a.point, b.point, c.point);
    ConvexHull_triangle.getNormal(this.normal);
    ConvexHull_triangle.getMidpoint(this.midpoint);
    this.area = ConvexHull_triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
}

// Entity for a Doubly-Connected Edge List (DCEL).

class HalfEdge {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
}

// A vertex as a double linked list node.

class VertexNode {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null; // the face that is able to see this vertex
  }
}

// A double linked list that contains vertex nodes.

class VertexList {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }

  // Inserts a vertex before the target vertex

  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }

  // Inserts a vertex after the target vertex

  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }

  // Appends a vertex to the end of the linked list

  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null; // the tail has no subsequent vertex

    this.tail = vertex;
    return this;
  }

  // Appends a chain of vertices where 'vertex' is the head.

  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;

    // ensure that the 'tail' reference points to the last vertex of the chain

    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }

  // Removes a vertex from the linked list

  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }

  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b

  removeSubList(a, b) {
    if (a.prev === null) {
      this.head = b.next;
    } else {
      a.prev.next = b.next;
    }
    if (b.next === null) {
      this.tail = a.prev;
    } else {
      b.next.prev = a.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
}

;// CONCATENATED MODULE: ./Renderer/jsm/geometries/ConvexGeometry.js


class ConvexGeometry extends BufferGeometry {
  constructor(points) {
    super();

    // buffers

    const vertices = [];
    const normals = [];
    if (ConvexHull === undefined) {
      console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull');
    }
    const convexHull = new ConvexHull().setFromPoints(points);

    // generate vertices and normals

    const faces = convexHull.faces;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      let edge = face.edge;

      // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }

    // build geometry

    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  }
}

;// CONCATENATED MODULE: ./CoreCrystal/Polyhedron.js



/**
 * Polyhedron 렌더링 모델 관리 클래스
 * */
class Polyhedron {
  /**
   * 클래스 생성자
   * @param {THREE.Group} parent 렌더링 오브젝트 그룹
   */
  constructor(parent) {
    this._parent = parent;
    this._root = null;
    this._polys = [];
    this._meshs = [];
    this._wires = [];
    this._meshColor = [0, 1, 1];
    this._wireColor = [0, 0, 1];
    this._opacity = 0.5;
    this._visible = true;
    this._visibleEdge = false;
  }

  /**
   * 연결 그래프 데이터를 사용하여 Polyhedron을 생성한다.
   * @param {Object} graph 그래프 데이터
   */
  _generateWithGraph(graph) {
    this._root = new Group();
    this._polys = [];
    this._meshs = [];
    this._wires = [];
    var no_more_center = false;
    do {
      var max_num_links = 0;
      var max_vidx = -1;
      var max_vatomRad = -1;
      var max_vatomId = "";
      for (let i = 0; i < graph.V.length; i++) {
        if (!graph.V[i].visible) continue;
        if (graph.V[i].used_center || graph.V[i].used_poly) continue;
        let num_links = 0;
        for (let j = 0; j < graph.V[i].iEdges.length; j++) {
          if (graph.V[i].iEdges[j].used) continue;
          let incident_atomIdx = graph.V[i].iEdges[j].atom1 === graph.V[i].atom ? graph.V[i].iEdges[j].atom2Idx : graph.V[i].iEdges[j].atom1Idx;
          if (graph.V[incident_atomIdx].used_center) continue;
          num_links++;
        }
        if (num_links > max_num_links) {
          max_num_links = num_links;
          max_vidx = i;
          max_vatomRad = graph.V[i].atom._def._def._radius;
          max_vatomId = graph.V[i].atom._def._def._id;
        } else if (num_links === max_num_links) {
          if (max_vatomRad < graph.V[i].atom._def._def._radius) {
            max_num_links = num_links;
            max_vidx = i;
            max_vatomRad = graph.V[i].atom._def._def._radius;
            max_vatomId = graph.V[i].atom._def._def._id;
          }
        }
      }
      if (max_num_links >= 3) {
        console.log("center vtx " + max_vidx + "(" + max_vatomId + ")" + " with links " + max_num_links);
        graph.V[max_vidx].used_center = true;
        graph.V[max_vidx].used_poly = true;
        var c_points = [];
        c_points.push(graph.V[max_vidx].atom._position2.clone());

        // add sample points - for one-plane degenerate case.
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(0.01, 0, 0)));
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(-0.01, 0, 0)));
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(0, 0.01, 0)));
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(0, -0.01, 0)));
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(0, 0, 0.01)));
        c_points.push(graph.V[max_vidx].atom._position2.clone().add(new three_module_Vector3(0, 0, -0.01)));
        for (let i = 0; i < graph.V[max_vidx].iEdges.length; i++) {
          graph.V[max_vidx].iEdges[i].used = true;
          let incident_atomIdx = graph.V[max_vidx].iEdges[i].atom1Idx === max_vidx ? graph.V[max_vidx].iEdges[i].atom2Idx : graph.V[max_vidx].iEdges[i].atom1Idx;
          if (graph.V[incident_atomIdx].used_center) continue;
          c_points.push(graph.V[incident_atomIdx].atom._position2.clone());
          graph.V[incident_atomIdx].used_poly = true;
        }
        const meshMaterial = new MeshPhongMaterial({
          color: 0xffffff,
          opacity: this._opacity,
          transparent: true
        });
        meshMaterial.color.r = this._meshColor[0];
        meshMaterial.color.g = this._meshColor[1];
        meshMaterial.color.b = this._meshColor[2];
        meshMaterial.specular.r = 0.5;
        meshMaterial.specular.g = 0.5;
        meshMaterial.specular.b = 0.5;
        const ch = new ConvexGeometry(c_points);
        const mesh1 = new three_module_Mesh(ch, meshMaterial);
        const bbwire = new WireframeGeometry(ch);
        const bboxWire = new LineSegments(bbwire);
        bboxWire.material.opacity = this._opacity;
        bboxWire.material.color.r = this._wireColor[0];
        bboxWire.material.color.g = this._wireColor[1];
        bboxWire.material.color.b = this._wireColor[2];
        bboxWire.material.transparent = true;
        bboxWire.visible = this._visibleEdge;
        var poly = new Group();
        poly.add(mesh1);
        poly.add(bboxWire);
        poly.center_iatom = graph.V[max_vidx].atom;
        this._root.add(poly);
        this._polys.push(poly);
        this._meshs.push(mesh1);
        this._wires.push(bboxWire);
      } else {
        no_more_center = true;
        console.log("no more center");
      }
    } while (!no_more_center);
  }

  /**
   * 원자, 결합 리스트를 사용하여 연결 그래프 데이터를 생성한다.
   * @param {Array} atomList 원자 리스트
   * @param {Array} bondList 결합 리스트
   * @returns {Object} 연결 그래프 데이터
   */
  _generateGraphWithAtomBondList(atomList, bondList) {
    let graph = {};
    graph.V = [];
    for (let i = 0; i < atomList.length; i++) {
      if (!atomList[i]._visible) continue;
      let vtx = {};
      vtx.atomIdx = i;
      vtx.atom = atomList[i];
      vtx.iEdges = [];
      vtx.used_center = false;
      vtx.used_poly = false;
      vtx.visible = atomList[i]._visible;
      graph.V.push(vtx);
    }
    graph.E = [];
    for (let i = 0; i < bondList.length; i++) {
      if (!bondList[i]._visible) continue;
      if (!bondList[i]._a1._visible) continue;
      if (!bondList[i]._a2._visible) continue;
      let edge = {};
      edge.atom1 = bondList[i]._a1;
      edge.atom2 = bondList[i]._a2;
      edge.atom1Idx = -1;
      edge.atom2Idx = -1;
      edge.used = false;
      for (let j = 0; j < atomList.length; j++) {
        if (graph.V[j].atom === edge.atom1) {
          edge.atom1Idx = j;
          graph.V[j].iEdges.push(edge);
          break;
        }
      }
      for (let j = 0; j < atomList.length; j++) {
        if (graph.V[j].atom === edge.atom2) {
          edge.atom2Idx = j;
          graph.V[j].iEdges.push(edge);
          break;
        }
      }
      graph.E.push(edge);
    }
    return graph;
  }

  /**
   * 원자, 결합 리스트를 사용하여 Polyhedron 모델을 생성한다.
   * @param {Array} atomList 원자 리스트
   * @param {Array} bondList 결합 리스트
   */
  generateWithAtomBondList(atomList, bondList) {
    this.dispose();
    let graph = this._generateGraphWithAtomBondList(atomList, bondList);
    this._generateWithGraph(graph);
    if (this._parent && this._root) {
      this._parent.add(this._root);
      this.setVisible(this._visible);
    }
  }

  /**
   * Polyhedron 모델 가시화 여부를 설정한다.
   * @param {Boolean} vis Polyhedron 모델 가시화 여부
   */
  setVisible(vis) {
    this._visible = vis;
    if (this._root) {
      this._root.visible = this._visible;
    }
  }

  /**
   * 엣지 모델 가시화 여부를 설정한다.
   * @param {Boolean} vis 엣지 모델 가시화 여부
   */
  setVisibleEdge(vis) {
    this._visibleEdge = vis;
    if (this._wires) {
      for (let w of this._wires) w.visible = this._visibleEdge;
    }
  }

  /**
   * Shininess 값을 설정한다.
   * @param {Number} shi Shininess 값
   */
  setShininess(shi) {
    if (this._meshs) {
      for (let m of this._meshs) m.material.shininess = shi;
    }
  }

  /**
   * 렌더링 리소스를 해제한다.
   * */
  dispose() {
    if (this._root) {
      if (this._parent) this._parent.remove(this._root);
      for (let pm of this._meshs) {
        pm.geometry.dispose();
        pm.material.dispose();
      }
      for (let pw of this._wires) {
        pw.geometry.dispose();
        pw.material.dispose();
      }
    }
    this._root = null;
    this._polys = [];
    this._meshs = [];
    this._wires = [];
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/CrystalShape.js



/**
 * Crystal Shape 렌더링 모델 관리 클래스
 * */
class CrystalShape {
  /**
   * 클래스 생성자
   * @param {THREE.Group} parent 렌더링 오브젝트 그룹
   */
  constructor(parent) {
    this._parent = parent;
    this._visible = true;
    //this._visibleEdge = false;
    this._wireframe = false;
    this._root = null;
    this._mesh = null;
    this._wire = null;
    this._meshColor = [1, .5, 0];
    this._wireColor = [1, .5, 0];
    this._opacity = 0.5;
  }

  /**
   * 정점이 Plane Half space 안에 포함되는지 확인한다.
   * @param {THREE.Vector3} v 정점 좌표
   * @param {THREE.Plane} plane half space plane
   * @returns {Boolean} 정점의 half space 포함 여부
   */
  _vertexInnerHalfSpace(v, plane) {
    const vp_dist = plane.distanceToPoint(v);
    if (vp_dist < 0.001) return true;
    return false;
  }

  /**
   * 3개의 Plane의 교차점을 구한다.
   * @param {THREE.Plane} p1 평면 1
   * @param {THREE.Plane} p2 평면 2
   * @param {THREE.Plane} p3 평면 3
   * @returns {THREE.Vector3} intersection or null
   */
  _vertIntersectPlanes(p1, p2, p3) {
    let n1 = p1.normal,
      n2 = p2.normal,
      n3 = p3.normal;
    let x1 = p1.coplanarPoint(new three_module_Vector3());
    let x2 = p2.coplanarPoint(new three_module_Vector3());
    let x3 = p3.coplanarPoint(new three_module_Vector3());
    let f1 = new three_module_Vector3().crossVectors(n2, n3).multiplyScalar(x1.dot(n1));
    let f2 = new three_module_Vector3().crossVectors(n3, n1).multiplyScalar(x2.dot(n2));
    let f3 = new three_module_Vector3().crossVectors(n1, n2).multiplyScalar(x3.dot(n3));
    let det = new Matrix3().set(n1.x, n1.y, n1.z, n2.x, n2.y, n2.z, n3.x, n3.y, n3.z).determinant();
    if (isNaN(det)) {
      return null;
    }
    if (det < 0.0001 && det > -0.0001) return null;
    let vectorSum = new three_module_Vector3().add(f1).add(f2).add(f3);
    if (isNaN(vectorSum.x) || isNaN(vectorSum.y) || isNaN(vectorSum.z)) {
      return null;
    }
    let planeIntersection = new three_module_Vector3(vectorSum.x / det, vectorSum.y / det, vectorSum.z / det);
    return planeIntersection;
  }

  /**
   * THREE.Plane 데이터를 사용하여 Crystal Shape을 생성한다.
   * @param {Array} planes THREE.Plane list
   */
  generateWithThreePlanes(planes) {
    this.dispose();
    var points = [];
    var c_points = [];
    var n = planes.length;

    // find all vertices from any 3 planes' intersection
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        for (let k = j + 1; k < n; k++) {
          let intrV = this._vertIntersectPlanes(planes[i], planes[j], planes[k]);
          if (intrV) {
            //console.log("add intr point " + intrV.x + "," + intrV.y + "," + intrV.z);
            points.push(intrV);
          }
        }
      }
    }

    // exclude vertices outer region of all half space intersection volume.
    for (let p of points) {
      var inner = true;
      for (let pl of planes) {
        if (!this._vertexInnerHalfSpace(p, pl)) {
          inner = false;
          break;
        }
      }
      if (inner) {
        let ex = false;
        for (let cp of c_points) {
          if (cp.distanceTo(p) < 0.001) {
            ex = true;
            break;
          }
        }
        if (!ex) c_points.push(p);
      }
    }
    console.log("[CrystalShapes] " + c_points.length + " plane-intersection points");
    if (c_points.length < 4) {
      return;
    }

    // generate convex geometry and mesh with vertices.

    const meshMaterial = new MeshPhongMaterial({
      color: 0xffffff,
      opacity: this._opacity,
      transparent: true
    });
    if (planes[0]) {
      meshMaterial.color.r = planes[0]._color[0];
      meshMaterial.color.g = planes[0]._color[1];
      meshMaterial.color.b = planes[0]._color[2];
    }
    const ch = new ConvexGeometry(c_points);
    const mesh1 = new three_module_Mesh(ch, meshMaterial);
    mesh1._crystalFace = true;
    const bbwire = new WireframeGeometry(ch);
    const bboxWire = new LineSegments(bbwire);
    bboxWire.material.opacity = 1.0;
    if (planes[0]) {
      bboxWire.material.color.r = planes[0]._color[0];
      bboxWire.material.color.g = planes[0]._color[1];
      bboxWire.material.color.b = planes[0]._color[2];
    }
    bboxWire.material.transparent = true;
    this._mesh = mesh1;
    this._wire = bboxWire;
    this._root = new Group();
    this._root.add(this._mesh);
    this._root.add(this._wire);
    if (this._parent) this._parent.add(this._root);
    this.setVisible(this._visible);
    //this.setVisibleEdge(this._visibleEdge);
    this.setWireframe(this._wireframe);
    this.setColor([planes[0]._color[0], planes[0]._color[1], planes[0]._color[2]]);
  }

  /**
   * Crystal Plane 데이터를 사용하여 Crystal Shape을 생성한다.
   * @param {Array} planes Crystal Planes
   */
  generateWithPlanes(planes) {
    let tplanes = [];
    for (let pl of planes) {
      let nplane = new Plane().setFromNormalAndCoplanarPoint(pl._normal.clone().normalize(), pl._position);
      nplane._color = [pl._color[0], pl._color[1], pl._color[2]];
      tplanes.push(nplane);
    }
    this.generateWithThreePlanes(tplanes);
  }

  /**
   * Crystal Shape 모델 가시화 여부를 설정한다.
   * @param {Boolean} vis Crystal Shape 모델 가시화 여부
   */
  setVisible(vis) {
    this._visible = vis;
    if (this._root) {
      this._root.visible = this._visible;
    }
  }

  /**
   * 렌더링 타입을 wireframe으로 설정할지 정한다.
   * @param {Boolean} wir wireframe 
   */
  setWireframe(wir) {
    this._wireframe = wir;
    if (this._wire) {
      this._wire.visible = this._wireframe;
    }
    if (this._mesh) {
      this._mesh.visible = !this._wireframe;
    }
  }

  /**
   * crystal shape 색상을 설정한다.
   * @param {Array} col color r,g,b
   */
  setColor(col) {
    this._meshColor = [col[0], col[1], col[2]];
    this._wireColor = [col[0], col[1], col[2]];
    if (this._wire) {
      this._wire.material.color.r = this._wireColor[0];
      this._wire.material.color.g = this._wireColor[1];
      this._wire.material.color.b = this._wireColor[2];
    }
    if (this._mesh) {
      this._mesh.material.color.r = this._meshColor[0];
      this._mesh.material.color.g = this._meshColor[1];
      this._mesh.material.color.b = this._meshColor[2];
    }
  }

  /**
   * 렌더링 리소스를 해제한다.
   * */
  dispose() {
    if (this._root) {
      if (this._parent) this._parent.remove(this._root);
      if (this._mesh) {
        this._mesh.geometry.dispose();
        this._mesh.material.dispose();
      }
      if (this._wire) {
        this._wire.geometry.dispose();
        this._wire.material.dispose();
      }
    }
    this._root = null;
    this._mesh = null;
    this._wire = null;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/LatticePlanes.js



/**
 * Lattice Plane 렌더링 모델 관리 클래스
 * */
class LatticePlanes {
  /**
   * 클래스 생성자
   * @param {THREE.Group} parent 렌더링 오브젝트 그룹
   */
  constructor(parent) {
    this._parent = parent;
    this._visible = true;
    this._visibleEdge = false;
    this._root = null;
    this._lplanes = [];
    this._meshs = [];
    this._wires = [];
    this._meshColor = [1, 0, 0];
    this._wireColor = [1, 0, 0];
    this._opacity = 0.5;
  }

  /**
   * Plane 데이터를 사용하여 Lattice Plane 모델을 생성한다.
   * @param {Array} planes Planes
   * @param {Number} size plane size
   */
  generateWithPlanes(planes, size = 10) {
    this.dispose();
    this._root = new Group();
    if (this._parent) this._parent.add(this._root);
    console.log(planes.length + " lattice planes");
    for (let i = 0; i < planes.length; i++) {
      const pcolor = planes[i]._color;
      const meshMaterial = new MeshLambertMaterial({
        color: 0xffffff,
        opacity: this._opacity,
        side: DoubleSide,
        transparent: true
      });
      meshMaterial.color.r = pcolor[0];
      meshMaterial.color.g = pcolor[1];
      meshMaterial.color.b = pcolor[2];
      const pg = new PlaneGeometry(size, size);
      const mesh = new three_module_Mesh(pg, meshMaterial);
      const bbwire = new WireframeGeometry(pg);
      const bboxWire = new LineSegments(bbwire);
      bboxWire.material.opacity = 1.0;
      bboxWire.material.color.r = pcolor[0];
      bboxWire.material.color.g = pcolor[1];
      bboxWire.material.color.b = pcolor[2];
      bboxWire.material.transparent = true;
      bboxWire.visible = this._visibleEdge;
      const lp = new Group();
      lp.add(mesh);
      lp.add(bboxWire);

      // apply lattice plane transform
      lp.position.copy(planes[i]._position);
      lp.setRotationFromQuaternion(new Quaternion().setFromUnitVectors(new three_module_Vector3(0, 0, 1), planes[i]._normal.clone().normalize()));
      console.log("plane pos " + planes[i]._position.x + "," + planes[i]._position.y + "," + planes[i]._position.z);

      // add mesh, wire, plane to root scene
      this._meshs.push(mesh);
      this._wires.push(bboxWire);
      this._lplanes.push(lp);
      this._root.add(lp);
    }
    this.setVisible(this._visible);
  }

  /**
   * Lattice Planes 모델 가시화 여부를 설정한다.
   * @param {Boolean} vis Lattice Planes 모델 가시화 여부
   */
  setVisible(vis) {
    this._visible = vis;
    if (this._root) {
      this._root.visible = this._visible;
    }
  }

  /**
   * 렌더링 리소스를 해제한다.
   * */
  dispose() {
    if (this._root) {
      if (this._parent) this._parent.remove(this._root);
      for (let pm of this._meshs) {
        pm.geometry.dispose();
        pm.material.dispose();
      }
      for (let pw of this._wires) {
        pw.geometry.dispose();
        pw.material.dispose();
      }
    }
    this._root = null;
    this._lplanes = [];
    this._meshs = [];
    this._wires = [];
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/tVector.js


/**
 * Template Vector 클래스
 * */
class tVector {
  /**
   * 생성자
   * @param {Array} vector vector array
   * @param {Array} color color array
   * @param {Number} radius radius number
   */
  constructor(vector, color, radius) {
    this._vector = [vector[0], vector[1], vector[2]];
    this._color = [color[0], color[1], color[2]];
    this._number = -1;
    this._radius = radius;
  }

  /**
   * clone method
   * @returns {tVector} cloned tVector
   * */
  clone() {
    let clone = new tVector(this._vector, this._color, this._radius);
    clone._number = this._number;
    return clone;
  }

  /**
   * tVector를 저장하려는 형태로 변환한다.
   * @returns {Object} 
   * */
  createData4Save() {
    let dat = {};
    dat._vector = [...this._vector];
    dat._color = [...this._color];
    dat._number = this._number;
    dat._radius = this._radius;
    return dat;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/SymmetryMatrix.js


var _mat_a_b_c;
var _mat_na_b_c;
var _mat_a_nb_c;
var _mat_a_b_nc;
var _mat_a_5_b_c;
var _mat_a_b_5_c;
var _mat_a_b_c_5;
var _mat_a_5_b_5_c;
var _mat_a_5_b_c_5;
var _mat_a_b_5_c_5;
var _mat_a_5_b_5_c_5;
var _mat_a_3_b_3_c_3;
var _mat_a_3_b_3_c_6;
var _mat_a_3_b_6_c_3;
var _mat_a_6_b_3_c_3;
var _mat_a_6_b_6_c_6;
var _mat_a_6_b_6_c_3;
var _mat_a_6_b_3_c_6;
var _mat_a_3_b_6_c_6;
var _mat_na_nb_nc;
var _mat_a_nb_nc;
var _mat_na_b_nc;
var _mat_na_nb_c;
var _mat_na_5_nb_5_nc_5;
var _mat_na_5_nb_5_nc;
var _mat_na_5_nb_nc_5;
var _mat_na_nb_5_nc_5;
var _mat_na_6_nb_6_nc_3;
var _mat_na_6_nb_3_nc_6;
var _mat_na_3_nb_6_nc_6;
var _mat_na_3_nb_3_nc_6;
var _mat_na_3_nb_6_nc_3;
var _mat_na_6_nb_3_nc_3;
var _mat_na_nb_c_5;
var _mat_na_b_5_nc;
var _mat_a_5_nb_nc;
var _mat_na_nb_5_c;
var _mat_na_5_nb_c;
var _mat_na_b_nc_5;
var _mat_na_5_b_nc;
var _mat_a_nb_nc_5;
var _mat_a_nb_5_nc;
var _mat_na_5_nb_5_c;
var _mat_na_5_nb_c_5;
var _mat_na_nb_5_c_5;
var _mat_na_5_b_5_nc;
var _mat_na_5_b_nc_5;
var _mat_na_b_5_nc_5;
var _mat_a_5_nb_5_nc;
var _mat_a_5_nb_nc_5;
var _mat_a_nb_5_nc_5;
var _mat_na_5_nb_5_c_5;
var _mat_na_5_b_5_nc_5;
var _mat_a_5_nb_5_nc_5;
var _mat_a_b_nc_5;
var _mat_a_b_5_nc;
var _mat_a_5_b_nc;
var _mat_a_nb_c_5;
var _mat_a_nb_5_c;
var _mat_a_5_nb_c;
var _mat_na_b_c_5;
var _mat_na_b_5_c;
var _mat_na_5_b_c;
var _mat_a_b_5_nc_5;
var _mat_a_5_b_nc_5;
var _mat_a_5_b_5_nc;
var _mat_a_nb_5_c_5;
var _mat_a_5_nb_c_5;
var _mat_a_5_nb_5_c;
var _mat_na_b_5_c_5;
var _mat_na_5_b_c_5;
var _mat_na_5_b_5_c;
var _mat_a_5_b_5_nc_5;
var _mat_a_5_nb_5_c_5;
var _mat_na_5_b_5_c_5;
var _mat_$_nb_$_a_nb_$_c;
var _mat_$_na_b_$_na_$_c;
var _mat_$_b_$_na_b_$_c;
var _mat_$_a_nb_$_a_$_c;
var _mat_$_nb_$_a_nb_$_c_3;
var _mat_$_na_b_$_na_$_c_6;
var _mat_$_b_$_na_b_$_c_8;
var _mat_$_a_nb_$_a_$_c_1;
var _mat_$_nb_$_a_nb_$_c_6;
var _mat_$_na_b_$_na_$_c_3;
var _mat_$_b_$_na_b_$_c_1;
var _mat_$_a_nb_$_a_$_c_8;
var _mat_$_b_$_na_b_$_c_6;
var _mat_$_a_nb_$_a_$_c_3;
var _mat_$_b_$_na_b_$_c_3;
var _mat_$_a_nb_$_a_$_c_6;
var _mat_$_b_$_na_b_$_c_5;
var _mat_$_a_nb_$_a_$_c_5;
var _mat_$_nb_$_a_nb_$_nc;
var _mat_$_na_b_$_na_$_nc;
var _mat_$_b_$_na_b_$_nc;
var _mat_$_na_$_b_$_na_c;
var _mat_$_a_nb_$_a_$_nc;
var _mat_$_nb_$_a_nb_$_nc_5;
var _mat_$_na_b_$_na_$_nc_5;
var _mat_b_a_nc;
var _mat_$_a_nb_$_nb_$_nc;
var _mat_$_na_$_na_b_$_nc;
var _mat_nb_na_nc;
var _mat_$_na_b_$_b_$_nc;
var _mat_$_a_$_a_nb_$_nc;
var _mat_$_nb_$_na_b_$_c_8;
var _mat_b_a_nc_3;
var _mat_$_na_$_na_b_$_nc_6;
var _mat_nb_na_nc_8;
var _mat_$_na_b_$_b_$_nc_5;
var _mat_$_a_$_a_nb_$_nc_1;
var _mat_$_a_nb_$_a_$_nc_8;
var _mat_b_a_nc_6;
var _mat_$_na_$_na_b_$_nc_3;
var _mat_nb_na_nc_1;
var _mat_$_a_$_a_nb_$_nc_8;
var _mat_nb_na_nc_6;
var _mat_$_a_$_a_nb_$_nc_3;
var _mat_$_b_$_a_$_nc_3;
var _mat_nb_na_nc_3;
var _mat_$_a_$_a_nb_$_nc_6;
var _mat_nb_na_c;
var _mat_$_na_b_$_b_$_c;
var _mat_$_a_$_a_nb_$_c;
var _mat_nb_na_nc_5;
var _mat_b_a_c_5;
var _mat_$_a_nb_$_nb_$_c_5;
var _mat_$_a_$_a_nb_$_nc_5;
var _mat_$_na_$_na_b_$_c_5;
var _mat_b_a_c;
var _mat_$_a_nb_$_nb_$_c;
var _mat_$_na_$_na_b_$_c;
var _mat_nb_na_c_5;
var _mat_na_b_$_b_$_c_5;
var _mat_a_$_a_nb_$_c_5;
var _mat_b_a_nc_5;
var _mat_$_a_nb_$_nc_$_nc_5;
var _mat_$_na_$_na_b_$_nc_5;
var _mat_c_a_b;
var _mat_c_na_nb;
var _mat_nc_na_b;
var _mat_nc_a_nb;
var _mat_b_c_a;
var _mat_nb_c_na;
var _mat_b_nc_na;
var _mat_nb_nc_a;
var _mat_c_a_5_b_5;
var _mat_c_na_5_nb_5;
var _mat_nc_na_5_b_5;
var _mat_nc_a_5_nb_5;
var _mat_b_c_5_a_5;
var _mat_nb_c_5_na_5;
var _mat_b_nc_5_na_5;
var _mat_nb_na_5_a_5;
var _mat_c_5_a_b_5;
var _mat_c_5_na_nb_5;
var _mat_nc_5_na_b_5;
var _mat_nc_5_a_nb_5;
var _mat_b_5_c_a_5;
var _mat_nb_5_c_na_5;
var _mat_b_5_nc_na_5;
var _mat_nb_5_nc_a_5;
var _mat_c_5_a_5_b;
var _mat_c_5_na_5_nb;
var _mat_nc_5_na_5_b;
var _mat_na_5_a_5_nb;
var _mat_b_5_c_5_a;
var _mat_nb_5_c_5_na;
var _mat_b_5_nc_5_na;
var _mat_nb_5_nc_5_a;
var _mat_c_5_a_5_b_5;
var _mat_c_5_na_5_nb_5;
var _mat_nc_5_na_5_b_5;
var _mat_nc_5_a_5_nb_5;
var _mat_b_5_c_5_a_5;
var _mat_nb_5_c_5_na_5;
var _mat_b_5_nc_5_na_5;
var _mat_nb_5_nc_5_a_5;
var _mat_c_5_na_5_nb;
var _mat_nc_5_na_b_5;
var _mat_nc_a_5_nb_5;
var _mat_nb_c_5_na_5;
var _mat_b_5_nc_5_na;
var _mat_nb_5_nc_a_5;
var _mat_na_5_na_b_5;
var _mat_nc_a_5_b_5;
var _mat_c_na_nb_5;
var _mat_nc_na_5_b;
var _mat_nc_5_a_nb;
var _mat_nb_5_c_na;
var _mat_b_nc_na_5;
var _mat_nb_nc_5_a;
var _mat_b_na_c;
var _mat_nb_a_c;
var _mat_a_c_nb;
var _mat_na_c_b;
var _mat_na_nc_nb;
var _mat_a_nc_b;
var _mat_c_b_na;
var _mat_c_nb_a;
var _mat_nc_b_a;
var _mat_nc_nb_na;
var _mat_b_5_a_5_nc_5;
var _mat_nb_5_na_5_nc_5;
var _mat_b_5_na_5_c_5;
var _mat_nb_5_a_5_c_5;
var _mat_a_5_c_5_nb_5;
var _mat_na_5_c_5_b_5;
var _mat_na_5_nc_5_nb_5;
var _mat_a_5_nc_5_b_5;
var _mat_c_5_b_5_na_5;
var _mat_c_5_nb_5_a_5;
var _mat_nc_5_b_5_a_5;
var _mat_nc_5_nb_5_na_5;
var _mat_nc_na_nb;
var _mat_nc_a_b;
var _mat_c_a_nb;
var _mat_c_na_b;
var _mat_nb_nc_na;
var _mat_b_nc_a;
var _mat_nb_c_a;
var _mat_b_c_na;
var _mat_nb_a_nc;
var _mat_b_na_nc;
var _mat_na_nc_b;
var _mat_a_nc_nb;
var _mat_a_c_b;
var _mat_na_c_nb;
var _mat_nc_nb_a;
var _mat_nc_b_na;
var _mat_c_nb_na;
var _mat_c_b_a;
var _mat_nc_5_na_5_nb_5;
var _mat_nc_5_a_5_b_5;
var _mat_c_5_a_5_nb_5;
var _mat_c_5_na_5_b_5;
var _mat_nb_5_nc_5_na_5;
var _mat_b_5_nc_5_a_5;
var _mat_nb_5_c_5_a_5;
var _mat_b_5_c_5_na_5;
var _mat_nb_nc_5_a_5;
var _mat_nc_5_a_5_nb;

/**
 * symmetry matrix ����
 * */
function initMatrix() {
  let mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_b_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_b_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_nb_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_b_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_b_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_b_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_b_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_b_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_b_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_b_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_b_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.333333, 0, 1, 0, 0.333333, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_a_3_b_3_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.333333, 0, 1, 0, 0.333333, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_a_3_b_3_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.333333, 0, 1, 0, 0.666667, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_a_3_b_6_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.666667, 0, 1, 0, 0.333333, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_a_6_b_3_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.666667, 0, 1, 0, 0.666667, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_a_6_b_6_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.666667, 0, 1, 0, 0.666667, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_a_6_b_6_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.666667, 0, 1, 0, 0.333333, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_a_6_b_3_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.333333, 0, 1, 0, 0.666667, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_a_3_b_6_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_nb_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_nb_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_b_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_b_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0], 0);
  _mat_na_nb_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_nb_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_nb_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_nb_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_nb_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.666667, 0, -1, 0, 0.666667, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_na_6_nb_6_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.666667, 0, -1, 0, 0.333333, 0, 0, -1, 0.666667, 0, 0, 0, 1], 0);
  _mat_na_6_nb_3_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.333333, 0, -1, 0, 0.666667, 0, 0, -1, 0.666667, 0, 0, 0, 1], 0);
  _mat_na_3_nb_6_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.333333, 0, -1, 0, 0.333333, 0, 0, -1, 0.666667, 0, 0, 0, 1], 0);
  _mat_na_3_nb_3_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.333333, 0, -1, 0, 0.666667, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_na_3_nb_6_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.666667, 0, -1, 0, 0.333333, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_na_6_nb_3_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_nb_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_b_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_nb_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_nb_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_nb_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_b_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_b_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_nb_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_nb_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_nb_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_nb_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_nb_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_b_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_b_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_b_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_nb_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_nb_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_nb_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_nb_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_b_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_nb_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_b_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_b_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_b_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_nb_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_nb_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_nb_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_b_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_b_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_b_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_b_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_b_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_b_5_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_nb_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_nb_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_a_5_nb_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_b_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_b_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_na_5_b_5_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_b_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_nb_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_b_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_nb_$_a_nb_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_$_nb_$_a_nb_$_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.833333, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c_8 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.166667, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c_1 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_$_nb_$_a_nb_$_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0.333333, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.166667, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c_1 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.833333, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c_8 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.33333, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.33333, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.666667, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c_6 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_nb_$_a_nb_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_nb_$_a_nb_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_b_$_na_b_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_$_b_$_na_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.5], 0);
  _mat_$_nb_$_a_nb_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_na_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_b_a_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_nb_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_nb_na_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_b_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.833333, 0, 0, 0, 1], 0);
  _mat_$_nb_$_na_b_$_c_8 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_b_a_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0.677777, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.833333, 0, 0, 0, 1], 0);
  _mat_nb_na_nc_8 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_b_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.166667, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc_1 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0.833333, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_a_$_nc_8 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0.666667, 0, 0, 0, 1], 0);
  _mat_b_a_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.166667, 0, 0, 0, 1], 0);
  _mat_nb_na_nc_1 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.833333, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc_8 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.666667], 0);
  _mat_nb_na_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_$_b_$_a_$_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.333333, 0, 0, 0, 1], 0);
  _mat_nb_na_nc_3 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.666667, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc_6 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_nb_na_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_b_$_b_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_na_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_b_a_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_nb_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_a_$_a_nb_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_b_a_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_nb_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_c = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_nb_na_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_na_b_$_b_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_a_$_a_nb_$_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_b_a_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_a_nb_$_nc_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_$_na_$_na_b_$_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_a_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_na_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_na_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_a_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_c_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_c_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_nc_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_nc_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_a_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, -1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_na_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, -1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_na_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_a_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, 1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_c_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_c_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, -1, 0.5, -1, 0, 0, 0.5], 0);
  _mat_b_nc_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_na_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_a_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, -1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_na_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_na_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 0 - 1, 0.5, 1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_a_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, 1, 0, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_c_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, 1, 0, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_c_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, -1, 0, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_nc_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_nc_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_5_a_5_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_5_na_5_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_5_na_5_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_na_5_a_5_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, 1, 0.5, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_5_c_5_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, 1, 0.5, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_5_c_5_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, -1, 0.5, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_5_nc_5_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0.5, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_5_nc_5_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_a_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_na_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_na_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_a_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, 1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_c_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_c_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, -1, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_nc_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_nc_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_5_na_5_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_na_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_a_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_c_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, -1, 0.5, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_5_nc_5_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_nc_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_na_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_a_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, -1, 0, 0, 0, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_na_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, -1, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_na_5_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_5_a_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_5_c_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_nc_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, -1, 0.5, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_nc_5_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_b_na_c = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0);
  _mat_nb_a_c = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_a_c_nb = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_na_c_b = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_na_nc_nb = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_a_nc_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_b_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_nb_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_b_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_nb_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 1, 0, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_a_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, -1, 0, 0, 0.5, 0, 0, -1, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_na_5_nc_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, -1, 0, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_na_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 1, 0, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_5_a_5_c_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 0, 1, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_c_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 0, 1, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_c_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0.5, 0, 0, -1, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_na_5_nc_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0.5, 0, 0, -1, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_a_5_nc_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 0, 1, 0, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_b_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 0, -1, 0, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_nb_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 0, 1, 0, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_b_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 0, -1, 0, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_nb_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_na_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_a_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_a_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_na_b = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_nc_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_nc_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nb_c_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_c_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1], 0);
  _mat_nb_a_nc = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_b_na_nc = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_na_nc_b = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_a_nc_nb = mat;
  mat = new Matrix4();
  mat.fromArray([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 0);
  _mat_a_c_b = mat;
  mat = new Matrix4();
  mat.fromArray([-1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1], 0);
  _mat_na_c_nb = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_nb_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_nc_b_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_nb_na = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], 0);
  _mat_c_b_a = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, -1, 0, 0, 0.5, 0, -1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_na_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nc_5_a_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, 1, 0, 0, 0.5, 0, -1, 0, 0.5], 0);
  _mat_c_5_a_5_nb_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_c_5_na_5_b_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0.5, -1, 0, 0, 0.5], 0);
  _mat_nb_5_nc_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_nc_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, 1, 0.5, 1, 0, 0, 0.5], 0);
  _mat_nb_5_c_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 1, 0, 0.5, 0, 0, 1, 0.5, -1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_b_5_c_5_na_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, -1, 0, 0.5, 0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, 0, 0, 1], 0);
  _mat_nb_nc_5_a_5 = mat;
  mat = new Matrix4();
  mat.fromArray([0, 0, -1, 0.5, 1, 0, 0, 0.5, 0, -1, 0, 0, 0, 0, 0, 1]);
  _mat_nc_5_a_5_nb = mat;
}

/**
 * symmetry matrix ��ȯ
 * @param {Number} idx matrix index
 */
function getMatrix(idx) {
  switch (idx) {
    case 0:
      return _mat_a_b_c;
    case 1:
      return _mat_na_b_c;
    case 2:
      return _mat_a_nb_c;
    case 3:
      return _mat_a_b_nc;
    case 4:
      return _mat_a_5_b_c;
    case 5:
      return _mat_a_b_5_c;
    case 6:
      return _mat_a_b_c_5;
    case 7:
      return _mat_a_5_b_5_c;
    case 8:
      return _mat_a_5_b_c_5;
    case 9:
      return _mat_a_b_5_c_5;
    case 10:
      return _mat_a_5_b_5_c_5;
    case 11:
      return _mat_a_3_b_3_c_3;
    case 12:
      return _mat_a_3_b_3_c_6;
    case 13:
      return _mat_a_3_b_6_c_3;
    case 14:
      return _mat_a_6_b_3_c_3;
    case 15:
      return _mat_a_6_b_6_c_6;
    case 16:
      return _mat_a_6_b_6_c_3;
    case 17:
      return _mat_a_6_b_3_c_6;
    case 18:
      return _mat_a_3_b_6_c_6;
    case 19:
      return _mat_na_nb_nc;
    case 20:
      return _mat_a_nb_nc;
    case 21:
      return _mat_na_b_nc;
    case 22:
      return _mat_na_nb_c;
    case 23:
      return _mat_na_5_nb_5_nc_5;
    case 24:
      return _mat_na_5_nb_5_nc;
    case 25:
      return _mat_na_5_nb_nc_5;
    case 26:
      return _mat_na_nb_5_nc_5;
    case 27:
      return _mat_na_6_nb_6_nc_3;
    case 28:
      return _mat_na_6_nb_3_nc_6;
    case 29:
      return _mat_na_3_nb_6_nc_6;
    case 30:
      return _mat_na_3_nb_3_nc_6;
    case 31:
      return _mat_na_3_nb_6_nc_3;
    case 32:
      return _mat_na_6_nb_3_nc_3;
    case 33:
      return _mat_na_nb_c_5;
    case 34:
      return _mat_na_b_5_nc;
    case 35:
      return _mat_a_5_nb_nc;
    case 36:
      return _mat_na_nb_5_c;
    case 37:
      return _mat_na_5_nb_c;
    case 38:
      return _mat_na_b_nc_5;
    case 39:
      return _mat_na_5_b_nc;
    case 40:
      return _mat_a_nb_nc_5;
    case 41:
      return _mat_a_nb_5_nc;
    case 42:
      return _mat_na_5_nb_5_c;
    case 43:
      return _mat_na_5_nb_c_5;
    case 44:
      return _mat_na_nb_5_c_5;
    case 45:
      return _mat_na_5_b_5_nc;
    case 46:
      return _mat_na_5_b_nc_5;
    case 47:
      return _mat_na_b_5_nc_5;
    case 48:
      return _mat_a_5_nb_5_nc;
    case 49:
      return _mat_a_5_nb_nc_5;
    case 50:
      return _mat_a_nb_5_nc_5;
    case 51:
      return _mat_na_5_nb_5_c_5;
    case 52:
      return _mat_na_5_b_5_nc_5;
    case 53:
      return _mat_a_5_nb_5_nc_5;
    case 54:
      return _mat_a_b_nc_5;
    case 55:
      return _mat_a_b_5_nc;
    case 56:
      return _mat_a_5_b_nc;
    case 57:
      return _mat_a_nb_c_5;
    case 58:
      return _mat_a_nb_5_c;
    case 59:
      return _mat_a_5_nb_c;
    case 60:
      return _mat_na_b_c_5;
    case 61:
      return _mat_na_b_5_c;
    case 62:
      return _mat_na_5_b_c;
    case 63:
      return _mat_a_b_5_nc_5;
    case 64:
      return _mat_a_5_b_nc_5;
    case 65:
      return _mat_a_5_b_5_nc;
    case 66:
      return _mat_a_nb_5_c_5;
    case 67:
      return _mat_a_5_nb_c_5;
    case 68:
      return _mat_a_5_nb_5_c;
    case 69:
      return _mat_na_b_5_c_5;
    case 70:
      return _mat_na_5_b_c_5;
    case 71:
      return _mat_na_5_b_5_c;
    case 72:
      return _mat_a_5_b_5_nc_5;
    case 73:
      return _mat_a_5_nb_5_c_5;
    case 74:
      return _mat_na_5_b_5_c_5;
    case 75:
      return _mat_$_nb_$_a_nb_$_c;
    case 76:
      return _mat_$_na_b_$_na_$_c;
    case 77:
      return _mat_$_b_$_na_b_$_c;
    case 78:
      return _mat_$_a_nb_$_a_$_c;
    case 79:
      return _mat_$_nb_$_a_nb_$_c_3;
    case 80:
      return _mat_$_na_b_$_na_$_c_6;
    case 81:
      return _mat_$_b_$_na_b_$_c_8;
    case 82:
      return _mat_$_a_nb_$_a_$_c_1;
    case 83:
      return _mat_$_nb_$_a_nb_$_c_6;
    case 84:
      return _mat_$_na_b_$_na_$_c_3;
    case 85:
      return _mat_$_b_$_na_b_$_c_1;
    case 86:
      return _mat_$_a_nb_$_a_$_c_8;
    case 87:
      return _mat_$_b_$_na_b_$_c_6;
    case 88:
      return _mat_$_a_nb_$_a_$_c_3;
    case 89:
      return _mat_$_b_$_na_b_$_c_3;
    case 90:
      return _mat_$_a_nb_$_a_$_c_6;
    case 91:
      return _mat_$_b_$_na_b_$_c_5;
    case 92:
      return _mat_$_a_nb_$_a_$_c_5;
    case 93:
      return _mat_$_nb_$_a_nb_$_nc;
    case 94:
      return _mat_$_na_b_$_na_$_nc;
    case 95:
      return _mat_$_b_$_na_b_$_nc;
    case 96:
      return _mat_$_na_$_b_$_na_c;
    case 97:
      return _mat_$_a_nb_$_a_$_nc;
    case 98:
      return _mat_$_nb_$_a_nb_$_nc_5;
    case 99:
      return _mat_$_na_b_$_na_$_nc_5;
    case 100:
      return _mat_b_a_nc;
    case 101:
      return _mat_$_a_nb_$_nb_$_nc;
    case 102:
      return _mat_$_na_$_na_b_$_nc;
    case 103:
      return _mat_nb_na_nc;
    case 104:
      return _mat_$_na_b_$_b_$_nc;
    case 105:
      return _mat_$_a_$_a_nb_$_nc;
    case 106:
      return _mat_$_nb_$_na_b_$_c_8;
    case 107:
      return _mat_b_a_nc_3;
    case 108:
      return _mat_$_na_$_na_b_$_nc_6;
    case 109:
      return _mat_nb_na_nc_8;
    case 110:
      return _mat_$_na_b_$_b_$_nc_5;
    case 111:
      return _mat_$_a_$_a_nb_$_nc_1;
    case 112:
      return _mat_$_a_nb_$_a_$_nc_8;
    case 113:
      return _mat_b_a_nc_6;
    case 114:
      return _mat_$_na_$_na_b_$_nc_3;
    case 115:
      return _mat_nb_na_nc_1;
    case 116:
      return _mat_$_a_$_a_nb_$_nc_8;
    case 117:
      return _mat_nb_na_nc_6;
    case 118:
      return _mat_$_a_$_a_nb_$_nc_3;
    case 119:
      return _mat_$_b_$_a_$_nc_3;
    case 120:
      return _mat_nb_na_nc_3;
    case 121:
      return _mat_$_a_$_a_nb_$_nc_6;
    case 122:
      return _mat_nb_na_c;
    case 123:
      return _mat_$_na_b_$_b_$_c;
    case 124:
      return _mat_$_a_$_a_nb_$_c;
    case 125:
      return _mat_nb_na_nc_5;
    case 126:
      return _mat_b_a_c_5;
    case 127:
      return _mat_$_a_nb_$_nb_$_c_5;
    case 128:
      return _mat_$_a_$_a_nb_$_nc_5;
    case 129:
      return _mat_$_na_$_na_b_$_c_5;
    case 130:
      return _mat_b_a_c;
    case 131:
      return _mat_$_a_nb_$_nb_$_c;
    case 132:
      return _mat_$_na_$_na_b_$_c;
    case 133:
      return _mat_nb_na_c_5;
    case 134:
      return _mat_na_b_$_b_$_c_5;
    case 135:
      return _mat_a_$_a_nb_$_c_5;
    case 136:
      return _mat_b_a_nc_5;
    case 137:
      return _mat_$_a_nb_$_nc_$_nc_5;
    case 138:
      return _mat_$_na_$_na_b_$_nc_5;
    case 139:
      return _mat_c_a_b;
    case 140:
      return _mat_c_na_nb;
    case 141:
      return _mat_nc_na_b;
    case 142:
      return _mat_nc_a_nb;
    case 143:
      return _mat_b_c_a;
    case 144:
      return _mat_nb_c_na;
    case 145:
      return _mat_b_nc_na;
    case 146:
      return _mat_nb_nc_a;
    case 147:
      return _mat_c_a_5_b_5;
    case 148:
      return _mat_c_na_5_nb_5;
    case 149:
      return _mat_nc_na_5_b_5;
    case 150:
      return _mat_nc_a_5_nb_5;
    case 151:
      return _mat_b_c_5_a_5;
    case 152:
      return _mat_nb_c_5_na_5;
    case 153:
      return _mat_b_nc_5_na_5;
    case 154:
      return _mat_nb_na_5_a_5;
    case 155:
      return _mat_c_5_a_b_5;
    case 156:
      return _mat_c_5_na_nb_5;
    case 157:
      return _mat_nc_5_na_b_5;
    case 158:
      return _mat_nc_5_a_nb_5;
    case 159:
      return _mat_b_5_c_a_5;
    case 160:
      return _mat_nb_5_c_na_5;
    case 161:
      return _mat_b_5_nc_na_5;
    case 162:
      return _mat_nb_5_nc_a_5;
    case 163:
      return _mat_c_5_a_5_b;
    case 164:
      return _mat_c_5_na_5_nb;
    case 165:
      return _mat_nc_5_na_5_b;
    case 166:
      return _mat_na_5_a_5_nb;
    case 167:
      return _mat_b_5_c_5_a;
    case 168:
      return _mat_nb_5_c_5_na;
    case 169:
      return _mat_b_5_nc_5_na;
    case 170:
      return _mat_nb_5_nc_5_a;
    case 171:
      return _mat_c_5_a_5_b_5;
    case 172:
      return _mat_c_5_na_5_nb_5;
    case 173:
      return _mat_nc_5_na_5_b_5;
    case 174:
      return _mat_nc_5_a_5_nb_5;
    case 175:
      return _mat_b_5_c_5_a_5;
    case 176:
      return _mat_nb_5_c_5_na_5;
    case 177:
      return _mat_b_5_nc_5_na_5;
    case 178:
      return _mat_nb_5_nc_5_a_5;
    case 179:
      return _mat_c_5_na_5_nb;
    case 180:
      return _mat_nc_5_na_b_5;
    case 181:
      return _mat_nc_a_5_nb_5;
    case 182:
      return _mat_nb_c_5_na_5;
    case 183:
      return _mat_b_5_nc_5_na;
    case 184:
      return _mat_nb_5_nc_a_5;
    case 185:
      return _mat_na_5_na_b_5;
    case 186:
      return _mat_nc_a_5_b_5;
    case 187:
      return _mat_c_na_nb_5;
    case 188:
      return _mat_nc_na_5_b;
    case 189:
      return _mat_nc_5_a_nb;
    case 190:
      return _mat_nb_5_c_na;
    case 191:
      return _mat_b_nc_na_5;
    case 192:
      return _mat_nb_nc_5_a;
    case 193:
      return _mat_b_na_c;
    case 194:
      return _mat_nb_a_c;
    case 195:
      return _mat_a_c_nb;
    case 196:
      return _mat_na_c_b;
    case 197:
      return _mat_na_nc_nb;
    case 198:
      return _mat_a_nc_b;
    case 199:
      return _mat_c_b_na;
    case 200:
      return _mat_c_nb_a;
    case 201:
      return _mat_nc_b_a;
    case 202:
      return _mat_nc_nb_na;
    case 203:
      return _mat_b_5_a_5_nc_5;
    case 204:
      return _mat_nb_5_na_5_nc_5;
    case 205:
      return _mat_b_5_na_5_c_5;
    case 206:
      return _mat_nb_5_a_5_c_5;
    case 207:
      return _mat_a_5_c_5_nb_5;
    case 208:
      return _mat_na_5_c_5_b_5;
    case 209:
      return _mat_na_5_nc_5_nb_5;
    case 210:
      return _mat_a_5_nc_5_b_5;
    case 211:
      return _mat_c_5_b_5_na_5;
    case 212:
      return _mat_c_5_nb_5_a_5;
    case 213:
      return _mat_nc_5_b_5_a_5;
    case 214:
      return _mat_nc_5_nb_5_na_5;
    case 215:
      return _mat_nc_na_nb;
    case 216:
      return _mat_nc_a_b;
    case 217:
      return _mat_c_a_nb;
    case 218:
      return _mat_c_na_b;
    case 219:
      return _mat_nb_nc_na;
    case 220:
      return _mat_b_nc_a;
    case 221:
      return _mat_nb_c_a;
    case 222:
      return _mat_b_c_na;
    case 223:
      return _mat_nb_a_nc;
    case 224:
      return _mat_b_na_nc;
    case 225:
      return _mat_na_nc_b;
    case 226:
      return _mat_a_nc_nb;
    case 227:
      return _mat_a_c_b;
    case 228:
      return _mat_na_c_nb;
    case 229:
      return _mat_nc_nb_a;
    case 230:
      return _mat_nc_b_na;
    case 231:
      return _mat_c_nb_na;
    case 232:
      return _mat_c_b_a;
    case 233:
      return _mat_nc_5_na_5_nb_5;
    case 234:
      return _mat_nc_5_a_5_b_5;
    case 235:
      return _mat_c_5_a_5_nb_5;
    case 236:
      return _mat_c_5_na_5_b_5;
    case 237:
      return _mat_nb_5_nc_5_na_5;
    case 238:
      return _mat_b_5_nc_5_a_5;
    case 239:
      return _mat_nb_5_c_5_a_5;
    case 240:
      return _mat_b_5_c_5_na_5;
    case 241:
      return _mat_nb_nc_5_a_5;
    case 242:
      return _mat_nc_5_a_5_nb;
  }
}
function getMatrixList(spaceGroupNum, settingNum) {
  switch (spaceGroupNum) {
    case -1:
      return [getMatrix(0)];
    case 2:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(21)];
          case 1:
            return [getMatrix(0), getMatrix(22)];
          case 2:
            return [getMatrix(0), getMatrix(20)];
        }
      }
    case 3:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(34)];
          case 1:
            return [getMatrix(0), getMatrix(33)];
          case 2:
            return [getMatrix(0), getMatrix(35)];
        }
      }
    case 167:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(75), getMatrix(76), getMatrix(22), getMatrix(77), getMatrix(78)];
        }
      }
    case 168:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(79), getMatrix(80), getMatrix(33), getMatrix(81), getMatrix(86)];
        }
      }
    case 194:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(22), getMatrix(21), getMatrix(20), getMatrix(139), getMatrix(140), getMatrix(141), getMatrix(142), getMatrix(143), getMatrix(144), getMatrix(145), getMatrix(146)];
        }
      }
    case 195:
      {
        switch (settingNum) {
          case 0:
            return [getMatrix(0), getMatrix(22), getMatrix(21), getMatrix(20), getMatrix(139), getMatrix(140), getMatrix(141), getMatrix(142), getMatrix(143), getMatrix(144), getMatrix(145), getMatrix(146), getMatrix(9), getMatrix(44), getMatrix(47), getMatrix(50), getMatrix(147), getMatrix(148), getMatrix(149), getMatrix(150), getMatrix(151), getMatrix(152), getMatrix(153), getMatrix(241), getMatrix(8), getMatrix(43), getMatrix(46), getMatrix(49), getMatrix(155), getMatrix(156), getMatrix(180), getMatrix(158), getMatrix(159), getMatrix(160), getMatrix(161), getMatrix(184), getMatrix(7), getMatrix(42), getMatrix(45), getMatrix(48), getMatrix(163), getMatrix(179), getMatrix(165), getMatrix(242), getMatrix(167), getMatrix(168), getMatrix(169), getMatrix(170)];
        }
      }
  }
  return [];
}
function getMatrixIdxList(spaceGroupNum, settingNum) {
  switch (spaceGroupNum) {
    case -1:
      return [0];
    case 2:
      {
        switch (settingNum) {
          case 0:
            return [0, 21];
          case 1:
            return [0, 22];
          case 2:
            return [0, 20];
        }
      }
    case 3:
      {
        switch (settingNum) {
          case 0:
            return [0, 34];
          case 1:
            return [0, 33];
          case 2:
            return [0, 35];
        }
      }
    case 167:
      {
        switch (settingNum) {
          case 0:
            return [0, 75, 76, 22, 77, 78];
        }
      }
    case 168:
      {
        switch (settingNum) {
          case 0:
            return [0, 79, 80, 33, 81, 86];
        }
      }
    case 194:
      {
        switch (settingNum) {
          case 0:
            return [0, 22, 21, 20, 139, 140, 141, 142, 143, 144, 145, 146];
        }
      }
    case 195:
      {
        switch (settingNum) {
          case 0:
            return [0, 22, 21, 20, 139, 140, 141, 142, 143, 144, 145, 146, 9, 44, 47, 50, 147, 148, 149, 150, 151, 152, 153, 241, 8, 43, 46, 49, 155, 156, 180, 158, 159, 160, 161, 184, 7, 42, 45, 48, 163, 179, 165, 242, 167, 168, 169, 170];
        }
      }
  }
  return [];
}
;// CONCATENATED MODULE: ./CoreCrystal/Plane.js



/**
 * Plane 클래스
 * */
class Plane_Plane {
  /**
   * 생성자
   * */
  constructor() {
    this._position = new three_module_Vector3(0, 0, 0);
    this._normal = new three_module_Vector3(1, 0, 0);
    this._h = 0;
    this._k = 0;
    this._l = 1;
    this._d = 1;
    this._color = [1, 1, 1, 1];
    this._latticeAxis = null;
    this._id = -1;
  }

  /**
   * plane의 색상을 설정한다.
   * @param {Number} r red
   * @param {Number} g green
   * @param {Number} b blue
   * @param {Number} a alpha
   */
  setColor(r, g, b, a) {
    this._color = [r, g, b, a];
  }

  /**
   * miller index를 설정한다.
   * @param {LatticeAxis} lattice_axis
   * @param {Number} h
   * @param {Number} k
   * @param {Number} l
   * @param {Number} distance
   */
  setMillerIndices(lattice_axis, h, k, l, distance) {
    this._h = h;
    this._k = k;
    this._l = l;
    this._d = distance;
    this._latticeAxis = lattice_axis;
    this.calculate();
  }

  /**
   * miller index calculate
   * */
  calculate() {
    let normal = this._latticeAxis.calcMillerIndices(this._h, this._k, this._l);
    if (normal == null) return false;
    this._normal = normal;
    this._position = this._normal.clone();
    let d = this._position.length();
    this._position.multiplyScalar(this._d / d);
  }

  /**
   * clone method
   * @returns {Plane} cloned plane
   * */
  clone() {
    let clone = new Plane_Plane();
    clone._color = [this._color[0], this._color[1], this._color[2], this._color[3]];
    clone.setMillerIndices(this._latticeAxis, this._h, this._k, this._l, this._d);
    return clone;
  }
  isIn(pos) {
    let pp = pos.clone();
    pp.sub(this._position);
    let val = pp.dot(this._normal);
    return val < 0;
  }

  /**
   * 저장하기 위한 형태로 변경
   * @returns {Object}
   * */
  createData4Save() {
    let dat = {};
    dat._h = this._h;
    dat._k = this._k;
    dat._l = this._l;
    dat._d = this._d;
    dat._latticeAxis = this._latticeAxis;
    dat._color = [this._color[0], this._color[1], this._color[2], this._color[3]];
    return dat;
  }

  /**
   * 주어진 plane으로부터 clone
   * @param {Plane} plane 
   * @returns {Plane} this
   */
  cloneFromPlane(plane) {
    Object.assign(this, plane);
    delete this._id;
    this._latticeAxis = new LatticeAxis(this._latticeAxis._a, this._latticeAxis._b, this._latticeAxis._c, this._latticeAxis._la, this._latticeAxis._lb, this._latticeAxis._lc);
    this.setMillerIndices(this._latticeAxis, this._h, this._k, this._l, this._d);
    return this;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/CStructure.js
















const _mdist = 0.00001;

/**
 * Crystal Structure 클래스
 * */
class CStructure {
  /**
   * 생성자
   * */
  constructor() {
    initMatrix();
    iAtom.init();
    this._name = "";
    this._position = new Vector3(0, 0, 0);
    this._direction = new Vector3(0, 0, 0);
    this._atoms = [];
    this._bonds = [];
    this._unitcell = new UnitCell();
    this._boundary = new Boundary();
    this._name = "";
    this._tvectors = []; // template. vector 정의
    this._avectors = []; // 한 vector를 어디에 둘지 정의

    this._curAtomIdx = -1;
    this._curBondIdx = -1;
    this._curVectorIdx = -1;
    this._curShapeId = -1;
    this._iatomList = [];
    this._ibondList = [];
    this._ivectors = []; // 생성된 ivectors, 한 메쉬를 정의

    // 전체 메쉬 가지고 있슴. 
    this._groupMesh = new Group();

    // 아톰 메쉬
    this._groupAtomMesh = new Group();

    // 본드 메쉬
    this._groupBondMesh = new Group();

    // 기타 : dot surface, crystal shape, 등등
    this._groupEtcMesh = new Group();
    this._groupMesh.add(this._groupAtomMesh);
    this._groupMesh.add(this._groupBondMesh);
    this._groupMesh.add(this._groupEtcMesh);
    this._groupMesh.name = "CStructure";
    this._clipOption = 0;
    this._crystalPlanes = [];
    this._polyhedron = null;
    this._crystalShape = null;
    this._latticePlaneObj = null;
    this._polyhedronVisible = false;
    this._crystalShapeVisible = true;
    this._latticePlanes = [];
    this._ROatom = 1;
    this._RObond = 0;
  }
  pickiAtom(renderer, normalizedPos) {
    let ia = renderer.pickObject(normalizedPos);
    if (ia) {
      if (ia.name == "atom") ia._iatom.select(true);
      return ia._iatom;
    }
    return null;
  }
  pickiBond(renderer, normalizedPos) {
    let ia = renderer.pickObject(normalizedPos);
    if (ia) {
      if (ia.name == "bond0" || ia.name == "bond1") ia._ibond.select(true);
      return ia._ibond;
    }
    return null;
  }
  selectiBondRect(renderer, rect) {
    let ret = [];
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      if (!bond._mesh) continue;
      let p2 = renderer.toScreenPosition(bond._mesh);
      if (p2[0] >= rect[0] && p2[0] <= rect[2] && p2[1] <= rect[1] && p2[1] >= rect[3]) {
        ret.push(bond);
        bond.select(true);
      }
    }
    return ret;
  }
  unselectAll() {
    let len = this._iatomList.length;
    let i;
    for (i = 0; i < len; i++) {
      let ia = this._iatomList[i];
      ia.select(false);
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.select(false);
    }
  }

  // rect = [left,top, right, bottom]
  selectiAtomRect(renderer, rect) {
    let ret = [];
    let len = this._iatomList.length;
    let i;
    for (i = 0; i < len; i++) {
      let ia = this._iatomList[i];
      if (!ia._mesh) continue;
      let p2 = renderer.toScreenPosition(ia._mesh);
      if (p2[0] >= rect[0] && p2[0] <= rect[2] && p2[1] <= rect[1] && p2[1] >= rect[3]) {
        ret.push(ia);
        ia.select(true);
      }
    }
    return ret;
  }

  /**
   * atom의 광택 정도를 설정한다.
   * @param {Number} value shininess
   */
  setAtomShininess(value) {
    let len = this._iatomList.length;
    let i;
    for (i = 0; i < len; i++) {
      let ia = this._iatomList[i];
      ia.setShininess(value);
    }
  }
  setBondShininess(value) {
    let len = this._ibondList.length;
    let i;
    for (i = 0; i < len; i++) {
      let ib = this._ibondList[i];
      ib.setShininess(value);
    }
  }

  /**
   * 렌더링 옵션을 설정한다.
   * @param {CrystalEditor} app 
   * @param {Object} options
   */
  setRenderOption(app, options) {
    //this._renderer
    let renderer = app._3dRender._renderer;
    renderer.setBackgroundColor(options.BackgroundColor[0], options.BackgroundColor[1], options.BackgroundColor[2]);
    switch (options.LightingMode) {
      case 1:
        renderer.setLightMode(1);
        break;
      case 2:
        renderer.setLightMode(6);
        break;
      case 3:
        renderer.setLightMode(7);
        break;
    }
    renderer.setAntialias(options.Antialiasing == 1);
    const alen = this._iatomList.length;
    for (let ia = 0; ia < alen; ia++) {
      let atom = this._iatomList[ia];
      atom.setMaterialType(options.AtomStyle);
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.setMaterialType(options.BondStyle);
    }
    switch (options.CameraType) {
      case 0:
        // ortho
        if (renderer._cameraMode == "P") {
          renderer.setOrthoCamera();
        }
        break;
      case 1:
        if (renderer._cameraMode == "O") {
          renderer.setPerspectiveCamera();
        }
        break;
    }
    switch (options.ShowAxis) {
      case 0:
        renderer._axisMesh.visible = false;
        app._labelManager._xLabel.style.display = 'none';
        app._labelManager._yLabel.style.display = 'none';
        app._labelManager._zLabel.style.display = 'none';
        break;
      case 1:
        renderer._axisMesh.visible = true;
        app._labelManager._xLabel.style.display = '';
        app._labelManager._yLabel.style.display = '';
        app._labelManager._zLabel.style.display = '';
        break;
    }
  }

  /**
   * cstructure의 이름을 반환한다.
   * @returns {String} CStructure의 이름
   * */
  getName() {
    return this._name;
  }

  /**
   * cstructure의 이름을 설정한다.
   * @param {String} name
   */
  setName(name) {
    this._name = name;
  }

  /**
   * lattice axis를 반환한다.
   * @returns {LatticeAxis} 
   * */
  getLatticeAxis() {
    return this._unitcell._axis;
  }

  /**
   * idx에 해당하는 crystal plane을 반환한다.
   * @param {Number} idx
   * @returns {Plane}
   */
  getPlaneByIdx(idx) {
    return this._crystalPlanes[idx];
  }
  getPlaneById(id) {
    return this._crystalPlanes.filter(elem => {
      return elem._id === id;
    });
  }

  /**
   * idx에 해당하는 lattice plane을 반환한다.
   * @param {Number} idx
   * @returns {Plane}
   */
  getLatticePlaneByIdx(idx) {
    return this._latticePlanes[idx];
  }

  /**
   * lattice plane을 추가한다.
   * @param {Plane} plane
   */
  addLatticePlane(plane) {
    this._latticePlanes.push(plane);
  }

  /**
   * lattice plane을 제거한다.
   * @param {Plane} plane
   */
  removeLatticePlane(plane) {
    const idx = this._latticePlanes.indexOf(plane);
    if (idx > -1) this._latticePlanes.splice(idx, 1);
  }

  /**
   * idx에 해당하는 lattice plane을 제거한다.
   * @param {Number} idx
   */
  removeLatticePlaneByIdx(idx) {
    if (idx >= 0) this._latticePlanes.splice(idx, 1);
  }

  /**
   * crystal plane을 추가한다.
   * @param {Plane} plane
   */
  addPlane(plane) {
    this._crystalPlanes.push(plane);
  }

  /**
   * crystal plane을 제거한다.
   * @param {Plane} plane
   */
  removePlane(plane) {
    const idx = this._crystalPlanes.indexOf(plane);
    if (idx > -1) this._crystalPlanes.splice(idx, 1);
  }

  /**
   * idx에 해당하는 crystal plane을 제거한다.
   * @param {Plane} idx
   */
  removePlaneByIdx(idx) {
    if (idx >= 0) this._crystalPlanes.splice(idx, 1);
  }

  /**
   * 
   * @param {any} plane_id
   */
  removePlaneById(plane_id) {
    this._crystalPlanes = this._crystalPlanes.filter(elem => {
      return elem._id !== plane_id;
    });
  }

  /**
   * clip option을 설정한다.
   * @param {Object} option
   */
  setClipOption(option) {
    this._clipOption = option;
  }

  /**
   * boundary의 min, max를 설정한다.
   * @param {Array} min
   * @param {Array} max
   */
  setBoundary(min, max) {
    this._boundary.set(new three_module_Vector3(min[0], min[1], min[2]), new three_module_Vector3(max[0], max[1], max[2]));
  }

  /**
   * clone method
   * @returns {CStructure} cloned cstructure
   * */
  clone() {
    let clone = new CStructure();
    clone._name = this._name;
    clone._position = this._position.clone();
    clone._direction = this._direction.clone();
    let len = this._atoms.length;
    for (let i = 0; i < len; i++) {
      clone.addAtom(this._atoms[i].clone());
    }
    len = this._bonds.length;
    for (let i = 0; i < len; i++) {
      clone.addBond(this._bonds[i].clone());
    }
    clone._unitcell = this._unitcell.clone();
    clone._boundary = this._boundary.clone();
    len = this._tvectors.length;
    for (let i = 0; i < len; i++) {
      clone.addtVector(this._tvectors[i].clone());
    }
    len = this._avectors.length;
    for (let i = 0; i < len; i++) {
      let av = this._avectors[i];
      let idx = this._tvectors.indexOf(av._def);
      let tv = clone._tvectors[idx];
      clone.addVector2iAtomWithPos(av._unitcellPos, av._index, tv);
    }
    len = this._crystalPlanes.length;
    for (let i = 0; i < len; i++) {
      clone.addPlane(this._crystalPlanes[i].clone());
    }
    len = this._latticePlanes.length;
    for (let i = 0; i < len; i++) {
      clone.addLatticePlane(this._latticePlanes[i].clone());
    }
    return clone;
  }

  /**
   * tVector를 추가한다.
   * @param {tVector} tvector
   */
  addtVector(tvector) {
    const idx = this._tvectors.indexOf(tvector);
    if (idx <= -1) {
      this._tvectors.push(tvector);
      this.numberVectors();
    }
  }

  /**
   * tVector를 제거한다.
   * @param {tVector} tvector
   */
  removetVector(tvector) {
    const idx = this._tvectors.indexOf(tvector);
    if (idx > -1) this._tvectors.splice(idx, 1);
  }

  /**
   * tVector를 하나의 iAtom에 추가한다.
   * @param {Array} opos unitcell 위치의 중심 좌표 배열
   * @param {Number} index cAtom의 _idx
   * @param {tVector} tvector 렌더링 될 벡터가 정의된 클래스
   * @returns {aVector} added aVector
   */
  addVector2iAtomWithPos(opos, index, tvector) {
    this.addtVector(tvector);
    let av = new aVector(tvector);
    av.setiAtomPos(opos, index);
    this._avectors.push(av);

    //this.numberVectors();

    return av;
  }

  /**
   * iAtom의 모든 벡터를 제거한다.
   * @param {iAtom} iatom
   */
  removeAllVectors4iAtom(iatom) {
    let pos = iatom._unitcellLoc;
    let idx = iatom._index;
    let avs = [];
    let len = this._avectors.length;
    for (let i = len - 1; i >= 0; i--) {
      let av = this._avectors[i];
      if (av._unitcellPos[0] == pos[0] && av._unitcellPos[1] == pos[1] && av._unitcellPos[2] == pos[2] && av._index == idx) avs.push(av);
    }
    len = avs.length;
    for (let i = 0; i < len; i++) {
      let av = avs[i];
      const idx2 = this._avectors.indexOf(av);
      if (idx2 > -1) this._avectors.splice(idx2, 1);
    }
  }

  /**
   * iAtom에 vector를 추가한다.
   * @param {iAtom} iatom
   * @param {tVector} tvector
   * @returns {aVector} 추가된 aVector
   */
  addVector2iAtom(iatom, tvector) {
    let ucpos = iatom._unitcellLoc;
    let idx = iatom._index;
    let av = this.addVector2iAtomWithPos(ucpos, idx, tvector);
    return av;
  }

  /**
   * iAtom의 iVector를 제거한다.
   * @param {iAtom} iatom
   * @param {tVector} tvector
   */
  removeVector4iAtom(iatom, tvector) {
    let iv = this.findiVector(iatom, tvector);
    const idx = this._ivectors.indexOf(iv);
    if (idx > -1) this._ivectors.splice(idx, 1);
  }

  /**
   * cAtom의 aVector를 제거한다.
   * @param {cAtom} catom
   * @param {tVector} tvector
   */
  removeVector4CAtom(catom, tvector) {
    catom.removeVector(tvector);
  }

  /**
   * cAtom에 aVector를 추가한다.
   * @param {cAtom} catom
   * @param {tVector} tvector
   */
  addVector2CAtom(catom, tvector) {
    this.addtVector(tvector);
    let av = new aVector(tvector);
    av.setCAtom(catom);
    catom.addVector(av);
  }

  /**
   * tVector numbering
   * */
  numberVectors() {
    const len = this._tvectors.length;
    let i;
    for (i = 0; i < len; i++) {
      this._tvectors[i]._number = i;
    }
  }

  /**
   * iVector 메쉬를 생성한다.
   * */
  generateMesh4iVectors() {
    let len = this._iatomList.length;
    let i;
    len = this._ivectors.length;
    for (i = 0; i < len; i++) {
      let iv = this._ivectors[i];
      if (!iv._iatom) {
        let t = 32;
      }
      let parent = iv._iatom.getVectorMesh();
      let mesh = iv.generateMesh(this);
      parent.add(mesh);
    }
  }

  /**
   * aVector로부터 iVector를 복원한다.
   * */
  generateiVectors() {
    const len = this._avectors.length;
    let i;
    for (i = 0; i < len; i++) {
      let av = this._avectors[i];
      let ia = this.findiAtom(av._unitcellPos, av._index);
      if (!ia) {
        rayLog(3, "Error!! atom index cannot found!");
      }
      let iv = av.generateIVector(ia, this);
      this._ivectors.push(iv);
    }
  }

  /**
   * cAtom을 추가한다.
   * @param {cAtom} atom
   */
  addAtom(atom) {
    if (atom.constructor === Array) {
      const len = atom.length;
      let i;
      for (i = 0; i < len; i++) {
        this._atoms.push(atom[i]);
      }
    } else {
      this._atoms.push(atom);
    }
    this.setAtomIndex();
  }

  /**
   * cAtom의 인덱스를 설정한다.
   * */
  setAtomIndex() {
    const len = this._atoms.length;
    let i;
    for (i = 0; i < len; i++) {
      this._atoms[i]._index4cstructure = i;
      this._atoms[i]._idx = i;
    }
  }

  /**
   * 추가될 cAtom의 인덱스를 반환한다.
   * @returns {Number} 추가된 atom의 index
   * */
  assignAtomIdx() {
    return ++this._curAtomIdx;
  }
  assignShapeId() {
    return ++this._curShapeId;
  }

  /**
   * 추가될 cBond의 인덱스를 반환한다.
   * @returns {Number} 추가된 bond의 index
   * */
  assignBondIdx() {
    return ++this._curBondIdx;
  }

  /**
   * cAtom을 제거한다.
   * @param {CAtom} atom
   */
  removeAtom(atom) {
    let idx = atom._idx;
    this._atoms = this._atoms.filter(elem => {
      return elem !== atom;
    });
    this._bonds = this._bonds.filter(elem => {
      return elem._A1Idx !== idx && elem._A2Idx !== idx;
    });
    this._avectors = this._avectors.filter(elem => {
      return elem._index !== idx;
    });
    this.setAtomIndex();
    const blen = this._bonds.length;
    let i;
    for (i = 0; i < blen; i++) {
      let bond = this._bonds[i];
      bond.touch();
    }
  }

  /**
   * atom id에 해당하는 cAtom을 제거한다.
   * @param {Number} atom_id
   */
  removeAtomById(atom_id) {
    this._atoms = this._atoms.filter(elem => {
      return elem._id !== atom_id;
    });
    this.setAtomIndex();
  }

  /**
   * atom index에 해당하는 cAtom을 반환한다.
   * @param {Number} atom_idx
   * @returns {CAtom} atom index에 해당하는 catom
   */
  getAtomByIdx(atom_idx) {
    let res = this._atoms[atom_idx];
    return res;
  }

  /**
   * atom index에 해당하는 iAtom을 반환한다.
   * @param {Number} atom_idx
   * @returns {IAtom} atom index에 해당하는 iatom
   */
  getIAtomByIdx(atom_idx) {
    let res = this._iatomList.filter(elem => {
      return elem._def._idx === atom_idx;
    });
    return res;
  }

  /**
   * atom id에 해당하는 cAtom을 반환한다.
   * @param {Number} atom_id
   * @returns {Array} atom id에 해당하는 atom
   */
  getAtomsById(atom_id) {
    return this._atoms.filter(elem => {
      return elem._id === atom_id;
    });
  }

  /**
   * vector number에 해당하는 iVector를 반환한다.
   * @param {Number} vector_number
   * @returns {Array} vector number에 해당하는 iVector
   */
  getiVectorByNumber(vector_number) {
    return this._ivectors.filter(elem => {
      return elem._number === vector_number;
    });
  }

  /**
   * vector number에 해당하는 tVector를 반환한다.
   * @param {Number} vector_number
   * @returns {Array} vector number에 해당하는 tVector
   */
  gettVectorByNumber(vector_number) {
    return this._tvectors.filter(elem => {
      return elem._number === vector_number;
    });
  }

  /**
   * vector number에 해당하는 cAtom을 반환한다.
   * @param {Number} vector_number
   * @returns {Array} vector number에 해당하는 CAtom
   */
  getAtomsByVectorNumber(vector_number) {
    return this._atoms.filter(elem => {
      let res = false;
      for (let vector of elem._ivectors) {
        if (vector._number === vector_number) {
          res = true;
          break;
        }
      }
      return res;
    });
  }

  /**
   * atom index에 해당하는 cAtom을 제거한다.
   * @param {Number} atom_idx
   */
  removeAtomByIdx(atom_idx) {
    this._atoms = this._atoms.filter(elem => {
      return elem._idx !== atom_idx;
    });
  }

  /**
   * cAtom을 모두 제거한다.
   * */
  clearAtom() {
    this._atoms = [];
    this._curAtomIdx = -1;
  }

  /**
   * aVector를 모두 제거한다.
   * */
  clearaVector() {
    this._avectors = [];
  }

  /**
   * cBond를 추가한다.
   * @param {cBond} bond
   */
  addBond(bond) {
    if (bond.constructor === Array) {
      const len = bond.length;
      let i;
      for (i = 0; i < len; i++) {
        this._bonds.push(bond[i]);
      }
    } else {
      this._bonds.push(bond);
    }
  }

  /**
   * atom1와 atom2를 데이터로 갖는 cBond를 제거한다.
   * @param {cAtom} atom1
   * @param {cAtom} atom2
   */
  removeBond(atom1, atom2) {
    this._bonds = this._bonds.filter(elem => {
      return elem.atom1 !== atom1 && elem.atom2 !== atom2;
    });
  }

  /**
   * bond index에 해당하는 cBond를 제거한다.
   * @param {Number} bond_idx
   */
  removeBondByIdx(bond_idx) {
    this._bonds = this._bonds.filter(elem => {
      return elem._idx !== bond_idx;
    });
  }

  /**
   * vector index에 해당하는 iVector를 제거한다.
   * @param {Number} vector_idx
   */
  removeVectorByIdx(vector_idx) {
    this._ivectors = this._ivectors.filter(elem => {
      return elem._idx !== vector_idx;
    });
  }

  /**
   * cBond를 모두 제거한다.
   * */
  clearBond() {
    this._bonds = [];
    this._curBondIdx = -1;
  }

  /**
   * unitcell geometry를 제거한다.
   * */
  clearUnitcell() {
    this._unitcell.clearGeom();
  }

  /**
   * crystal plane을 모두 제거한다.
   * */
  clearPlane() {
    this._crystalPlanes = [];
    this._curShapeId = -1;
  }

  /**
   * lattice plane을 모두 제거한다.
   * */
  clearLatticePlane() {
    this._latticePlanes = [];
  }

  /**
   * dot surface 가시화 여부를 설정한다.
   * @param {Boolean} show
   */
  showDotSurface(show) {
    const alen = this._iatomList.length;
    for (let ia = 0; ia < alen; ia++) {
      let atom = this._iatomList[ia];
      if (!atom._mesh) continue;
      if (atom._mesh.visible) atom.showDotSurface(show);
    }
  }

  // style 0: normal
  // 1: space-filling
  // 2: polyhedral
  // 3: wireframe
  // 4: stick
  /**
   * 렌더링 스타일을 설정한다.
   * @param {Number} style
   */
  setRenderStyle(style) {
    this._style = style;
    switch (style) {
      case 0:
        // normal
        this.setStyleWireframe(false);
        this.setStyleNormal(1, 0.05);
        break;
      case 1:
        // space-filling
        this.setStyleWireframe(false);
        this.setRadius(0, 0);
        this.setStyleNormal(2.39, 0.0);
        break;
      case 2:
        // polyhedral
        this.setStyleWireframe(false);
        this.setStyleNormal(1, 0.05);
        break;
      case 3:
        // wireframe
        this.setStyleWireframe(true);
        this.setStyleNormal(1, 0.003);
        //this.setRadius(0, 0.01);
        break;
      case 4:
        // stick
        this.setStyleWireframe(false);
        this.setRadius(0.02, 0.02);
        break;
    }
  }

  /**
   * mesh material의 wireframe 여부를 설정한다.
   * @param {Boolean} w
   */
  setStyleWireframe(w) {
    const alen = this._iatomList.length;
    for (let ia = 0; ia < alen; ia++) {
      let atom = this._iatomList[ia];
      atom.setWireframe(w);
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.setWireframe(w);
    }
  }

  /**
   * 원자와 결합에 적용될 가중치와 결합의 크기를 설정한다.
   * @param {Number} ratio
   * @param {Number} bond_radius
   */
  setStyleNormal(ratio, bond_radius) {
    const alen = this._iatomList.length;
    for (let ia = 0; ia < alen; ia++) {
      let atom = this._iatomList[ia];
      atom.setNormalRadius(ratio);
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.setRadius(bond_radius);
    }
  }

  /**
   * 원자의 크기, 결합의 크기를 설정한다.
   * @param {Number} aradius
   * @param {Number} bradius
   */
  setRadius(aradius, bradius) {
    const alen = this._iatomList.length;
    for (let ia = 0; ia < alen; ia++) {
      let atom = this._iatomList[ia];
      atom.setRadius(aradius);
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.setRadius(bradius);
    }
  }

  /**
   * iAtom 추가 가능 여부를 반환한다.
   * @param {iAtom} iatom
   * @returns {Boolean} iAtom 추가 가능 여부
   */
  canAddiAtom(iatom) {
    const len = this._iatomList.length;
    for (let i = 0; i < len; i++) {
      let atom = this._iatomList[i];
      let dist = atom.distance(iatom);
      if (dist < _mdist && atom.visible === true) return false;
    }
    return true;
  }

  /**
   * tVector와 매칭되는 iAtom의 iVector를 반환한다.
   * @param {iAtom} iatom
   * @param {tVector} tvector
   * @returns {iVector} 
   */
  findiVector(iatom, tvector) {
    const len = this._ivectors.length;
    for (let i = 0; i < len; i++) {
      let iv = this._ivectors[i];
      if (iv._iatom == iatom && iv._tvector == tvector) return iv;
    }
    return null;
  }

  /**
   * unitcell location, index가 매칭되는 iAtom을 반환한다.
   * @param {Array} uc_loc
   * @param {Number} index
   * @returns {iAtom}
   */
  findiAtom(uc_loc, index) {
    const len = this._iatomList.length;
    for (let i = 0; i < len; i++) {
      let atom = this._iatomList[i];
      if (atom._unitcellLoc[0] == uc_loc[0] && atom._unitcellLoc[1] == uc_loc[1] && atom._unitcellLoc[2] == uc_loc[2] && atom.getIndex() == index && atom._exist == true) {
        return atom;
      }
    }
    return null;
  }

  /**
   * iAtom, iBond, iVector를 모두 제거한다.
   * */
  cleariAtomiBond() {
    this._iatomList = [];
    this._ibondList = [];
    this._ivectors = [];
  }

  /**
   * iAtom을 생성한다.
   * @param {THREE.Matrix4} mat
   */
  generateAtom(mat) {
    this._boundary.update();
    let i = 0;
    let j = 0;
    let k = 0;
    const alen = this._atoms.length;
    let ia = 0;
    let idx = 0;
    let number = 0;
    for (ia = 0; ia < alen; ia++) {
      let atom = this._atoms[ia];
      atom.setAtomID(atom._id);
      idx = ia;
      for (i = this._boundary._imin._x; i < this._boundary._imax._x; i++) {
        for (j = this._boundary._imin._y; j < this._boundary._imax._y; j++) {
          for (k = this._boundary._imin._z; k < this._boundary._imax._z; k++) {
            let lpos = new three_module_Vector3(i + atom._position._x, j + atom._position._y, k + atom._position._z);
            if (mat) {
              let lpos4 = new Vector4(atom._position._x, atom._position._y, atom._position._z, 1);
              lpos4.applyMatrix4(mat);
              lpos4.divideScalar(lpos4.w);
              lpos.x = lpos4.x + i;
              lpos.y = lpos4.y + j;
              lpos.z = lpos4.z + k;
            }
            let iatom = new iAtom(atom, lpos);
            iatom.setUnitcellLoc(i, j, k, idx);
            if (!this.canAddiAtom(iatom)) continue;
            iatom._number = number;
            number++;

            //iatom.generate(this);

            this._iatomList.push(iatom);
          }
        }
      }
    }
  }

  /**
   * 1개의 iBond를 생성한다. 
   * @param {iAtom} atom1 결합의 첫번째 원소
   * @param {iAtom} atom2 결합의 두번째 원소
   * @param {cBond} bond cBond
   * @returns {iBond}
   */
  createBond(atom1, atom2, bond) {
    let ibond = new iBond(atom1, atom2, bond);
    return ibond;
  }

  /**
   * CStructure 메쉬를 생성한다.
   * @param {any} mat_list
   */
  generateWithMatrices(mat_list) {
    if (!mat_list) {
      mat_list = [getMatrix(0)];
    }
    this._groupAtomMesh.clear();
    this._groupBondMesh.clear();
    this._groupEtcMesh.clear();
    this._ivectors = [];
    this.cleariAtomiBond();
    const len = mat_list.length;
    for (let i = 0; i < len; i++) {
      let mat = mat_list[i];
      this.generateAtom(mat);
    }
    this.generateBond();
    this.generateiVectors();
    this.generateMesh4iVectors();
    let mesh = this._unitcell.generateGeom();
    this._groupEtcMesh.add(mesh);
    this.ClipBoundary();
    this.generateMesh();
    this.generatePolyhedron();
    this.generateCrystalShape();
    this.generateLatticePlanes();
  }

  /**
   * symmetry matrix를 적용한 CStructure를 만든다.
   * @param {any} mat_idx_list
   */
  generate(mat_idx_list) {
    if (!mat_idx_list) {
      mat_idx_list = [0];
    }
    const len = mat_idx_list.length;
    let mat_list = [];
    for (let i = 0; i < len; i++) {
      let matidx = mat_idx_list[i];
      let mat = getMatrix(matidx);
      mat_list.push(mat);
    }
    this.generateWithMatrices(mat_list);
  }

  /**
   * CStructure의 mesh를 반환한다.
   * @returns {THREE.Mesh}
   * */
  getMesh() {
    return this._groupMesh;
  }

  /**
   * iBond를 생성한다.
   * */
  generateBond() {
    const alen = this._iatomList.length;
    const blen = this._bonds.length;
    let bi = 0;
    let i = 0;
    let j = 0;
    for (i = 0; i < alen - 1; i++) {
      let a1 = this._iatomList[i];
      a1.calcPos2(this);
      for (j = i + 1; j < alen; j++) {
        let a2 = this._iatomList[j];
        a2.calcPos2(this);
        for (bi = 0; bi < blen; bi++) {
          let bond = this._bonds[bi];
          if (bond.condition(a1, a2)) {
            //generated = true;
            let ibond = this.createBond(a1, a2, bond);

            //ibond.generate(this);

            this._ibondList.push(ibond);
            break;
          }
        }
      }
    }
  }

  /**
   * CStructure의 mesh를 생성한다.
   * */
  generateMesh() {
    for (let i = 0; i < this._iatomList.length; ++i) {
      let iatom = this._iatomList[i];
      iatom.generate(this);
      if (iatom._mesh) {
        this._groupAtomMesh.add(iatom.getMesh());
        this._groupEtcMesh.add(iatom.getVectorMesh());
        this._groupEtcMesh.add(iatom.getDotSurface());
      }
    }
    const blen = this._ibondList.length;
    for (let ib = 0; ib < blen; ib++) {
      let bond = this._ibondList[ib];
      bond.generate(this);
      let meshes = bond.getMesh();
      if (meshes) {
        this._groupBondMesh.add(meshes[0]);
        this._groupBondMesh.add(meshes[1]);
      }
    }
  }

  /**
   * boundary에 맞게 CStructure mesh를 clip한다.
   * */
  ClipBoundary() {
    let mode = this._clipOption;
    if (mode === 0) {
      // 전체 visible off
      for (let i = 0; i < this._iatomList.length; ++i) {
        this._iatomList[i]._cvisible = false;
        this._iatomList[i]._visible = false;
      }
      for (let i = 0; i < this._iatomList.length; ++i) {
        if (this._iatomList[i]._def._visible && this.isIn(this._iatomList[i])) {
          this._iatomList[i]._cvisible = true;
          this._iatomList[i]._visible = true;
        }
      }

      // ibond에서 살펴보기
      for (let elem of this._ibondList) {
        if (elem._a1._cvisible || elem._a2._cvisible) {
          elem._a2._visible = true;
          elem._a1._visible = true;
          elem._visible = true;
        } else {
          elem._visible = false;
        }
      }
    } else if (mode === 1) {
      // 전체 visible off
      for (let i = 0; i < this._iatomList.length; ++i) {
        this._iatomList[i].setVisible(false);
      }
      for (let i = 0; i < this._iatomList.length; ++i) {
        if (this._iatomList[i]._def._visible && this.isIn(this._iatomList[i])) {
          this._iatomList[i].setVisible(true);
        }
      }

      // ibond에서 살펴보기
      for (let elem of this._ibondList) {
        if (elem._a1._visible && elem._a2._visible) {
          for (let bond of elem._meshes) {
            bond.visible = true;
          }
        } else {
          for (let bond of elem._meshes) {
            bond.visible = false;
          }
        }
      }
    }
  }

  /**
   * 주어진 position에 대해 포함 여부를 반환한다.
   * @param {THREE.Vector3} pos 객체의 위치 정보
   * @returns {Boolean} 포함 여부
   */
  isIn(iatom) {
    return this._boundary.isIn(iatom._position, iatom._position2);
  }

  /**
   * CStructure 데이터를 저장한다.
   * @returns {CStructure} 저장 데이터 형식의 CStructure
   * */
  SaveCStructure() {
    let cs = this.clone();
    for (let i = 0; i < cs._atoms.length; ++i) {
      cs._atoms[i] = cs._atoms[i].createData4Save();
    }
    for (let i = 0; i < cs._bonds.length; ++i) {
      cs._bonds[i] = cs._bonds[i].createData4Save();
    }
    cs._unitcell = cs._unitcell.createData4Save();
    cs._boundary = cs._boundary.createData4Save();
    for (let i = 0; i < cs._tvectors.length; ++i) {
      cs._tvectors[i] = cs._tvectors[i].createData4Save();
    }
    for (let i = 0; i < cs._avectors.length; ++i) {
      cs._avectors[i] = cs._avectors[i].createData4Save();
    }
    for (let i = 0; i < cs._crystalPlanes.length; ++i) {
      cs._crystalPlanes[i] = cs._crystalPlanes[i].createData4Save();
    }
    for (let i = 0; i < cs._latticePlanes.length; ++i) {
      cs._latticePlanes[i] = cs._latticePlanes[i].createData4Save();
    }
    delete cs._iatomList;
    delete cs._ibondList;
    delete cs._groupMesh;
    delete cs._groupAtomMesh;
    delete cs._groupBondMesh;
    delete cs._groupEtcMesh;
    cs._ivectors = [];
    return cs;
  }

  /**
   * CStructure 정보를 가진 데이터로부터 CStructure를 복원한다.
   * @param {CStructure} cs
   */
  LoadCStructure(cs) {
    this._name = cs._name;
    this._position = new Vector3(cs._position._x, cs._position._y, cs._position._z);
    this._direction = new Vector3(cs._direction._x, cs._direction._y, cs._direction._z);
    for (let i = 0; i < cs._tvectors.length; ++i) {
      this.LoadtVectorFromJSON(cs._tvectors[i]);
    }
    this.numberVectors();

    // avector도 저장하는 걸 만들자
    for (let i = 0; i < cs._avectors.length; ++i) {
      this.LoadaVectorFromJSON(cs._avectors[i]);
    }
    for (let i = 0; i < cs._atoms.length; ++i) {
      this.LoadAtomFromJSON(cs._atoms[i]);
    }
    for (let i = 0; i < cs._bonds.length; ++i) {
      this.LoadBondFromJSON(cs._bonds[i]);
    }
    this.LoadBoundaryFromJSON(cs._boundary);
    this.LoadUnitcellFromJSON(cs._unitcell);
    for (let i = 0; i < cs._crystalPlanes.length; ++i) {
      this.LoadCrystalPlaneFromJSON(cs._crystalPlanes[i]);
    }
    for (let i = 0; i < cs._latticePlanes.length; ++i) {
      this.LoadLatticePlaneFromJSON(cs._latticePlanes[i]);
    }
  }

  /**
   * JSON 데이터로부터 tVector를 불러온다.
   * @param {String} tVectorJSON tVector 정보가 담긴 JSON
   */
  LoadtVectorFromJSON(tVectorJSON) {
    let tvector = new tVector([tVectorJSON._vector[0], tVectorJSON._vector[1], tVectorJSON._vector[2]], [tVectorJSON._color[0], tVectorJSON._color[1], tVectorJSON._color[2]], tVectorJSON._radius);
    this._tvectors.push(tvector);
  }

  /**
   * JSON 데이터로부터 aVector를 불러온다.
   * @param {String} aVectorJSON aVector 정보가 담긴 JSON
   */
  LoadaVectorFromJSON(aVectorJSON) {
    let avector = null;
    for (let i = 0; i < this._tvectors.length; ++i) {
      if (this._tvectors[i]._number === aVectorJSON._def._number) {
        avector = new aVector(this._tvectors[i]);
        break;
      }
    }
    if (avector) {
      avector._unitcellPos = aVectorJSON._unitcellPos;
      avector._index = aVectorJSON._index;
      this._avectors.push(avector);
    }
  }

  /**
   * JSON 데이터로부터 CStructure를 불러온다.
   * @param {String} jsonStr CStructure 정보가 담긴 JSON
   */
  LoadInstanceFromJSON(jsonStr) {
    this._atoms = [];
    for (let i = 0; i < jsonStr._atoms.length; ++i) {
      this.LoadAtomFromJSON(jsonStr._atoms[i]);
    }
    this._bonds = [];
    for (let i = 0; i < jsonStr._bonds.length; ++i) {
      this.LoadBondFromJSON(jsonStr._bonds[i]);
    }
    this._boundary = new Boundary();
    this.LoadBoundaryFromJSON(jsonStr._boundary);
    for (let i = 0; i < jsonStr._iatomList.length; ++i) {
      this.LoadIAtomFromJSON(jsonStr._iatomList[i]);
    }
    for (let i = 0; i < jsonStr._ibondList.length; ++i) {
      this.LoadIBondFromJSON(jsonStr._ibondList[i]);
    }

    // unitcell
    this.LoadUnitcellFromJSON(jsonStr._unitcell);
  }

  /**
   * json 데이터로부터 cAtom을 불러온다.
   * @param {String} atomJSON cAtom 정보가 담긴 json
   */
  LoadAtomFromJSON(atomJSON) {
    let idx = this._atoms.length;
    let catom = new CAtom().cloneFromAtom(atomJSON);

    // *** avector 생성 부분 수정하기 ***
    for (let i = 0; i < atomJSON._avectors.length; ++i) {
      catom._avectors[i] = new aVector(this._tvectors[atomJSON._avectors[i]._def._number]);
    }
    catom._idx = idx;
    this._atoms.push(catom);
  }

  /**
   * json 데이터로부터 cBnd 데이터를 불러온다.
   * @param {String} bondJSON cBond 정보가 담긴 json
   */
  LoadBondFromJSON(bondJSON) {
    let idx = this._bonds.length;
    let newBond = new CBond().cloneFromBond(bondJSON);
    newBond._idx = idx;
    this._bonds.push(newBond);
  }

  /**
   * json 데이터로부터 boundary 데이터를 불러온다.
   * @param {String} boundaryJSON boundary 정보가 담긴 json
   */
  LoadBoundaryFromJSON(boundaryJSON) {
    this._boundary = new Boundary().cloneFromBoundary(boundaryJSON);
  }

  /**
   * json 데이터로부터 iAtom 데이터를 불러온다.
   * @param {String} iAtomJSON iAtom 정보가 담긴 json
   */
  LoadIAtomFromJSON(iAtomJSON) {
    this._iatomList.push(new iAtom().cloneFromIAtom(this, iAtomJSON));
  }

  /**
   * json 데이터로부터 iBond 데이터를 불러온다.
   * @param {String} iBondJSON iBond 정보가 담긴 json
   */
  LoadIBondFromJSON(iBondJSON) {
    this._ibondList.push(new iBond().cloneFromBond(iBondJSON));
  }

  /**
   * json 데이터로부터 unitcell 데이터를 불러온다.
   * @param {String} unitcellJSON unitcell 정보가 담긴 json
   */
  LoadUnitcellFromJSON(unitcellJSON) {
    this._unitcell = new UnitCell().cloneFromUnitcell(unitcellJSON);
  }
  LoadCrystalPlaneFromJSON(crystalPlaneJSON) {
    let plane = new Plane_Plane().cloneFromPlane(crystalPlaneJSON);
    plane._id = this._crystalPlanes.length;
    this._crystalPlanes.push(plane);
  }
  LoadLatticePlaneFromJSON(latticePlaneJSON) {
    this._latticePlanes.push(new Plane_Plane().cloneFromPlane(latticePlaneJSON));
  }

  /**
   * polyhedron을 생성한다.
   * */
  generatePolyhedron() {
    if (this._polyhedron) {
      this._polyhedron.dispose();
      this._polyhedron = null;
    }
    this._polyhedron = new Polyhedron(this._groupEtcMesh);
    this._polyhedron.generateWithAtomBondList(this._iatomList, this._ibondList);
    this.setVisiblePolyhedron(this._polyhedronVisible);
  }

  /**
   * polyhedron 가시화 여부를 설정한다.
   * @param {Boolean} vis 가시화 여부
   */
  setVisiblePolyhedron(vis) {
    this._polyhedronVisible = vis;
    if (this._polyhedron) {
      this._polyhedron.setVisible(vis);
    }
  }

  /**
   * polyhedron edge 가시화 여부를 설정한다.
   * @param {Boolean} vis 가시화 여부
   */
  setVisiblePolyhedronEdge(vis) {
    this._polyhedronVisibleEdge = vis;
    if (this._polyhedron) {
      this._polyhedron.setVisibleEdge(vis);
    }
  }

  /**
   * polyhedron의 광도를 설정한다.
   * @param {Number} shi polyhedron shininess
   */
  setPolyhedronShininess(shi) {
    this._polyhedronShininess = shi;
    if (this._polyhedron) {
      this._polyhedron.setShininess(shi);
    }
  }

  /**
   * crystal shape를 생성한다.
   * */
  generateCrystalShape() {
    if (this._crystalShape) {
      this._crystalShape.dispose();
      this._crystalShape = null;
    }
    this._crystalShape = new CrystalShape(this._groupEtcMesh);
    this._crystalShape.generateWithPlanes(this._crystalPlanes);
  }

  /**
   * crystal shape 가시화 여부를 설정한다.
   * @param {Boolean} vis crystal shape 가시화 여부
   */
  setVisibleCrystalShape(vis) {
    this._crystalShapeVisible = vis;
    if (this._crystalShape) {
      this._crystalShape.setVisible(vis);
    }
  }

  /**
   * crystal shape edge 가시화 여부를 설정한다.
   * @param {Boolean} vis crystal shape edge 가시화 여부
   */
  setVisibleCrystalShapeEdge(vis) {
    this._crystalShapeVisibleEdge = vis;
    if (this._crystalShape) {
      this._crystalShape.setVisible(vis);
    }
  }

  /**
   * lattice plane을 생성한다.
   * */
  generateLatticePlanes() {
    if (this._latticePlaneObj) {
      this._latticePlaneObj.dispose();
      this._latticePlaneObj = null;
    }
    this._latticePlaneObj = new LatticePlanes(this._groupEtcMesh);
    let lpsize = 1;
    if (this._unitcell && this._unitcell._axis) {
      if (lpsize < this._unitcell._axis._la) lpsize = this._unitcell._axis._la;
      if (lpsize < this._unitcell._axis._lb) lpsize = this._unitcell._axis._lb;
      if (lpsize < this._unitcell._axis._lc) lpsize = this._unitcell._axis._lc;
    }
    lpsize *= 2.1;
    this._latticePlaneObj.generateWithPlanes(this._latticePlanes, lpsize);
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/BondData.js


var _data = [];

/**
 *
 * */
class BondData {
  static loadFile(filePath) {
    var result = null;
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("GET", filePath, false);
    xmlhttp.send();
    if (xmlhttp.status == 200) {
      result = xmlhttp.responseText;
    }
    return result;
  }
  static init() {
    let fileurl = "./_resources/bond.txt";
    let data = BondData.loadFile(fileurl);
    BondData.parse(data);
  }
  static parse(data) {
    let strings = data.split("\n");
    for (let i = 0; i < strings.length; i++) {
      let str = strings[i];
      let obj = {};
      let num = str.substring(0, 3);
      let a1 = str.substring(3, 9);
      let aa1 = a1.replace(/ /g, "");
      obj._a1 = AtomDef.GetDefWithID(aa1);
      let a2 = str.substring(9, 15);
      let aa2 = a2.replace(/ /g, "");
      obj._a2 = AtomDef.GetDefWithID(aa2);
      obj._min = str.substring(15, 26) * 1;
      obj._max = str.substring(26, 37) * 1;
      _data.push(obj);
    }
  }
  static findbond(a1, a2) {
    for (let i = 0; i < _data.length; i++) {
      let bond = _data[i];
      if (a1._def == bond._a1 && a2._def == bond._a2) return bond;
    }
    return null;
  }
  static addBonds(cs) {
    for (let i = 0; i < cs._atoms.length - 1; i++) {
      let a1 = cs._atoms[i];
      for (let j = i + 1; j < cs._atoms.length; j++) {
        let a2 = cs._atoms[j];
        let bond = BondData.findbond(a1, a2);
        if (bond) {
          let cb = new CBond();
          cb.setAtom(a1, a2);
          cb._minLength = bond._min;
          cb._maxLength = bond._max;
          cs.addBond(cb);
        }
      }
    }
  }
}
BondData.init();
;// CONCATENATED MODULE: ./CoreCrystal/fileCif.js



/**
 * file의 text를 반환한다.
 * @param {File} file 읽을 파일 객체
 * @returns {String} 읽은 텍스트 결과
 */
function readTextFile(file) {
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", file, false);
  var allText = "";
  rawFile.onreadystatechange = function () {
    if (rawFile.readyState === 4) {
      if (rawFile.status === 200 || rawFile.status == 0) {
        allText = rawFile.responseText;
        //return allText;
      }
    }
  };

  rawFile.send(null);
  return allText;
}

/**
 * 타입에 맞는 데이터로 변환하여 반환한다.
 * @param {String} value 값을 나타내는 문자열
 * @returns {String} 변환된 문자열
 */
function parseType(value) {
  let newValue = Number(value);
  if (isNaN(newValue)) {
    newValue = value;
    if (value[0] === "'") {
      newValue = value.slice(1, value.length - 1);
    }
  }
  return newValue;
}

/**
 * 문자열로부터 key와 value를 추출한다.
 * @param {String} string 해석할 문자열
 * @return {Object} key, value pair
 */
function varReader(string) {
  let curser = 0;
  let key = new String();
  let rawValue = new String();
  for (; curser < string.length; curser++) {
    if (string[curser] !== " ") {
      key = key + string[curser];
    } else {
      break;
    }
  }
  for (; curser < string.length; curser++) {
    rawValue = rawValue + string[curser];
  }
  rawValue = rawValue.trim();
  let value = parseType(rawValue);
  return {
    key,
    value
  };
}

/**
 * 주어진 문자열을 읽어 obj에 key, value를 추가한다.
 * @param {String} strings 해석할 문자열
 * @param {Object} obj 결과를 저장할 변수
 */
function loopReader(strings = [new String()], obj) {
  let curser = 0;
  let keys = [];
  for (let i = 0; i < strings.length; i++) {
    strings[i] = strings[i].trim();
  }
  for (curser = 0; curser < strings.length; curser++) {
    if (strings[curser][0] === "_") {
      keys.push(strings[curser]);
    } else break;
  }
  for (let i = 0; i < keys.length; i++) {
    obj[keys[i]] = [];
  }
  for (; curser < strings.length; curser++) {
    for (let i = 0; i < keys.length; i++) {
      let v = new String();
      if (strings[curser][0] !== "'") {
        v = strings[curser].slice(0, strings[curser].indexOf(" ") === -1 ? strings[curser].length : strings[curser].indexOf(" "));
        strings[curser] = strings[curser].slice(strings[curser].indexOf(" ")).trim();
      } else {
        v = strings[curser].slice(0, strings[curser].indexOf("'", 1) + 1);
        strings[curser] = strings[curser].slice(strings[curser].indexOf("'", 1) + 1).trim();
      }
      obj[keys[i]].push(parseType(v));
    }
  }
}

/**
 * 주어진 cif 문자열로부터 해석한 결과를 반환한다.
 * @param {String} strings cif 문자열
 * @returns {Object} parse result
 */
function parseCif(strings) {
  let curser = 0;
  let data = new Object();
  let isCommentStart = false;
  for (curser = 0; curser < strings.length; curser++) {
    let string = strings[curser];
    if (!data._name) {
      if (string[0] === "#") {
        continue;
      } else {
        data._name = strings[curser];
        continue;
      }
    }
    if (string[0] === ";") {
      isCommentStart = !isCommentStart;
      continue;
    }
    if (isCommentStart) {
      continue;
    }
    if (string[0] === "#" || string.length === 0) {
      continue;
    }
    if (string.indexOf("loop_") !== -1) {
      let loopString = [];
      curser++;
      for (; curser < strings.length; curser++) {
        if (strings[curser].indexOf("loop_") === -1 && strings[curser].length !== 0) {
          if (strings[curser][0] === "_" && strings[curser].indexOf(" ") !== -1) {
            console.log(strings[curser]);
            curser--;
            break;
          }
          loopString.push(strings[curser]);
        } else {
          curser--;
          break;
        }
      }
      loopReader(loopString, data);
    } else {
      let vv = varReader(string);
      data[vv.key] = vv.value;
    }
  }
  return data;
}

/**
 * cif를 해석한 결과를 바탕으로 CStructure를 생성한다.
 * @param {Object} cif cif 결과
 * @param {CStructure} cs 생성하게 될 CStructure
 */
function cif2cstructure(cif, cs) {
  cs._unitcell.set(cif._cell_angle_alpha, cif._cell_angle_beta, cif._cell_angle_gamma, cif._cell_length_a, cif._cell_length_b, cif._cell_length_c);
  cs.setName(cif._name);
  let alen = cif._atom_site_fract_x.length;
  for (let i = 0; i < alen; i++) {
    let atom = new CAtom();
    atom._position.fromArray([cif._atom_site_fract_x[i], cif._atom_site_fract_y[i], cif._atom_site_fract_z[i]], 0);
    atom._name = cif._atom_site_label[i];
    let sym = null;
    if (cif._atom_site_type_symbol) {
      sym = cif._atom_site_type_symbol[i];
    } else {
      sym = atom._name;
    }
    atom.setAtomWithSymbol(sym);
    atom._color = atom._def._color.slice();
    if (cif._atom_site_occupancy) {
      atom._occ = cif._atom_site_occupancy[i];
    }
    cs.addAtom(atom);
  }
}

/**
 * cif 파일을 cstructure로 변환하거나,
 * cstructure를 문자열 형태로 변환하는 클래스
 * */
class fileCIF {
  /**
   * text data로부터 cstructure를 생성한다.
   * @param {String} text_data cif 문자열 데이터
   * @param {CStructure} cstructure 결과를 저장할 CStructure
   * @returns {Object} parse result
   */
  static parse(text_data, cstructure) {
    let strings = text_data.split("\n");
    let data = parseCif(strings);
    cif2cstructure(data, cstructure);
    BondData.addBonds(cstructure);
    return data;
  }

  /**
   * 주어진 CStructure를 문자열로 변환한다.
   * @param {CStructure} cs 변환할 CStructure
   * @returns {CString} 문자열로 변환된 CStructure
   */
  static toString(cs) {
    let str = "";
    let sbuf = "";
    sbuf = cs._name + "\n";
    // sbuf = "'"+cs._name + "'\n";
    str += sbuf + "\n";
    sbuf = "_cell_length_a   " + cs._unitcell._axis._la;
    str += sbuf + "\n";
    sbuf = "_cell_length_b   " + cs._unitcell._axis._lb;
    str += sbuf + "\n";
    sbuf = "_cell_length_c   " + cs._unitcell._axis._lc;
    str += sbuf + "\n";
    sbuf = "_cell_angle_alpha   " + cs._unitcell._axis._a;
    str += sbuf + "\n";
    sbuf = "_cell_angle_beta   " + cs._unitcell._axis._b;
    str += sbuf + "\n";
    sbuf = "_cell_angle_gamma   " + cs._unitcell._axis._c;
    str += sbuf + "\n";
    sbuf = "loop_";
    str += sbuf + "\n";
    sbuf = "_atom_site_type_symbol";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_label";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_symmetry_multiplicity";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_fract_x";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_fract_y";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_fract_z";
    str += " " + sbuf + "\n";
    sbuf = "_atom_site_occupancy";
    str += " " + sbuf + "\n";
    let len = cs._atoms.length;
    for (let i = 0; i < len; i++) {
      let atom = cs._atoms[i];
      sbuf = "  " + atom._def._id + "  '" + atom._label + "'  1  " + atom._position._y + "  " + atom._position._z + "  " + atom._position._x + "  " + atom._occ;
      str += sbuf + "\n";
    }
    return str;
  }
}
;// CONCATENATED MODULE: ./CoreCrystal/Loader.js






/**
 * 파일 로더 클래스
 * */
class Loader_Loader {
  static _module = null;
  static _conversion = null;

  /**
   * 데이터 변환 결과를 반환한다.
   * */
  static getConversion() {
    if (!Loader_Loader._conversion) {
      if (!Loader_Loader._module) return null;
      Loader_Loader._conversion = new Loader_Loader._module.ObConversionWrapper(); // create ObConversionWrapper instance
    }

    return Loader_Loader._conversion;
  }
  /**
   * 초기화
   * */
  static init() {
    if (Loader_Loader._module == null) {
      Loader_Loader._module = OpenBabelModule();
    }
  }
  static saveFile(type, cstructure) {
    let data = "";
    if (type == "cif") {
      data = fileCIF.toString(cstructure);
    } else if (type == "mol") {
      data = Loader_Loader.toMolString(cstructure);
    }
    return data;
  }

  /**
   * 파일로부터 데이터를 가져온다.
   * @param {String} type
   * @param {String} data
   * @param {CStructure} cstructure
   */
  static loadFile(type, data, cstructure) {
    if (type == "cif") {
      fileCIF.parse(data, cstructure);
    } else {
      Loader_Loader.init();
      let conv = Loader_Loader.getConversion();
      conv.setInFormat('', type);
      let bMol = new Loader_Loader._module.OBMol();
      conv.readString(bMol, data); // ... and load it with input data

      if (bMol == null) {
        return null;
      }
      Loader_Loader.send2CStructure(bMol, cstructure);
    }
  }

  /**
   * 숫자를 고정 길이 문자열로 변경한다.
   * @param {Number} number 숫자
   * @param {Number} len 문자열 길이
   * @returns {String}
   */
  static string2FixedLength(number, len) {
    var ret = number.toString();
    var length = ret.length;
    if (length > len) {
      return ret.substr(0, len);
    }
    for (; length < len; length++) {
      ret = " " + ret;
    }
    return ret;
  }
  /**
   * iAtom을 mol data의 문자열로 변환한다.
   * @param {iAtom} atom
   */
  static iatom2MoleString(atom) {
    var data = "";
    data += this.string2FixedLength(atom._position2.x, 10);
    data += this.string2FixedLength(atom._position2.y, 10);
    data += this.string2FixedLength(atom._position2.z, 10);
    data += this.string2FixedLength(atom._def._def._atom_id, 3);
    for (var i = 0; i < 12; i++) {
      data += "  0";
    }
    return data;
  }

  /**
   * iBond를 mol data의 문자열로 변환한다.
   * @param {iBond} ibond
   * @returns {String}
   */
  static ibond2MoleString(ibond) {
    var data = "";
    data += this.string2FixedLength(ibond._a1._export_idx, 3);
    data += this.string2FixedLength(ibond._a2._export_idx, 3);
    data += "  1  0  0  0  0";
    return data;
  }

  /**
  * 숫자를 고정된 길이의 문자열로 변환한다.
  * @param {Number} number 숫자 값
  * @param {Number} len 길이
  * @returns {String} 문자열
  */
  static string2FixedLength(number, len) {
    var ret = number.toString();
    var length = ret.length;
    if (length > len) {
      return ret.substr(0, len);
    }
    for (; length < len; length++) {
      ret = " " + ret;
    }
    return ret;
  }
  /**
   * CStructure를 mol data의 문자열로 변환한다.
   * @param {CStructure} cs
   */
  static toMolString(cs) {
    var num_atoms = 0;
    var atom_data = "";
    let len = cs._iatomList.length;
    for (let i = 0; i < len; i++) {
      let iatom = cs._iatomList[i];
      if (iatom._visible) {
        atom_data += Loader_Loader.iatom2MoleString(iatom) + "\n";
        num_atoms++;
        iatom._export_idx = num_atoms;
      }
    }
    var num_bonds = 0;
    var bond_data = "";
    len = cs._ibondList.length;
    for (let i = 0; i < len; i++) {
      let ibond = cs._ibondList[i];
      if (ibond._visible) {
        bond_data += Loader_Loader.ibond2MoleString(ibond) + "\n";
        num_bonds++;
      }
    }
    var data = "";
    data += cs._name + "\n";
    data += "\n";
    data += "" + "\n";
    data += this.string2FixedLength(num_atoms, 3);
    data += this.string2FixedLength(num_bonds, 3);
    data += "  0  0  0  0  0  0  0  0999 V2000\n";
    data += atom_data;
    data += bond_data;
    data += "M  END\n";
    return data;
  }

  /**
   * mol data의 atom을 cAtom으로 변환한다.
   * @param {Object} bAtom mol data의 atom
   * @returns {CAtom}
   */
  static convertAtom(bAtom, cs) {
    let a = cs._unitcell._axis._la;
    let b = cs._unitcell._axis._lb;
    let c = cs._unitcell._axis._lc;
    const num = bAtom.GetAtomicNum();
    let name = "";
    let a1 = new CAtom();
    let gx = bAtom.GetX();
    let gy = bAtom.GetY();
    let gz = bAtom.GetZ();
    a1._position.set(gx / a, gy / b, gz / c);
    a1._label = name;
    a1.setAtomNumber(num);
    return a1;
  }
  /**
   * bMol의 정보를 cstructure에 적용한다.
   * @param {Object} bMol mol data
   * @param {CStructure} cstructure 데이터를 저장할 cstructure
   */
  static send2CStructure(bMol, cstructure) {
    let num_atoms = bMol.NumAtoms();
    let i;
    let bAtom;
    for (i = 1; i <= num_atoms; i++) {
      bAtom = bMol.GetAtom(i);
      if (!bAtom) continue;
      let catom = Loader_Loader.convertAtom(bAtom, cstructure);
      cstructure.addAtom(catom);
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/SymmetryDef.js
var SystemDef = {};
var SpaceGroupDef = {};
var SettingDef = {};
SystemDef._defList = [];
SystemDef._numList = [];
SpaceGroupDef._defList = [];
SpaceGroupDef._numList = [];
SettingDef._defOnList = [];
SettingDef._numOnList = [];
SettingDef._defOffList = [];
SettingDef._numOffList = [];

/**
 * key에 맞는 SystemDef를 반환한다.
 * @param {String} key SystemDef key
 */
SystemDef.GetDataWithKey = function (key) {
  return SystemDef._defList[key];
};

/**
 * id에 맞는 SystemDef를 반환한다.
 * @param {Number} id SystemDef id
 */
SystemDef.GetDataWithID = function (id) {
  return SystemDef._numList[id];
};

/**
 * key에 맞는 SpaceGroupDef를 반환한다.
 * @param {String} key SpaceGroupDef key
 */
SpaceGroupDef.GetDataWithKey = function (key) {
  return SpaceGroupDef._defList[key];
};

/**
 * id에 맞는 SpaceGroupDef를 반환한다.
 * @param {Number} id SpaceGroupDef id
 */
SpaceGroupDef.GetDataWithID = function (id) {
  return SpaceGroupDef._numList[id];
};

/**
 * key, mode에 따라 SettingDef를 반환한다.
 * @param {String} key SettingDef key
 * @param {Boolean} mode SettingDef mode
 */
SettingDef.GetDataWithKey = function (key, mode) {
  if (mode) return SettingDef._defOnList[key];else return SettingDef._defOffList[key];
};

/**
 * id, mode에 따라 SettingDef를 반환한다.
 * @param {Number} id SettingDef id
 * @param {Boolean} mode SettingDef mode
 */
SettingDef.GetDataWithID = function (id, mode) {
  if (mode) return SettingDef._numOnList[id];else return SettingDef._numOffList[idx];
};

/**
 * SystemDef 클래스
 * */
class CSystemDef {
  /**
   * 생성자
   * */
  constructor() {
    this._name = "";
    this._range = [];
  }

  /**
   * 이름을 지정한다.
   * @param {String} name 지정할 이름
   */
  setName(name) {
    this._name = name;
  }

  /**
   * 포함하는 space group의 범위를 설정한다.
   * @param {Number} start space group 시작 인덱스
   * @param {Number} end space group 종료 인덱스
   */
  setRange(start, end) {
    this._range = [start, end];
  }

  /**
   * lattice field 입력창의 enable disable을 설정한다.
   * @param {Array} enableLattice lattice 입력창 설정
   */
  setEnableLattice(enableLattice) {
    this._enableLattice = enableLattice;
  }
}

/**
 * SpaceGroupDef 클래스
 * */
class CSpaceGroupDef {
  /**
   * 생성자
   * */
  constructor() {
    this._name = "";
    this._spaceGroupName = "";
  }

  /**
   * 이름을 지정한다.
   * @param {String} name 지정할 이름
   */
  setName(name) {
    this._name = name;
  }
  setIdx(idx) {
    this._idx = idx;
  }
}

/**
 * SettingDef 클래스
 * */
class CSettingDef {
  /**
   * 생성자
   * */
  constructor() {
    this._name = "";
    this._lattice = null;
    this._mode = false;
  }

  /**
   * 이름을 지정한다.
   * @param {String} name 지정할 이름
   */
  setName(name) {
    this._name = name;
  }

  /**
   * spacegroup의 이름을 지정한다.
   * @param {String} spaceGroupName space group 명
   */
  setSpaceGroupName(spaceGroupName) {
    this._spaceGroupName = spaceGroupName;
  }
  setIdx(idx) {
    this._idx = idx;
  }
  /**
   * lattice field 입력창의 enable disable을 설정한다.
   * @param {Array} lattice lattice 입력창 설정
   */
  setLattice(lattice) {
    this._lattice = lattice;
  }

  /**
   * 모드를 설정한다.
   * @param {Boolean} mode
   */
  setMode(mode) {
    this._mode = mode;
  }
  setEnableLattice(enableLattice) {
    this._enableLattice = enableLattice;
  }
}

/**
 * lattice 입력란 활성화 여부를 설정하는 클래스
 * */
class CEnableLatticeDef {
  /**
   * 생성자
   * @param {Boolean} a a입력란 활성화
   * @param {Boolean} b b입력란 활성화
   * @param {Boolean} c c입력란 활성화
   * @param {Boolean} alpha alpha입력란 활성화
   * @param {Boolean} beta beta입력란 활성화
   * @param {Boolean} gamma gamma입력란 활성화
   * @param {Boolean} su_a su_a입력란 활성화
   * @param {Boolean} su_b su_b입력란 활성화
   * @param {Boolean} su_c su_c입력란 활성화
   * @param {Boolean} su_alpha su_alpha입력란 활성화
   * @param {Boolean} su_beta su_beta입력란 활성화
   * @param {Boolean} su_gamma su_gamma입력란 활성화
   */
  constructor(a, b, c, alpha, beta, gamma, su_a, su_b, su_c, su_alpha, su_beta, su_gamma) {
    this._enableA = a;
    this._enableB = b;
    this._enableC = c;
    this._enableAlpha = alpha;
    this._enableBeta = beta;
    this._enableGamma = gamma;
    this._enableSuA = su_a;
    this._enableSuB = su_b;
    this._enableSuC = su_c;
    this._enableSuAlpha = su_alpha;
    this._enableSuBeta = su_beta;
    this._enableSuGamma = su_gamma;
  }

  /**
   * enable 설정
   * @param {Boolean} a a입력란 활성화
   * @param {Boolean} b b입력란 활성화
   * @param {Boolean} c c입력란 활성화
   * @param {Boolean} alpha alpha입력란 활성화
   * @param {Boolean} beta beta입력란 활성화
   * @param {Boolean} gamma gamma입력란 활성화
   * @param {Boolean} su_a su_a입력란 활성화
   * @param {Boolean} su_b su_b입력란 활성화
   * @param {Boolean} su_c su_c입력란 활성화
   * @param {Boolean} su_alpha su_alpha입력란 활성화
   * @param {Boolean} su_beta su_beta입력란 활성화
   * @param {Boolean} su_gamma su_gamma입력란 활성화
   */
  SetEnable(a, b, c, alpha, beta, gamma, su_a, su_b, su_c, su_alpha, su_beta, su_gamma) {
    this._enableA = a;
    this._enableB = b;
    this._enableC = c;
    this._enableAlpha = alpha;
    this._enableBeta = beta;
    this._enableGamma = gamma;
    this._enableSuA = su_a;
    this._enableSuB = su_b;
    this._enableSuC = su_c;
    this._enableSuAlpha = su_alpha;
    this._enableSuBeta = su_beta;
    this._enableSuGamma = su_gamma;
  }
}
/**
 * lattice 입력값 세팅 클래스
 * */
class CLatticeDef {
  /**
   * 생성자
   * @param {Number} a a 입력값
   * @param {Number} b b 입력값
   * @param {Number} c  c 입력값
   * @param {Number} alpha alpha 입력값
   * @param {Number} beta beta 입력값
   * @param {Number} gamma gamma 입력값
   * @param {Number} su_a su a 입력값
   * @param {Number} su_b su b 입력값
   * @param {Number} su_c su c 입력값
   * @param {Number} su_alpha su alpha 입력값
   * @param {Number} su_beta su beta 입력값
   * @param {Number} su_gamma su gamma 입력값
   */
  constructor(a, b, c, alpha, beta, gamma, su_a, su_b, su_c, su_alpha, su_beta, su_gamma) {
    this._a = a;
    this._b = b;
    this._c = c;
    this._alpha = alpha;
    this._beta = beta;
    this._gamma = gamma;
    this._su_a = su_a;
    this._su_b = su_b;
    this._su_c = su_c;
    this._su_alpha = su_alpha;
    this._su_beta = su_beta;
    this._su_gamma = su_gamma;
  }

  /**
   * 값 설정
   * @param {Number} a a 입력값
   * @param {Number} b b 입력값
   * @param {Number} c  c 입력값
   * @param {Number} alpha alpha 입력값
   * @param {Number} beta beta 입력값
   * @param {Number} gamma gamma 입력값
   * @param {Number} su_a su a 입력값
   * @param {Number} su_b su b 입력값
   * @param {Number} su_c su c 입력값
   * @param {Number} su_alpha su alpha 입력값
   * @param {Number} su_beta su beta 입력값
   * @param {Number} su_gamma su gamma 입력값
   */
  SetValue(a, b, c, alpha, beta, gamma, su_a, su_b, su_c, su_alpha, su_beta, su_gamma) {
    this._a = a;
    this._b = b;
    this._c = c;
    this._alpha = alpha;
    this._beta = beta;
    this._gamma = gamma;
    this._su_a = su_a;
    this._su_b = su_b;
    this._su_c = su_c;
    this._su_alpha = su_alpha;
    this._su_beta = su_beta;
    this._su_gamma = su_gamma;
  }
}

/**
 * SystemData 세팅
 * @param {Number} idx 인덱스
 * @param {String} name 이름
 * @param {Array} enableLattice lattice 활성화 정보
 * @param {Number} start 포함하는 space group 시작 인덱스
 * @param {Number} end 포함하는 space group 종료 인덱스
 */
function setSystemData(idx, name, enableLattice, start, end) {
  let system_def = new CSystemDef();
  system_def.setName(name);
  system_def.setEnableLattice(enableLattice);
  system_def.setRange(start, end);
  SystemDef._defList[name] = system_def;
  SystemDef._numList[idx] = system_def;
}

/**
 * SpaceGroupData 세팅
 * @param {Number} idx 인덱스
 * @param {String} name 이름
 */
function setSpaceGroupData(idx, name, symidx) {
  let spaceGroup_def = new CSpaceGroupDef();
  spaceGroup_def.setName(name);
  if (!isNaN(symidx)) {
    spaceGroup_def.setIdx(symidx);
  }
  SpaceGroupDef._defList[name] = spaceGroup_def;
  SpaceGroupDef._numList[idx] = spaceGroup_def;
}

/**
 * SettingData 세팅
 * @param {Number} idx 인덱스
 * @param {String} spaceGroupName 포함되는 space group 명
 * @param {String} name 이름
 * @param {Array} lattice lattice 정보
 * @param {Boolean} mode 모드
 */
function setSettingData(idx, spaceGroupName, name, lattice, mode, symidx, enableLattice = null) {
  let setting_def = new CSettingDef();
  setting_def.setSpaceGroupName(spaceGroupName);
  setting_def.setName(name);
  setting_def.setLattice(lattice);
  setting_def.setMode(mode);
  setting_def.setEnableLattice(enableLattice);
  if (!isNaN(symidx)) {
    setting_def.setIdx(symidx);
  }
  if (mode) {
    SettingDef._defOnList[name] = setting_def;
    if (!SettingDef._numOnList[idx]) SettingDef._numOnList[idx] = [];
    SettingDef._numOnList[idx].push(setting_def);
  } else {
    SettingDef._defOffList[name] = setting_def;
    if (!SettingDef._numOffList[idx]) SettingDef._numOffList[idx] = [];
    SettingDef._numOffList[idx].push(setting_def);
  }
}

/*
setSystemData(0, "MoleCule", new CEnableLatticeDef(false, false, false, false, false, false, false, false, false, false, false, false), -1, -1);
setSystemData(1, "Custom", new CEnableLatticeDef(true, true, true, true, true, true, true, true, true, true, true, true), -1, -1);
setSystemData(2, "Triclinic", new CEnableLatticeDef(true, true, true, true, true, true, true, true, true, true, true, true), 1, 2);
setSystemData(3, "Monoclinic", new CEnableLatticeDef(true, true, true, false, true, false, true, true, true, false, true, false), 3, 15);
setSystemData(4, "Orthorhombic", new CEnableLatticeDef(true, true, true, false, false, false, true, true, true, false, false, false), 16, 74);
setSystemData(5, "Tetragonal", new CEnableLatticeDef(true, false, true, false, false, false, true, false, true, false, false, false), 75, 142);
setSystemData(6, "Trigonal", new CEnableLatticeDef(true, false, true, false, false, false, true, false, true, false, false, false), 143, 167);
setSystemData(7, "Hexagonal", new CEnableLatticeDef(true, false, true, true, false, true, false, false, false, false, false, false), 168, 194);
setSystemData(8, "Cubic", new CEnableLatticeDef(true, false, false, false, false, false, true, false, false, false, false, false), 195, 230);
*/
setSystemData(0, "Custom", new CEnableLatticeDef(true, true, true, true, true, true, true, true, true, true, true, true), -1, -1);
setSystemData(1, "Molecule", new CEnableLatticeDef(false, false, false, false, false, false, false, false, false, false, false, false), -1, -1);
setSystemData(2, "Monoclinic", new CEnableLatticeDef(true, true, true, false, true, false, true, true, true, false, true, false), 1, 2);
setSystemData(3, "Hexagonal", new CEnableLatticeDef(true, false, true, true, false, true, false, false, false, false, false, false), 3, 4);
setSystemData(4, "Cubic", new CEnableLatticeDef(true, false, false, false, false, false, true, false, false, false, false, false), 5, 6);
setSpaceGroupData(0, "P 2", 2);
setSpaceGroupData(1, "P 21", 3);
setSpaceGroupData(2, "P 6", 167);
setSpaceGroupData(3, "P 61", 168);
setSpaceGroupData(4, "P 2 3", 194);
setSpaceGroupData(5, "F 2 3", 195);

// P 2
setSettingData(0, "P 2", "P 2(Unique axis b)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90, 73.2213, 90, 0, 0, 0, 0, 0, 0), false, 0, new CEnableLatticeDef(true, true, true, false, true, false, true, true, true, false, true, false));
setSettingData(0, "P 2", "P 2(Unique axis c)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90, 90, 79.1065, 0, 0, 0, 0, 0, 0), false, 1, new CEnableLatticeDef(true, true, true, false, false, true, true, true, true, false, true, false));
setSettingData(0, "P 2", "P 2(Unique axis a)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 2, new CEnableLatticeDef(true, true, true, true, false, false, true, true, true, false, true, false));

// P 21
setSettingData(1, "P 21", "P 21(Unique axis b)", new CLatticeDef(1.22474, 1.22474, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 0, new CEnableLatticeDef(true, true, true, false, true, false, true, true, true, false, true, false));
setSettingData(1, "P 21", "P 21(Unique axis c)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 1, new CEnableLatticeDef(true, true, true, false, false, true, true, true, true, false, false, true));
setSettingData(1, "P 21", "P 21(Unique axis a)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 2, new CEnableLatticeDef(true, true, true, true, false, false, true, true, true, true, false, false));

// P 6
setSettingData(2, "P 6", "P 6", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 0);

// P 61
setSettingData(3, "P 61", "P 61", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 0);

// P 2 3
setSettingData(4, "P 2 3", "P 2 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 0);

// F 2 3
setSettingData(5, "F 2 3", "F 2 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false, 0);

/*
setSpaceGroupData(0, "P 1");
setSpaceGroupData(1, "P -1");
setSpaceGroupData(2, "P 2");
setSpaceGroupData(3, "P 21");
setSpaceGroupData(4, "C 2");
setSpaceGroupData(5, "P m");
setSpaceGroupData(6, "P c");
setSpaceGroupData(7, "C m");
setSpaceGroupData(8, "C c");
setSpaceGroupData(9, "P 2/m");
setSpaceGroupData(10, "P 21/m");
setSpaceGroupData(11, "C 2/m");
setSpaceGroupData(12, "P 2/c");
setSpaceGroupData(13, "P 21/c");
setSpaceGroupData(14, "C 2/c");
setSpaceGroupData(15, "P 2 2 2");
setSpaceGroupData(16, "P 2 2 21");
setSpaceGroupData(17, "P 21 21 2");
setSpaceGroupData(18, "P 21 21 21");
setSpaceGroupData(19, "C 2 2 21");
setSpaceGroupData(20, "C 2 2 2");
setSpaceGroupData(21, "F 2 2 2");
setSpaceGroupData(22, "I 2 2 2");
setSpaceGroupData(23, "I 21 21 21");
setSpaceGroupData(24, "P m m 2");
setSpaceGroupData(25, "P m c 21");
setSpaceGroupData(26, "P c c 2");
setSpaceGroupData(27, "P m a 2");
setSpaceGroupData(28, "P c a 21");
setSpaceGroupData(29, "P n c 2");
setSpaceGroupData(30, "P m n 21");
setSpaceGroupData(31, "P b a 2");
setSpaceGroupData(32, "P n a 21");
setSpaceGroupData(33, "P n n 2");
setSpaceGroupData(34, "C m m 2");
setSpaceGroupData(35, "C m c 21");
setSpaceGroupData(36, "C c c 2");
setSpaceGroupData(37, "A m m 2");
setSpaceGroupData(38, "A e m 2");
setSpaceGroupData(39, "A m a 2");
setSpaceGroupData(40, "A e a 2");
setSpaceGroupData(41, "F m m 2");
setSpaceGroupData(42, "F d d 2");
setSpaceGroupData(43, "I m m 2");
setSpaceGroupData(44, "I b a 2");
setSpaceGroupData(45, "I m a 2");
setSpaceGroupData(46, "P m m m");
setSpaceGroupData(47, "P n n n");
setSpaceGroupData(48, "P c c m");
setSpaceGroupData(49, "P b a n");
setSpaceGroupData(50, "P m m a");
setSpaceGroupData(51, "P n n a");
setSpaceGroupData(52, "P m n a");
setSpaceGroupData(53, "P c c a");
setSpaceGroupData(54, "P b a m");
setSpaceGroupData(55, "P c c n");
setSpaceGroupData(56, "P b c m");
setSpaceGroupData(57, "P n n m");
setSpaceGroupData(58, "P m m n");
setSpaceGroupData(59, "P b c n");
setSpaceGroupData(60, "P b c a");
setSpaceGroupData(61, "P n m a");
setSpaceGroupData(62, "C m c m");
setSpaceGroupData(63, "C m c e");
setSpaceGroupData(64, "C m m m");
setSpaceGroupData(65, "C c c m");
setSpaceGroupData(66, "C m m e");
setSpaceGroupData(67, "C c c e");
setSpaceGroupData(68, "F m m m");
setSpaceGroupData(69, "F d d d");
setSpaceGroupData(70, "I m m m");
setSpaceGroupData(71, "I b a m");
setSpaceGroupData(72, "I b c a");
setSpaceGroupData(73, "I m m a");
setSpaceGroupData(74, "P 4");
setSpaceGroupData(75, "P 41");
setSpaceGroupData(76, "P 42");
setSpaceGroupData(77, "P 43");
setSpaceGroupData(78, "I 4");
setSpaceGroupData(79, "I 41");
setSpaceGroupData(80, "P -4");
setSpaceGroupData(81, "I -4");
setSpaceGroupData(82, "P 4/m");
setSpaceGroupData(83, "P 42/m");
setSpaceGroupData(84, "P 4/n");
setSpaceGroupData(85, "P 42/n");
setSpaceGroupData(86, "I 4/m");
setSpaceGroupData(87, "I 41/a");
setSpaceGroupData(88, "P 4 2 2");
setSpaceGroupData(89, "P 4 21 2");
setSpaceGroupData(90, "P 41 2 2");
setSpaceGroupData(91, "P 41 21 2");
setSpaceGroupData(92, "P 42 2 2");
setSpaceGroupData(93, "P 42 21 2");
setSpaceGroupData(94, "P 43 2 2");
setSpaceGroupData(95, "P 43 21 2");
setSpaceGroupData(96, "I 4 2 2");
setSpaceGroupData(97, "I 41 2 2");
setSpaceGroupData(98, "P 4 m m");
setSpaceGroupData(99, "P 4 b m");
setSpaceGroupData(100, "P 42 c m");
setSpaceGroupData(101, "P 42 n m");
setSpaceGroupData(102, "P 4 c c");
setSpaceGroupData(103, "P 4 n c");
setSpaceGroupData(104, "P 42 m c");
setSpaceGroupData(105, "P 42 b c");
setSpaceGroupData(106, "I 4 m m");
setSpaceGroupData(107, "I 4 c m");
setSpaceGroupData(108, "I 41 m d");
setSpaceGroupData(109, "I 41 c d");
setSpaceGroupData(110, "P -4 2 m");
setSpaceGroupData(111, "P -4 2 c");
setSpaceGroupData(112, "P -4 21 m");
setSpaceGroupData(113, "P -4 21 c");
setSpaceGroupData(114, "P -4 m 2");
setSpaceGroupData(115, "P -4 c 2");
setSpaceGroupData(116, "P -4 b 2");
setSpaceGroupData(117, "P -4 n 2");
setSpaceGroupData(118, "I -4 m 2");
setSpaceGroupData(119, "I -4 c 2");
setSpaceGroupData(120, "I -4 2 m");
setSpaceGroupData(121, "I -4 2 d");
setSpaceGroupData(122, "P 4/m m m");
setSpaceGroupData(123, "P 4/m c c");
setSpaceGroupData(124, "P 4/n b m");
setSpaceGroupData(125, "P 4/n n c");
setSpaceGroupData(126, "P 4/m b m");
setSpaceGroupData(127, "P 4/m n c");
setSpaceGroupData(128, "P 4/n m m");
setSpaceGroupData(129, "P 4/n c c");
setSpaceGroupData(130, "P 42/m m c");
setSpaceGroupData(131, "P 42/m c m");
setSpaceGroupData(132, "P 42/n b c");
setSpaceGroupData(133, "P 42/n n m");
setSpaceGroupData(134, "P 42/m b c");
setSpaceGroupData(135, "P 42/m n m");
setSpaceGroupData(136, "P 42/n m c");
setSpaceGroupData(137, "P 42/n c m");
setSpaceGroupData(138, "I 4/m m m");
setSpaceGroupData(139, "I 4/m c m");
setSpaceGroupData(140, "I 41/a m d");
setSpaceGroupData(141, "I 41/a c d");
setSpaceGroupData(142, "P 3");
setSpaceGroupData(143, "P 31");
setSpaceGroupData(144, "P 32");
setSpaceGroupData(145, "R 3");
setSpaceGroupData(146, "P -3");
setSpaceGroupData(147, "R -3");
setSpaceGroupData(148, "P 3 1 2");
setSpaceGroupData(149, "P 3 2 1");
setSpaceGroupData(150, "P 31 1 2");
setSpaceGroupData(151, "P 31 2 1");
setSpaceGroupData(152, "P 32 1 2");
setSpaceGroupData(153, "P 32 2 1");
setSpaceGroupData(154, "R 3 2");
setSpaceGroupData(155, "P 3 m 1");
setSpaceGroupData(156, "P 3 1 m");
setSpaceGroupData(157, "P 3 c 1");
setSpaceGroupData(158, "P 3 1 c");
setSpaceGroupData(159, "R 3 m");
setSpaceGroupData(160, "R 3 c");
setSpaceGroupData(161, "P -3 1 m");
setSpaceGroupData(162, "P -3 1 c");
setSpaceGroupData(163, "P -3 m 1");
setSpaceGroupData(164, "P -3 c 1");
setSpaceGroupData(165, "R -3 m");
setSpaceGroupData(166, "R -3 c");

setSpaceGroupData(167, "P 6");
setSpaceGroupData(168, "P 61");

setSpaceGroupData(169, "P 65");
setSpaceGroupData(170, "P 62");
setSpaceGroupData(171, "P 64");
setSpaceGroupData(172, "P 63");
setSpaceGroupData(173, "P -6");
setSpaceGroupData(174, "P 6/m");
setSpaceGroupData(175, "P 63/m");
setSpaceGroupData(176, "P 6 2 2");
setSpaceGroupData(177, "P 61 2 2");
setSpaceGroupData(178, "P 65 2 2");
setSpaceGroupData(179, "P 62 2 2");
setSpaceGroupData(180, "P 64 2 2");
setSpaceGroupData(181, "P 63 2 2");
setSpaceGroupData(182, "P 6 m m");
setSpaceGroupData(183, "P 6 c c");
setSpaceGroupData(184, "P 63 c m");
setSpaceGroupData(185, "P 63 m c");
setSpaceGroupData(186, "P -6 m 2");
setSpaceGroupData(187, "P -6 c 2");
setSpaceGroupData(188, "P -6 2 m");
setSpaceGroupData(189, "P -6 2 c");
setSpaceGroupData(190, "P 6/m m m");
setSpaceGroupData(191, "P 6/m c c");
setSpaceGroupData(192, "P 63/m c m");
setSpaceGroupData(193, "P 63/m m c");

setSpaceGroupData(194, "P 2 3");
setSpaceGroupData(195, "F 2 3");

setSpaceGroupData(196, "I 2 3");
setSpaceGroupData(197, "P 21 3");
setSpaceGroupData(198, "I 21 3");
setSpaceGroupData(199, "P m -3");
setSpaceGroupData(200, "P n -3");
setSpaceGroupData(201, "F m -3");
setSpaceGroupData(202, "F d -3");
setSpaceGroupData(203, "I m -3");
setSpaceGroupData(204, "P a -3");
setSpaceGroupData(205, "I a -3");
setSpaceGroupData(206, "P 4 3 2");
setSpaceGroupData(207, "P 42 3 2");
setSpaceGroupData(208, "F 4 3 2");
setSpaceGroupData(209, "F 41 3 2");
setSpaceGroupData(210, "I 4 3 2");
setSpaceGroupData(211, "P 43 3 2");
setSpaceGroupData(212, "P 41 3 2");
setSpaceGroupData(213, "I 41 3 2");
setSpaceGroupData(214, "P -4 3 m");
setSpaceGroupData(215, "F -4 3 m");
setSpaceGroupData(216, "I -4 3 m");
setSpaceGroupData(217, "P -4 3 n");
setSpaceGroupData(218, "F -4 3 c");
setSpaceGroupData(219, "I -4 3 d");
setSpaceGroupData(220, "P m -3 m");
setSpaceGroupData(221, "P n -3 n");
setSpaceGroupData(222, "P m -3 n");
setSpaceGroupData(223, "P n -3 m");
setSpaceGroupData(224, "F m -3 m");
setSpaceGroupData(225, "F m -3 c");
setSpaceGroupData(226, "F d -3 m");
setSpaceGroupData(227, "F d -3 c");
setSpaceGroupData(228, "I m -3 m");
setSpaceGroupData(229, "I a -3 d");


// P 1

setSettingData(0, "P 1", "P 1", new CLatticeDef(0.66667, 0.5, 0.44096, 89.9996, 100.8934, 89.9997, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "A 1", new CLatticeDef(0.66667, 0.66667, 0.66667, 97.1808, 97.1808, 97.1808, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "B 1", new CLatticeDef(0.86603, 0.5, 0.72649, 90, 66.5865, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "C 1", new CLatticeDef(0.83334, 0.83334, 0.44096, 81.3045, 98.6955, 106.2607, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "I 1", new CLatticeDef(0.66667, 0.72649, 0.83334, 50.0313, 69.5127, 73.3353, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "F 1", new CLatticeDef(1.00001, 0.88192, 1.00001, 89.9995, 120.0002, 124.5377, 0, 0, 0, 0, 0, 0), false);
setSettingData(0, "P 1", "R 1", new CLatticeDef(1.41421, 1.41421, 1.73205, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);


// P -1
setSettingData(1, "P -1", "P -1", new CLatticeDef(0.66667, 0.5, 0.44096, 89.9996, 100.8936, 89.9997, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "A -1", new CLatticeDef(0.66667, 0.66667, 0.66667, 97.1808, 97.1811, 97.1806, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "B -1", new CLatticeDef(0.86603, 0.5, 0.72649, 89.9995, 66.5868, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "C -1", new CLatticeDef(0.83334, 0.83334, 0.44096, 81.3039, 98.6955, 106.2601, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "I -1", new CLatticeDef(0.66667, 0.72649, 0.83334, 50.0315, 69.5125, 73.3351, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "F -1", new CLatticeDef(1, 0.88192, 1.00001, 89.9999, 120.0000, 124.5375, 0, 0, 0, 0, 0, 0), false);
setSettingData(1, "P -1", "R -1", new CLatticeDef(0.83334, 0.66667, 0.88193, 79.1063, 79.1065, 110.4871, 0, 0, 0, 0, 0, 0), false);


// P 2
setSettingData(2, "P 2", "P 2(Unique axis b)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90, 73.2213,90,0,0,0,0,0,0), false);
setSettingData(2, "P 2", "P 2(Unique axis c)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90, 90, 79.1065,0,0,0,0,0,0), false);
setSettingData(2, "P 2", "P 2(Unique axis a)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21
setSettingData(3, "P 21", "P 21(Unique axis b)", new CLatticeDef(1.22474, 1.22474, 1.41421, 90,90,90, 0,0 ,0,0,0,0), false);
setSettingData(3, "P 21", "P 21(Unique axis c)", new CLatticeDef(1.41421, 1.22474, 1.22474, 90,90,90, 0,0 ,0,0,0,0), false);
setSettingData(3, "P 21", "P 21(Unique axis a)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C 2
setSettingData(4, "C 2", "C 2(Unique aixs b)", new CLatticeDef(1.73204, 1.41421, 1.22474, 90, 135, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "A 2(Unique aixs b)", new CLatticeDef(1.22474, 1.41421, 1.73204, 90, 134.9999, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "I 2(Unique aixs b)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90.0002, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "A 2(Unique aixs c)", new CLatticeDef(1.22474, 1.41421, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "B 2(Unique aixs c)", new CLatticeDef(1.41421, 1.87082, 1.22474, 90, 90, 139.1066, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "I 2(Unique aixs c)", new CLatticeDef(1.87082, 1.22474, 1.22474, 90, 90, 130.8932, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "B 2(Unique aixs a)", new CLatticeDef(1.87082, 1.22474, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "C 2(Unique aixs a)", new CLatticeDef(1.87082, 1.22474, 1.73204, 135.0000, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(4, "C 2", "I 2(Unique aixs a)", new CLatticeDef(1.87082, 1.73204, 1.22474, 134.9999, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m
setSettingData(5, "P m", "P m (Unique axis b)", new CLatticeDef(1.87082, 1.73204, 1.22474, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(5, "P m", "P m (Unique axis c)", new CLatticeDef(1.22474, 1.87082, 1.73204, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(5, "P m", "P m (Unique axis a)", new CLatticeDef(1.73204, 1.22474, 1.87082, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c
setSettingData(6, "P c", "P c (Unique axis b)", new CLatticeDef(2.54950, 1.22474, 1.73204, 90, 132.7942, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P n (Unique axis b)", new CLatticeDef(1.87082, 1.22474, 2.54950, 90, 137.2060, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P a (Unique axis b)", new CLatticeDef(1.73204, 1.22474, 1.87082, 90, 89.9998, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P a (Unique axis c)", new CLatticeDef(1.73204, 1.22474, 1.87082, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P n (Unique axis c)", new CLatticeDef(1.22474, 2.12131, 1.87082, 90, 90, 125.2645, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P b (Unique axis c)", new CLatticeDef(2.12131, 1.73204, 1.87082, 90, 90, 144.7356, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P b (Unique axis a)", new CLatticeDef(2.12131, 1.73204, 1.87082, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P n (Unique axis a)", new CLatticeDef(2.12131, 1.87082, 2.54950, 137.2059, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(6, "P c", "P c (Unique axis a)", new CLatticeDef(2.12131, 2.54950, 1.73204, 132.7942, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(4.24264, 3.46410, 1.73205, 90, 114.0948, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(3.87298, 3.46410, 4.24264, 90, 155.9051, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(1.73205, 3.46410, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(1.73205, 4.24264, 3.46410, 90, 90, 114.0948, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(4.24264, 3.87298, 3.46410, 90, 90, 155.9051, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(3.87298, 1.73205, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(3.46410, 1.73205, 4.24264, 114.0948, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(3.46410, 4.24264, 3.87298, 155.9051, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(7, "C m", "C m (Unique axis b)", new CLatticeDef(3.46410, 3.87298, 1.73205, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C c
setSettingData(8, "C c", "C c (Unique axis b)", new CLatticeDef(4.24264, 3.46410, 1.73205, 90, 114.0948, 90, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "A n (Unique axis b)", new CLatticeDef(3.87298, 3.46410, 4.24264, 90, 155.9051, 90, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "I a (Unique axis b)", new CLatticeDef(1.73205, 3.46410, 3.87298, 90, 90, 90, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "A a (Unique axis c)", new CLatticeDef(1.73205, 4.24264, 3.46410, 90, 90, 114.0948,0,0,0,0,0,0), false);
setSettingData(8, "C c", "B n (Unique axis c)", new CLatticeDef(4.24264, 3.87297, 90,90,155.9051,0,0,0,0,0,0), false);
setSettingData(8, "C c", "I b (Unique axis c)", new CLatticeDef(3.87298, 1.73205, 3.46410, 90,90,90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "B b (Unique axis a)", new CLatticeDef(3.46410, 1.73205, 2.42464, 114.0948, 90,90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "C n (Unique axis a)", new CLatticeDef(3.46410, 4.24264, 3.87298, 155.9051, 90, 90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "I c (Unique axis a)", new CLatticeDef(3.46410, 3.87298, 1.73205, 90,90,90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "A a (Unique axis b)", new CLatticeDef(1.73205, 3.46410, 4.24264, 90, 114.0948, 90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "C n (Unique axis b)", new CLatticeDef(4.24264, 3.46410, 3.87298, 90, 155.9051, 90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "I c (Unique axis b)", new CLatticeDef(3.87298, 3.46410, 1.73205, 90,90,90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "B b (Unique axis c)", new CLatticeDef(4.24264, 1.73205, 3.46410, 90, 90, 114.0948, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "A n (Unique axis c)", new CLatticeDef(3.87298, 4.24264, 3.46410, 90, 90, 155.9051, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "I a (Unique axis c)", new CLatticeDef(1.73205, 3.87298, 3.46410, 90,90,90,0,0,0,0,0,0), false);
setSettingData(8, "C c", "C c (Unique axis a)", new CLatticeDef(3.46410, 4.24264, 1.73205, 114.0948, 90, 90, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "B n (Unique axis a)", new CLatticeDef(3.46410, 3.87298, 4.24264, 155.9051, 90,90, 0,0,0,0,0,0), false);
setSettingData(8, "C c", "I b (Unique axis a)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 2/m
setSettingData(9, "P 2/m", "P 2/m (Unique axis b)", new CLatticeDef(3.87298, 3.46410, 1.73205, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(9, "P 2/m", "P 2/m (Unique axis c)", new CLatticeDef(3.87298, 1.73205, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(9, "P 2/m", "P 2/m (Unique axis a)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21/m
setSettingData(10, "P 21/m", "P 21/m (Unique axis b)", new CLatticeDef(3.87298, 3.46410, 1.73205, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(10, "P 21/m", "P 21/m (Unique axis c)", new CLatticeDef(1.73205, 3.87298, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(10, "P 21/m", "P 21/m (Unique axis a)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C 2/m
setSettingData(11, "C 2/m", "C 2/m (Unique axis b)", new CLatticeDef(5.19615, 1.73205, 3.46410, 90, 131.8103, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "A 2/m (Unique axis b)", new CLatticeDef(3.87298, 1.73205, 5.19615, 90, 138.1897, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "I 2/m (Unique axis b)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "A 2/m (Unique axis c)", new CLatticeDef(3.46410, 5.19615, 1.73205, 90, 90, 131.8103, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "B 2/m (Unique axis c)", new CLatticeDef(5.19615, 3.87298, 1.73205, 90, 90, 138.1897, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "I 2/m (Unique axis c)", new CLatticeDef(3.87298, 3.46410, 1.73205, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "B 2/m (Unique axis a)", new CLatticeDef(1.73205, 3.46410, 5.19615, 131.8103, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "C 2/m (Unique axis a)", new CLatticeDef(1.73205, 5.19615, 3.87298, 138.1897, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(11, "C 2/m", "I 2/m (Unique axis a)", new CLatticeDef(1.73205, 3.87298, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 2/c
setSettingData(12, "P 2/c", "P 2/c (Unique axis b)", new CLatticeDef(5.19615, 1.73205, 3.46410, 90, 131.8103, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/n (Unique axis b)", new CLatticeDef(3.87298, 1.73205, 5.19615, 90, 138.1897, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/a (Unique axis b)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/a (Unique axis c)", new CLatticeDef(3.46410, 1.73205, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/n (Unique axis c)", new CLatticeDef(1.73205, 3.87298, 3.87298, 90, 90, 116.5650, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/b (Unique axis c)", new CLatticeDef(3.87298, 3.46410, 3.87298, 90, 90, 153.4349, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/b (Unique axis a)", new CLatticeDef(3.87298, 3.46410, 3.87298, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/n (Unique axis a)", new CLatticeDef(3.87298, 3.87298, 5.19615, 138.1897, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(12, "P 2/c", "P 2/c (Unique axis a)", new CLatticeDef(3.87298, 5.19615, 3.46410, 131.8103, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21/c
setSettingData(13, "P 21/c", "P 21/c (Unique axis b)", new CLatticeDef(3.87298, 5.19615, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/n (Unique axis b)", new CLatticeDef(5.19615, 5.19615, 3.87298, 90, 138.1897, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/a (Unique axis b)", new CLatticeDef(3.46410, 5.19615, 5.19615, 90, 131.8103, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/a (Unique axis c)", new CLatticeDef(3.46410, 5.19615, 5.19615, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/n (Unique axis c)", new CLatticeDef(5.19615, 6.24499, 5.19615, 90, 90, 146.3099, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/b (Unique axis c)", new CLatticeDef(6.24499, 3.46410, 5.19615, 90, 90, 123.6900, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/b (Unique axis a)", new CLatticeDef(6.24499, 3.46410, 5.19615, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/n (Unique axis a)", new CLatticeDef(6.24499, 5.19615, 6.24499, 146.3099, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(13, "P 21/c", "P 21/c (Unique axis a)", new CLatticeDef(6.24499, 6.24499, 3.46410, 123.6900, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C 2/c
setSettingData(14, "C 2/c", "C 2/c (Unique axis b)", new CLatticeDef(6.24499, 6.24499, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "A 2/n (Unique axis b)", new CLatticeDef(7.14142, 6.24499, 6.24499, 90, 150.9828, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/a (Unique axis b)", new CLatticeDef(3.46410, 6.24499, 7.14142, 90, 119.0172, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "A 2/a (Unique axis c)", new CLatticeDef(3.46410, 6.24499, 6.24499, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "B 2/n (Unique axis c)", new CLatticeDef(6.24499, 7.14142, 7.14142, 90, 90, 150.9828, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/b (Unique axis c)", new CLatticeDef(7.14142, 3.46410, 7.14142, 90, 90, 119.0171, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "B 2/b (Unique axis a)", new CLatticeDef(7.14142, 3.46410, 7.14142, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "C 2/n (Unique axis a)", new CLatticeDef(7.14142, 7.14142, 7.93725, 115.8767, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/c (Unique axis a)", new CLatticeDef(7.14142, 7.93725, 3.46410, 154.1233, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "A 2/a (Unique axis b)", new CLatticeDef(7.14142, 7.93725, 3.46410, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "C 2/n (Unique axis b)", new CLatticeDef(3.46410, 7.93725, 7.93724, 90, 115.8767, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/c (Unique axis b)", new CLatticeDef(7.93724, 7.93725, 7.14142, 90, 154.1233, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "B 2/b (Unique axis c)", new CLatticeDef(7.93724, 7.93725, 7.14142, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "A 2/n (Unique axis c)", new CLatticeDef(11.22496, 7.93724, 7.14142, 90, 90, 135, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/a (Unique axis c)", new CLatticeDef(7.93725, 11.22496, 7.14142, 90, 90, 135, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "C 2/c (Unique axis a)", new CLatticeDef(7.93725, 11.22496, 7.14142, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "B 2/n (Unique axis a)", new CLatticeDef(7.93725, 13.30412, 11.22496, 147.5351, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(14, "C 2/c", "I 2/b (Unique axis a)", new CLatticeDef(7.93725, 7.14142, 13.30412, 122.4649, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 2 2 2
setSettingData(15, "P 2 2 2", "P 2 2 2 (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(15, "P 2 2 2", "P 2 2 2 (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(15, "P 2 2 2", "P 2 2 2 (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(15, "P 2 2 2", "P 2 2 2 (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(15, "P 2 2 2", "P 2 2 2 (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(15, "P 2 2 2", "P 2 2 2 (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 2 2 21
setSettingData(16, "P 2 2 21", "P 2 2 21 (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(16, "P 2 2 21", "P 2 2 21 (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(16, "P 2 2 21", "P 2 2 21 (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(16, "P 2 2 21", "P 2 2 21 (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(16, "P 2 2 21", "P 2 2 21 (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(16, "P 2 2 21", "P 2 2 21 (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21 21 2
setSettingData(17, "P 21 21 2", "P 21 21 2 (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(17, "P 21 21 2", "P 21 21 2 (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(17, "P 21 21 2", "P 21 21 2 (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(17, "P 21 21 2", "P 21 21 2 (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(17, "P 21 21 2", "P 21 21 2 (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(17, "P 21 21 2", "P 21 21 2 (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21 21 21
setSettingData(18, "P 21 21 21", "P 21 21 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(18, "P 21 21 21", "P 21 21 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(18, "P 21 21 21", "P 21 21 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(18, "P 21 21 21", "P 21 21 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(18, "P 21 21 21", "P 21 21 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(18, "P 21 21 21", "P 21 21 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C 2 2 21
setSettingData(19, "C 2 2 21", "C 2 2 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(19, "C 2 2 21", "C 2 2 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(19, "C 2 2 21", "C 2 2 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(19, "C 2 2 21", "C 2 2 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(19, "C 2 2 21", "C 2 2 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(19, "C 2 2 21", "C 2 2 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C 2 2 2
setSettingData(20, "C 2 2 2", "C 2 2 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(20, "C 2 2 2", "C 2 2 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(20, "C 2 2 2", "C 2 2 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(20, "C 2 2 2", "C 2 2 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(20, "C 2 2 2", "C 2 2 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(20, "C 2 2 2", "C 2 2 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F 2 2 2
setSettingData(21, "F 2 2 2", "F 2 2 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(21, "F 2 2 2", "F 2 2 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(21, "F 2 2 2", "F 2 2 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(21, "F 2 2 2", "F 2 2 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(21, "F 2 2 2", "F 2 2 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(21, "F 2 2 2", "F 2 2 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 2 2 2
setSettingData(22, "I 2 2 2", "I 2 2 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(22, "I 2 2 2", "I 2 2 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(22, "I 2 2 2", "I 2 2 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(22, "I 2 2 2", "I 2 2 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(22, "I 2 2 2", "I 2 2 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(22, "I 2 2 2", "I 2 2 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 21 21 21
setSettingData(23, "I 21 21 21", "I 21 21 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(23, "I 21 21 21", "I 21 21 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(23, "I 21 21 21", "I 21 21 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(23, "I 21 21 21", "I 21 21 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(23, "I 21 21 21", "I 21 21 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(23, "I 21 21 21", "I 21 21 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m m 2
setSettingData(24, "P m m 2", "P m m 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(24, "P m m 2", "P m m 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(24, "P m m 2", "P m m 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(24, "P m m 2", "P m m 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(24, "P m m 2", "P m m 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(24, "P m m 2", "P m m 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m c 21
setSettingData(25, "P m c 21", "P m c 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(25, "P m c 21", "P m c 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(25, "P m c 21", "P m c 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(25, "P m c 21", "P m c 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(25, "P m c 21", "P m c 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(25, "P m c 21", "P m c 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c c 2
setSettingData(26, "P c c 2", "P c c 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(26, "P c c 2", "P c c 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(26, "P c c 2", "P c c 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(26, "P c c 2", "P c c 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(26, "P c c 2", "P c c 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(26, "P c c 2", "P c c 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m a 2
setSettingData(27, "P m a 2", "P m a 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(27, "P m a 2", "P m a 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(27, "P m a 2", "P m a 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(27, "P m a 2", "P m a 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(27, "P m a 2", "P m a 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(27, "P m a 2", "P m a 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c a 21
setSettingData(28, "P c a 21", "P c a 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(28, "P c a 21", "P c a 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(28, "P c a 21", "P c a 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(28, "P c a 21", "P c a 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(28, "P c a 21", "P c a 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(28, "P c a 21", "P c a 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n c 2
setSettingData(29, "P n c 2", "P n c 2 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(29, "P n c 2", "P n c 2 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(29, "P n c 2", "P n c 2 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(29, "P n c 2", "P n c 2 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(29, "P n c 2", "P n c 2 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(29, "P n c 2", "P n c 2 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m n 21
setSettingData(30, "P m n 21", "P m n 21 (a,b,c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(30, "P m n 21", "P m n 21 (b,a,-c)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(30, "P m n 21", "P m n 21 (c,a,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(30, "P m n 21", "P m n 21 (-c,b,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(30, "P m n 21", "P m n 21 (b,c,a)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(30, "P m n 21", "P m n 21 (a,-c,b)", new CLatticeDef(1,1,1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P b a 2
setSettingData(31, "P b a 2", "P b a 2 (a,b,c)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(31, "P b a 2", "P b a 2 (b,a,-c)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(31, "P b a 2", "P b a 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(31, "P b a 2", "P b a 2 (-c,b,a)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(31, "P b a 2", "P b a 2 (b,c,a)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(31, "P b a 2", "P b a 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n a 21
setSettingData(32, "P n a 21", "P n a 21 (a,b,c)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(32, "P n a 21", "P n a 21 (b,a,-c)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(32, "P n a 21", "P n a 21 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(32, "P n a 21", "P n a 21 (-c,b,a)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(32, "P n a 21", "P n a 21 (b,c,a)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(32, "P n a 21", "P n a 21 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n n 2
setSettingData(33, "P n n 2", "P n n 2 (a,b,c)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(33, "P n n 2", "P n n 2 (b,a,-c)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(33, "P n n 2", "P n n 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(33, "P n n 2", "P n n 2 (-c,b,a)", new CLatticeDef(1.41421, 1, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(33, "P n n 2", "P n n 2 (b,c,a)", new CLatticeDef(1, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(33, "P n n 2", "P n n 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m m 2
setSettingData(34, "C m m 2", "C m m 2 (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(34, "C m m 2", "C m m 2 (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(34, "C m m 2", "A 2 m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(34, "C m m 2", "A 2 m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(34, "C m m 2", "B m 2 m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(34, "C m m 2", "B m 2 m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m c 21
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(35, "C m c 21", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C c c 2
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(36, "C c c 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// A m m 2
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(37, "A m m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// A e m 2
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(38, "A e m 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// A m a 2
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(39, "A m a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// A e a 2
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(40, "A e a 2", " ()", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F m m 2
setSettingData(41, "F m m 2", "F m m 2 (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(41, "F m m 2", "F m m 2 (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(41, "F m m 2", "F m m 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(41, "F m m 2", "F m m 2 (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(41, "F m m 2", "F m m 2 (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(41, "F m m 2", "F m m 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F d d 2
setSettingData(42, "F d d 2", "F d d 2 (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(42, "F d d 2", "F d d 2 (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(42, "F d d 2", "F d d 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(42, "F d d 2", "F d d 2 (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(42, "F d d 2", "F d d 2 (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(42, "F d d 2", "F d d 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m m 2
setSettingData(43, "I m m 2", "I m m 2 (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(43, "I m m 2", "I m m 2 (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(43, "I m m 2", "I m m 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(43, "I m m 2", "I m m 2 (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(43, "I m m 2", "I m m 2 (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(43, "I m m 2", "I m m 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I b a 2
setSettingData(44, "I b a 2", "I b a 2 (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(44, "I b a 2", "I b a 2 (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(44, "I b a 2", "I b a 2 (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(44, "I b a 2", "I b a 2 (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(44, "I b a 2", "I b a 2 (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(44, "I b a 2", "I b a 2 (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m a 2
setSettingData(45, "I m a 2", "I m a 2 (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(45, "I m a 2", "I b m 2 (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(45, "I m a 2", "I 2 m b (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(45, "I m a 2", "I 2 c m (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(45, "I m a 2", "I c 2 m (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(45, "I m a 2", "I m 2 a (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m m m 
setSettingData(46, "P m m m", "P m m m (a,b,c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(46, "P m m m", "P m m m (b,a,-c)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(46, "P m m m", "P m m m (c,a,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(46, "P m m m", "P m m m (-c,b,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(46, "P m m m", "P m m m (b,c,a)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(46, "P m m m", "P m m m (a,-c,b)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n n n
setSettingData(47, "P n n n", "P n n n (a,b,c) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (a,b,c) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (b,a,-c) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (b,a,-c) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (c,a,b) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (c,a,b) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (-c,b,a) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (-c,b,a) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (b,c,a) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (b,c,a) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (a,-c,b) (Origin choice 1)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(47, "P n n n", "P n n n (a,-c,b) (Origin choice 2)", new CLatticeDef(1.41421, 1.41421, 1.41421, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c c m
setSettingData(48, "P c c m", "P c c m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(48, "P c c m", "P c c m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(48, "P c c m", "P c c m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(48, "P c c m", "P c c m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(48, "P c c m", "P c c m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(48, "P c c m", "P c c m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P b a n
setSettingData(49, "P b a n", "P b a n (a,b,c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P b a n (a,b,c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P b a n (b,a,-c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P b a n (b,a,-c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P n c b (c,a,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P n c b (c,a,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P n c b (-c,b,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P n c b (-c,b,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P c n a (b,c,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P c n a (b,c,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P c n a (a,-c,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(49, "P b a n", "P c n a (a,-c,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m m a
setSettingData(50, "P m m a", "P m m a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(50, "P m m a", "P m m b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(50, "P m m a", "P b m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(50, "P m m a", "P c m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(50, "P m m a", "P m c m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(50, "P m m a", "P m a m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n n a
setSettingData(51, "P n n a", "P n n a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(51, "P n n a", "P n n b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(51, "P n n a", "P b n n (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(51, "P n n a", "P c n n (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(51, "P n n a", "P n c n (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(51, "P n n a", "P n a n (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m n a
setSettingData(52, "P m n a", "P m n a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(52, "P m n a", "P n m b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(52, "P m n a", "P b m n (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(52, "P m n a", "P c n m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(52, "P m n a", "P n c m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(52, "P m n a", "P m a n (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c c a
setSettingData(53, "P c c a", "P c c a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(53, "P c c a", "P c c b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(53, "P c c a", "P b a a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(53, "P c c a", "P c a a (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(53, "P c c a", "P b c b (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(53, "P c c a", "P b a b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P b a m
setSettingData(54, "P b a m", "P b a m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(54, "P b a m", "P b a m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(54, "P b a m", "P m c b (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(54, "P b a m", "P m c b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(54, "P b a m", "P c m a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(54, "P b a m", "P c m a (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P c c n
setSettingData(55, "P c c n", "P c c n (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(55, "P c c n", "P c c n (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(55, "P c c n", "P n a a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(55, "P c c n", "P n a a (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(55, "P c c n", "P b n b (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(55, "P c c n", "P b n b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P b c m
setSettingData(56, "P b c m", "P b c m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(56, "P b c m", "P c a m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(56, "P b c m", "P m c a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(56, "P b c m", "P m a b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(56, "P b c m", "P b m a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(56, "P b c m", "P c m b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n n m
setSettingData(57, "P n n m", "P n n m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(57, "P n n m", "P n n m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(57, "P n n m", "P m n n (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(57, "P n n m", "P m n n (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(57, "P n n m", "P n m n (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(57, "P n n m", "P n m n (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m m n
setSettingData(58, "P m m n", "P m m n (a,b,c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (a,b,c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (b,a,-c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (b,a,-c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (c,a,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (c,a,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (-c,b,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (-c,b,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (b,c,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (b,c,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (a,-c,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(58, "P m m n", "P m m n (a,-c,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P b c n
setSettingData(59, "P b c n", "P b c n (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(59, "P b c n", "P c a n (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(59, "P b c n", "P n c a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(59, "P b c n", "P n a b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(59, "P b c n", "P b n a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(59, "P b c n", "P c n b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);


// P b c a
setSettingData(60, "P b c a", "P b c a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(60, "P b c a", "P c a b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(60, "P b c a", "P b c a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(60, "P b c a", "P c a b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(60, "P b c a", "P b c a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(60, "P b c a", "P c a b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n m a
setSettingData(61, "P n m a", "P n m a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(61, "P n m a", "P m n b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(61, "P n m a", "P b n m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(61, "P n m a", "P c m n (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(61, "P n m a", "P m c n (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(61, "P n m a", "P n a m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m c m
setSettingData(62, "C m c m", "C m c m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(62, "C m c m", "C c m m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(62, "C m c m", "A m m a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(62, "C m c m", "A m a m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(62, "C m c m", "B b m m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(62, "C m c m", "B m m b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m c e
setSettingData(63, "C m c e", "C m c e (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(63, "C m c e", "C c m e (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(63, "C m c e", "A e m a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(63, "C m c e", "A e a m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(63, "C m c e", "B b e m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(63, "C m c e", "B m e b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m m m
setSettingData(64, "C m m m", "C m m m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(64, "C m m m", "C m m m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(64, "C m m m", "A m m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(64, "C m m m", "A m m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(64, "C m m m", "B m m m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(64, "C m m m", "B m m m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C c c m
setSettingData(65, " C c c m", "C c c m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(65, " C c c m", "C c c m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(65, " C c c m", "A m a a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(65, " C c c m", "A m a a (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(65, " C c c m", "B b m b (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(65, " C c c m", "B b m b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C m m e
setSettingData(66, "C m m e", "C m m e (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(66, "C m m e", "C m m e (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(66, "C m m e", "A e m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(66, "C m m e", "A e m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(66, "C m m e", "B m e m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(66, "C m m e", "B m e m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// C c c e
setSettingData(67, "C c c e", "C c c e (a,b,c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "C c c e (a,b,c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "C c c e (b,a,-c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "C c c e (b,a,-c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "A e a a (c,a,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "A e a a (c,a,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "A e a a (-c,b,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "A e a a (-c,b,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "B b e b (b,c,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "B b e b (b,c,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "B b e b (a,-c,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(67, "C c c e", "B b e b (a,-c,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F m m m
setSettingData(68, "F m m m", "F m m m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(68, "F m m m", "F m m m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(68, "F m m m", "F m m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(68, "F m m m", "F m m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(68, "F m m m", "F m m m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(68, "F m m m", "F m m m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F d d d
setSettingData(69, "F d d d", "F d d d (a,b,c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (a,b,c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (b,a,-c) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (b,a,-c) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (c,a,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (c,a,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (-c,b,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (-c,b,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (b,c,a) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (b,c,a) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (a,-c,b) (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(69, "F d d d", "F d d d (a,-c,b) (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m m m
setSettingData(70, "I m m m", "I m m m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(70, "I m m m", "I m m m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(70, "I m m m", "I m m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(70, "I m m m", "I m m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(70, "I m m m", "I m m m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(70, "I m m m", "I m m m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I b a m
setSettingData(71, "I b a m", "I b a m (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(71, "I b a m", "I b a m (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(71, "I b a m", "I m c b (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(71, "I b a m", "I m c b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(71, "I b a m", "I c m a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(71, "I b a m", "I c m a (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I b c a
setSettingData(72, "I b c a", "I b c a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(72, "I b c a", "I c a b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(72, "I b c a", "I b c a (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(72, "I b c a", "I c a b (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(72, "I b c a", "I b c a (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(72, "I b c a", "I c a b (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m m a
setSettingData(73, "I m m a", "I m m a (a,b,c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(73, "I m m a", "I m m b (b,a,-c)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(73, "I m m a", "I b m m (c,a,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(73, "I m m a", "I c m m (-c,b,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(73, "I m m a", "I m c m (b,c,a)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(73, "I m m a", "I m a m (a,-c,b)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4
setSettingData(74, "P 4", "P 4", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 41
setSettingData(75, "P 41", "P 41", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42
setSettingData(76, "P 42", "P 42", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 43
setSettingData(77, "P 43", "P 43", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4
setSettingData(78, "I 4", "I 4", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41
setSettingData(79, "I 41", "I 41", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4
setSettingData(80, "P -4", "P -4", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4
setSettingData(81, "I -4", "I -4", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/m
setSettingData(82, "P 4/m", "P 4/m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/m
setSettingData(83, "P 42/m", "P 42/m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/n
setSettingData(84, "P 4/n", "P 4/n (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(84, "P 4/n", "P 4/n (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/n
setSettingData(85, "P 42/n", "P 42/n (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(85, "P 42/n", "P 42/n (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4/m
setSettingData(86, "I 4/m", "I 4/m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41/a
setSettingData(87, "I 41/a", "I 41/a (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(87, "I 41/a", "I 41/a (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 2 2
setSettingData(88, "P 4 2 2", "P 4 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 21 2
setSettingData(89, "P 4 21 2", "P 4 21 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 41 2 2
setSettingData(90, "P 41 2 2", "P 41 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 41 21 2
setSettingData(91, "P 41 21 2", "P 41 21 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 2 2
setSettingData(92, "P 42 2 2", "P 42 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 21 2
setSettingData(93, "P 42 21 2", "P 42 21 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 43 2 2
setSettingData(94, "P 43 2 2", "P 43 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 43 21 2
setSettingData(95, "P 43 21 2", "P 43 21 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4 2 2
setSettingData(96, "I 4 2 2", "I 4 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41 2 2
setSettingData(97, "I 41 2 2", "I 41 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 m m 
setSettingData(98, "P 4 m m", "P 4 m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 b m
setSettingData(99, "P 4 b m", "P 4 b m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 c m
setSettingData(100, "P 42 c m", "P 42 c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 n m
setSettingData(101, "P 42 n m", "P 42 n m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 c c
setSettingData(102, " P 4 c c", "P 4 c c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 n c
setSettingData(103, "P 4 n c", "P 4 n c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 m c
setSettingData(104, "P 42 m c", "P 42 m c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 b c
setSettingData(105, "P 42 b c", "P 42 b c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4 m m
setSettingData(106, "I 4 m m", "I 4 m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4 c m
setSettingData(107, "I 4 c m", "I 4 c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41 m d
setSettingData(108, "I 41 m d", "I 41 m d", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41 c d
setSettingData(109, "I 41 c d", "I 41 c d", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 2 m
setSettingData(110, "P -4 2 m", "P -4 2 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 2 c
setSettingData(111, "P -4 2 c", "P -4 2 c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 21 m
setSettingData(112, "P -4 21 m", "P -4 21 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 21 c
setSettingData(113, "P -4 21 c", "P -4 21 c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 m 2
setSettingData(114, "P -4 m 2", "P -4 m 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 c 2
setSettingData(115, "P -4 c 2", "P -4 c 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 b 2
setSettingData(116, "P -4 b 2", "P -4 b 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 n 2
setSettingData(117, "P -4 n 2", "P -4 n 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 m 2
setSettingData(118, "I -4 m 2", "I -4 m 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 c 2
setSettingData(119, "I -4 c 2", "I -4 c 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 2 m
setSettingData(120, "I -4 2 m", "I -4 2 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 2 d
setSettingData(121, "I -4 2 d", "I -4 2 d", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/m m m
setSettingData(122, "P 4/m m m", "P 4/m m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/m c c
setSettingData(123, "P 4/m c c", "P 4/m c c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/n b m
setSettingData(124, "P 4/n b m", "P 4/n b m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(124, "P 4/n b m", "P 4/n b m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/n n c
setSettingData(125, "P 4/n n c", "P 4/n n c (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(125, "P 4/n n c", "P 4/n n c (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/m b m
setSettingData(126, "P 4/m b m", "P 4/m b m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/m n c
setSettingData(127, "P 4/m n c", "P 4/m n c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/n m m
setSettingData(128, "P 4/n m m", "P 4/n m m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(128, "P 4/n m m", "P 4/n m m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4/n c c
setSettingData(129, "P 4/n c c", "P 4/n c c (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(129, "P 4/n c c", "P 4/n c c (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/m m c
setSettingData(130, "P 42/m m c", "P 42/m m c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/m c m
setSettingData(131, "P 42/m c m", "P 42/m c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/n b c
setSettingData(132, "P 42/n b c", "P 42/n b c (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(132, "P 42/n b c", "P 42/n b c (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/n n m
setSettingData(133, "P 42/n n m", "P 42/n n m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(133, "P 42/n n m", "P 42/n n m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/m b c
setSettingData(134, "P 42/m b c", "P 42/m b c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/m n m
setSettingData(135, "P 42/m n m", "P 42/m n m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/n m c
setSettingData(136, "P 42/n m c", "P 42/n m c (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(136, "P 42/n m c", "P 42/n m c (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42/n c m
setSettingData(137, "P 42/n c m", "P 42/n c m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(137, "P 42/n c m", "P 42/n c m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4/m m m
setSettingData(138, "I 4/m m m", "I 4/m m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4/m c m
setSettingData(139, "I 4/m c m", "I 4/m c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41/a m d
setSettingData(140, "I 41/a m d", "I 41/a m d (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(140, "I 41/a m d", "I 41/a m d (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41/a c d
setSettingData(141, "I 41/a c d", "I 41/a c d (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(141, "I 41/a c d", "I 41/a c d (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3
setSettingData(142, "P 3", "P 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 31
setSettingData(143, "P 31", "P 31", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 32
setSettingData(144, "P 32", "P 32", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// R 3
setSettingData(145, "R 3", "R 3 (Hexagonal axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(145, "R 3", "R 3 (Rhombohedral axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -3
setSettingData(146, "P -3", "P -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// R -3
setSettingData(147, "R -3", "R -3 (Hexagonal axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(147, "R -3", "R -3 (Rhombohedral axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3 1 2
setSettingData(148, "P 3 1 2", "P 3 1 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3 2 1
setSettingData(149, "P 3 2 1", "P 3 2 1", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 31 1 2
setSettingData(150, "P 31 1 2", "P 31 1 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 31 2 1
setSettingData(151, "P 31 2 1", "P 31 2 1", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 32 1 2
setSettingData(152, "P 32 1 2", "P 32 1 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 32 2 1
setSettingData(153, "P 32 2 1", "P 32 2 1", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// R 3 2
setSettingData(154, "R 3 2", "R 3 2 (Hexagonal axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(154, "R 3 2", "R 3 2 (Rhombohedral axes)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3 m 1
setSettingData(155, "P 3 m 1", "P 3 m 1", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3 1 m
setSettingData(156, "P 3 1 m", "P 3 1 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 3 c 1
setSettingData(157, "P 3 c 1", "P 3 c 1", new CLatticeDef(0.44445, 0.44445, 0.44445, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// P 3 1 c
setSettingData(158, "P 3 1 c", "P 3 1 c", new CLatticeDef(0.44445, 0.44445, 0.44445, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// R 3 m
setSettingData(159, "R 3 m", "R 3 m (Hexagonal axes)", new CLatticeDef(0.44445, 0.44445, 0.44445, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);
setSettingData(159, "R 3 m", "R 3 m (Rhombohedral axes)", new CLatticeDef(0.29630, 0.29630, 0.29630, 97.1808, 97.1808, 97.1808, 0, 0, 0, 0, 0, 0), false);

// R 3 c
setSettingData(160, "R 3 c", "R 3 c (Hexagonal axes)", new CLatticeDef(0.44445, 0.44445, 0.44445, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);
setSettingData(160, "R 3 c", "R 3 c (Rhombohedral axes)", new CLatticeDef(0.29630, 0.29630, 0.29630, 97.1808, 97.1808, 97.1808, 0, 0, 0, 0, 0, 0), false);

// P -3 1 m
setSettingData(161, "P -3 1 m", "P -3 1 m", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// P -3 1 c
setSettingData(162, "P -3 1 c", "P -3 1 c", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// P -3 m 1
setSettingData(163, "P -3 m 1", "P -3 m 1", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// P -3 c 1
setSettingData(164, "P -3 c 1", "P -3 c 1", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);

// R -3 m
setSettingData(165, " R -3 m", "R -3 m (Hexagonal axes)", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);
setSettingData(165, " R -3 m", "R -3 m (Rhombonhedral axes)", new CLatticeDef(0.66667, 0.66667, 0.66667, 97.1808, 97.1808, 97.1808, 0, 0, 0, 0, 0, 0), false);

// R -3 c
setSettingData(166, "R -3 c", "R -3 c (Hexagonal axes)", new CLatticeDef(0.66667, 0.66667, 0.66667, 90, 90, 120, 0, 0, 0, 0, 0, 0), false);
setSettingData(166, "R -3 c", "R -3 c (Rhombohedral axes)", new CLatticeDef(0.66667, 0.66667, 0.66667, 97.1808, 97.1808, 97.1808, 0, 0, 0, 0, 0, 0), false);


// P 6
setSettingData(167, "P 6", "P 6", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 61
setSettingData(168, "P 61", "P 61", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);


// P 65
setSettingData(169, "P 65", "P 65", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 62
setSettingData(170, "P 62", "P 62", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 64
setSettingData(171, "P 64", "P 64", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63
setSettingData(172, "P 63", "P 63", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -6
setSettingData(173, "P -6", "P -6", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6/m
setSettingData(174, "P 6/m", "P 6/m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63/m
setSettingData(175, "P 63/m", "P 63/m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6 2 2
setSettingData(176, "P 6 2 2", "P 6 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 61 2 2
setSettingData(177, "P 61 2 2", "P 61 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 65 2 2
setSettingData(178, "P 65 2 2", "P 65 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 62 2 2
setSettingData(179, "P 62 2 2", "P 62 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 64 2 2
setSettingData(180, "P 64 2 2", "P 64 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63 2 2
setSettingData(181, "P 63 2 2", "P 63 2 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6 m m
setSettingData(182, "P 6 m m", "P 6 m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6 c c
setSettingData(183, "P 6 c c", "P 6 c c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63 c m
setSettingData(184, "P 63 c m", "P 63 c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63 m c
setSettingData(185, "P 63 m c", "P 63 m c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -6 m 2
setSettingData(186, "P -6 m 2", "P -6 m 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -6 c 2
setSettingData(187, "P -6 c 2", "P -6 c 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -6 2 m
setSettingData(188, "P -6 2 m", "P -6 2 m", new CLatticeDef(), false);

// P -6 2 c
setSettingData(189, "P -6 2 c", "P -6 2 c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6/m m m
setSettingData(190, "P 6/m m m", "P 6/m m m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 6/m c c
setSettingData(191, "P 6/m c c", "P 6/m c c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63/m c m
setSettingData(192, "P 63/m c m", "P 63/m c m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 63/m m c
setSettingData(193, "P 63/m m c", "P 63/m m c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);


// P 2 3
setSettingData(194, "P 2 3", "P 2 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F 2 3
setSettingData(195, "F 2 3", "F 2 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);


// I 2 3
setSettingData(196, "I 2 3", "I 2 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 21 3
setSettingData(197, "P 21 3", "P 21 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 21 3
setSettingData(198, "I 21 3", "I 21 3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m -3
setSettingData(199, "P m -3", "P m -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n -3
setSettingData(200, "P n -3", "P n -3 (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(200, "P n -3", "P n -3 (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F m -3
setSettingData(201, "F m -3", "F m -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F d -3 
setSettingData(202, "F d -3 ", "F d -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m -3
setSettingData(203, "I m -3", "I m -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P a -3
setSettingData(204, "P a -3", "P a -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I a -3
setSettingData(205, "I a -3", "I a -3", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 4 3 2
setSettingData(206, "P 4 3 2", "P 4 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 42 3 2
setSettingData(207, "P 42 3 2", "P 42 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F 4 3 2
setSettingData(208, "F 4 3 2", "F 4 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F 41 3 2
setSettingData(209, "F 41 3 2", "F 41 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 4 3 2
setSettingData(210, "I 4 3 2", "I 4 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 43 3 2
setSettingData(211, " P 43 3 2", "P 43 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P 41 3 2
setSettingData(212, "P 41 3 2", "P 41 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I 41 3 2
setSettingData(213, "I 41 3 2", "I 41 3 2", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 3 m
setSettingData(214, "P -4 3 m", "P -4 3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F -4 3 m
setSettingData(215, "F -4 3 m", "F -4 3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 3 m
setSettingData(216, "I -4 3 m", "I -4 3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P -4 3 n
setSettingData(217, "P -4 3 n", "P -4 3 n", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F -4 3 c
setSettingData(218, "F -4 3 c", "F -4 3 c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I -4 3 d
setSettingData(219, "I -4 3 d", "I -4 3 d", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m -3 m
setSettingData(220, "P m -3 m", "P m -3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n -3 n
setSettingData(221, "P n -3 n", "P n -3 n (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(221, "P n -3 n", "P n -3 n (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P m -3 n
setSettingData(222, "P m -3 n", "P m -3 n", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// P n -3 m
setSettingData(223, "P n -3 m", "P n -3 m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(223, "P n -3 m", "P n -3 m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F m -3 m
setSettingData(224, "F m -3 m", "F m -3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F m -3 c
setSettingData(225, "F m -3 c", "F m -3 c", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F d -3 m
setSettingData(226, "F d -3 m", "F d -3 m (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(226, "F d -3 m", "F d -3 m (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// F d -3 c
setSettingData(227, "F d -3 c", "F d -3 c (Origin choice 1)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
setSettingData(227, "F d -3 c", "F d -3 c (Origin choice 2)", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I m -3 m
setSettingData(228, "I m -3 m", "I m -3 m", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);

// I a -3 d
setSettingData(229, "I a -3 d", "I a -3 d", new CLatticeDef(1, 1, 1, 90, 90, 90, 0, 0, 0, 0, 0, 0), false);
*/
;// CONCATENATED MODULE: ./CrystalEditor/crystalTable.js
/**
 * 테이블 생성 클래스
 * */
class crystalTable {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTable이 부착될 HTML Element
   * @param {String} table_id 다른 테이블과 구분하기 위한 이름
   */
  constructor(name, app, div_elem, table_id) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._table_id = table_id;
    this._div.innerHTML = this._appElementHTML(name);
    this._div_table = document.getElementById(this._name + '_table');
    this._div_tbody = document.getElementById(this._name + '_' + this._table_id + "_tbody");
    this._div_header_tbody = document.getElementById(this._name + '_' + this._table_id + '_header');
    crystalTable.I = this;
  }

  /**
   * Table에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<table id='" + name + "_" + this._table_id + "_header_table'>";
    idx++;
    ihtml[idx] = "<tbody id='" + name + "_" + this._table_id + "_header'>";
    idx++;
    ihtml[idx] = "</tbody>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "<table id='" + name + "_table'>";
    idx++;
    ihtml[idx] = "<tbody id='" + name + "_" + this._table_id + "_tbody'>";
    idx++;
    ihtml[idx] = "</tbody>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * sort 기능 적용
   * */
  applySortable() {
    let id = this._name + "_" + this._table_id + "_tbody";
    $("#" + id)
    /*
    .sortable({
        handle: ".handle",
        update: function (event, ui) {
            let idx = 1;
            $("#" + id + " .position").each(function (e) {
                $(this).text(idx.toString());
                idx++;
            });
        }
    })
    */.selectable({
      filter: "tr",
      cancel: ".handle",
      selected: function (event, ui) {
        // 현재 활성화된 다이얼로그 판별
        /*
        if (crystalTable.I._app._dlgEditData._show)
            crystalTable.I._app._dlgEditData.UpdateSelect();
        else if (crystalTable.I._app._dlgEditBond._show)
            crystalTable.I._app._dlgEditBond.UpdateSelect();
        */
      }
    });
    $("#" + id + " tr").last().addClass("ui-corner-all").prepend("<div class='handle'><span class='ui-icon ui-icon-carat-2-n-s'></span></div>");
  }

  /**
   * 선택 기능 적용
   * @param {Function} cb callback function
   */
  applySelectable(cb) {
    let id = this._name + "_" + this._table_id + "_tbody";
    $("#" + id).selectable({
      filter: "tr",
      cancel: ".handle",
      selected: function (event, ui) {
        cb();
      }
    });
  }

  /**
   * 테이블 업데이트
   * */
  updateTable() {
    let id = this._name + "_" + this._table_id + "_tbody";
    let idx = 1;
    $("#" + id + " .position").each(function (e) {
      $(this).text(idx.toString());
      idx++;
    });
  }

  /**
   * 테이블 row 추가
   * @param {String} innerHTML 테이블 row html
   * @param {Boolean} hasPosition 순번 포함 여부
   */
  appTable(innerHTML, hasPosition = false) {
    if (hasPosition) {
      $(this._div_tbody).append("<tr class='sortable'><td class='position cryUI_Normal_Td'></td>" + innerHTML + "</tr>");
      this.updateTable();
      this.applySortable();
    } else $(this._div_tbody).append("<tr class='sortable'><td class='position cryUI_Normal_Td' style='display:none;'></td>" + innerHTML + "</tr>");
  }

  /**
   * 테이블 row 추가
   * @param {String} innerHTML table row string
   */
  appInnerHTML(innerHTML) {
    $(this._div_tbody).append(innerHTML);
  }

  /**
   * 테이블 row 선택 초기화
   * */
  initSelect() {
    let selected = this.getSelected();
    let length = selected.length;
    for (let i = 0; i < length; ++i) {
      $(selected[i]).removeClass("ui-selected");
    }
  }

  /**
   * 테이블의 마지막 row 선택
   * */
  selectLast() {
    let allRows = this.getAllRow();
    let lastRow = allRows[allRows.length - 1];
    $(lastRow).addClass("ui-selected");
  }

  /**
   * header 추가
   * @param {String} innerHTML table header string
   * @param {Boolean} bSortable 정렬 가능 여부
   */
  createHeader(innerHTML, bSortable = true) {
    $(this._div_header_tbody).prepend("<tr>" + innerHTML + "</tr>");
    if (bSortable) {
      this.updateTable();
      this.applySortable();
    }
  }

  /**
   * header row 삭제
   * */
  removeHeader() {
    $(this._div_header_tbody).find("tr:first")[0].remove();
  }

  /**
   * 선택된 row 반환
   * */
  getSelected() {
    let selected = $('#' + this._name + '_' + this._table_id + "_tbody" + " tr").filter('.ui-selected');
    return selected;
  }

  /**
   * 모든 row 반환
   * */
  getAllRow() {
    let rows = $("#" + this._name + "_" + this._table_id + "_tbody" + ' .position').parent();
    return rows;
  }

  /**
   * 선택된 row 삭제
   * */
  deleteSelected() {
    let selected = this.getSelected();
    if (selected) selected.remove();
  }

  /**
   * 모든 row 삭제
   * */
  clearAll() {
    let rows = this.getAllRow();
    if (rows) {
      rows.remove();
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalBoundarySettingDialog.js






/**
 * boundary 설정 다이얼로그
 * */
class crystalBoundarySettingDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalBoundarySettingDialog가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    crystalBoundarySettingDialog.I = this;
    this._div.innerHTML = this._appElementHTML(this._name);
    this._bModified = false;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxHeight: 500,
      height: 500,
      maxWidth: 620,
      width: 620,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Boundary",
      buttons: {
        "OK": function () {
          let minX = parseFloat($(crystalBoundarySettingDialog.I._input_min_x).val());
          let minY = parseFloat($(crystalBoundarySettingDialog.I._input_min_y).val());
          let minZ = parseFloat($(crystalBoundarySettingDialog.I._input_min_z).val());
          let maxX = parseFloat($(crystalBoundarySettingDialog.I._input_max_x).val());
          let maxY = parseFloat($(crystalBoundarySettingDialog.I._input_max_y).val());
          let maxZ = parseFloat($(crystalBoundarySettingDialog.I._input_max_z).val());
          let boundary = crystalBoundarySettingDialog.I._app._csManager._cs._boundary;
          if (boundary._min._x !== minX || boundary._min._y !== minY || boundary._min._z !== minZ || boundary._max._x !== maxX || boundary._max._y !== maxY || boundary._max._z !== maxZ) crystalBoundarySettingDialog.I._bModified = true;
          if (crystalBoundarySettingDialog.I._bModified) {
            crystalBoundarySettingDialog.I._app._bModified = true;
            crystalBoundarySettingDialog.I._app._csManager.AddUndo();
            crystalBoundarySettingDialog.I._app._3dRender._renderer.autofitCameraObjList([crystalBoundarySettingDialog.I._app._csManager._cs.getMesh()], 100);
          }
          crystalBoundarySettingDialog.I.OnApply();
          crystalBoundarySettingDialog.I._app._dlgEditVectors.RestoreAddedVectorFromCS();
          crystalBoundarySettingDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalBoundarySettingDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalBoundarySettingDialog.I._show = false;
      }
    });
    this._input_min_x = document.getElementById(name + "_boundary_min_x");
    this._input_max_x = document.getElementById(name + "_boundary_max_x");
    this._input_min_y = document.getElementById(name + "_boundary_min_y");
    this._input_max_y = document.getElementById(name + "_boundary_max_y");
    this._input_min_z = document.getElementById(name + "_boundary_min_z");
    this._input_max_z = document.getElementById(name + "_boundary_max_z");
    this._input_h = document.getElementById(name + "_cutoff_miller_indices_h");
    this._input_k = document.getElementById(name + "_cutoff_miller_indices_k");
    this._input_l = document.getElementById(name + "_cutoff_miller_indices_l");
    this._input_d = document.getElementById(name + "_cutoff_distance_from_origin_A");
    this._btnNewShape = document.getElementById(name + "_new_cutoff_shape_btn");
    this._btnDeleteShape = document.getElementById(name + "_delete_cutoff_shape_btn");
    this._btnClearShape = document.getElementById(name + "_clear_cutoff_shape_btn");
    this._div_shapeTable = document.getElementById(name + "_cutoff_crystal_shape_table");
    this._shapeTable = new crystalTable(this._name, this._app, this._div_shapeTable, "cutOffShapeTable");
    this._shapeTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>h</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>k</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>l</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>d(A)</th>\
            ", false);

    // <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>sym.</th>\

    $(this._btnNewShape).button();
    $(this._btnDeleteShape).button();
    $(this._btnClearShape).button();
    $(this._btnNewShape).click(function (event) {
      crystalBoundarySettingDialog.I._bModified = true;
      let len = crystalBoundarySettingDialog.I._app._csManager._cs._boundary._cutoffPlanes.length;
      let h = parseFloat($(crystalBoundarySettingDialog.I._input_h).val());
      let k = parseFloat($(crystalBoundarySettingDialog.I._input_k).val());
      let l = parseFloat($(crystalBoundarySettingDialog.I._input_l).val());
      let d = parseFloat($(crystalBoundarySettingDialog.I._input_d).val());
      if (h === 0 && k === 0 && l === 0) {
        alert("hkl can not be all zero");
        return;
      }
      crystalBoundarySettingDialog.I.AddShapeToTable(len, h, k, l, d, true);
      let plane = new Plane_Plane();
      let lattice_axis = crystalBoundarySettingDialog.I._app._csManager._cs.getLatticeAxis();
      plane.setMillerIndices(lattice_axis, h, k, l, d);
      crystalBoundarySettingDialog.I._app._csManager._cs._boundary.addPlane(plane);
      crystalBoundarySettingDialog.I.generateStructure();
    });
    $(this._btnDeleteShape).click(function (event) {
      crystalBoundarySettingDialog.I._bModified = true;
      let shapeRows = crystalBoundarySettingDialog.I._shapeTable.getSelected();
      for (let shapeRow of shapeRows) {
        let idx = parseInt($(shapeRow).find("#" + crystalBoundarySettingDialog.I._app._name + "_cutoff_shape_no").html());
        crystalBoundarySettingDialog.I._app._csManager._cs._boundary.removePlane(crystalBoundarySettingDialog.I._app._csManager._cs._boundary._cutoffPlanes[idx]);
      }
      crystalBoundarySettingDialog.I._shapeTable.deleteSelected();
      crystalBoundarySettingDialog.I.generateStructure();
    });
    $(this._btnClearShape).click(function (event) {
      crystalBoundarySettingDialog.I._bModified = true;
      crystalBoundarySettingDialog.I._app._csManager._cs._boundary.clearPlane();
      crystalBoundarySettingDialog.I._app._dlgBoundarySetting._shapeTable.clearAll();
      crystalBoundarySettingDialog.I.generateStructure();
    });
    $(this._input_h).on("input", function () {
      crystalBoundarySettingDialog.I.ChangeSelected();
    });
    $(this._input_k).on("input", function () {
      crystalBoundarySettingDialog.I.ChangeSelected();
    });
    $(this._input_l).on("input", function () {
      crystalBoundarySettingDialog.I.ChangeSelected();
    });
    $(this._input_d).on("input", function () {
      crystalBoundarySettingDialog.I.ChangeSelected();
    });
  }

  /**
   * BoundarySettingDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div id='" + name + "_boundary_setting_dialog'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Boundary_Setting_Select_Structure' id='" + name + "_bondary_setting_select_structure'>";
    idx++;

    // dropdown 추가하기

    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_boundary_setting_range' style='overflow:hidden'>";
    idx++;

    // fieldset + legend
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Ranges of fractional coordinates</legend>";
    idx++;
    ihtml[idx] = "<table>";
    idx++;

    // table with input tags
    ihtml[idx] = "<tr style='height:10px;'>";
    idx++;
    ihtml[idx] = "<td>min x:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_min_x' value=" + cryst.Boundary["minX"] + "></td>";
    idx++;
    ihtml[idx] = "<td>min y:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_min_y' value=" + cryst.Boundary["minY"] + "></td>";
    idx++;
    ihtml[idx] = "<td>min z:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_min_z' value=" + cryst.Boundary["minZ"] + "></td>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td>max x:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_max_x' value=" + cryst.Boundary["maxX"] + "></td>";
    idx++;
    ihtml[idx] = "<td>max y:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_max_y' value=" + cryst.Boundary["maxY"] + "></td>";
    idx++;
    ihtml[idx] = "<td>max z:</td><td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_boundary_max_z' value=" + cryst.Boundary["maxZ"] + "></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</fieldset></div>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Cutoff planes</legend>";
    idx++;
    ihtml[idx] = "<table>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td>Miller indices (hkl):</td>";
    idx++;
    ihtml[idx] = "<td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_cutoff_miller_indices_h' value=1></td>";
    idx++;
    ihtml[idx] = "<td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_cutoff_miller_indices_k' value=1></td>";
    idx++;
    ihtml[idx] = "<td><input type='number' class='cryUI_Low_Normal_Td' id='" + name + "_cutoff_miller_indices_l' value=0></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Distance from origin:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Low_Normal_Td' type='number' id='" + name + "_cutoff_distance_from_origin_A' value=1></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;

    // table
    ihtml[idx] = "<br><div class='cryUI_Edit_Structure_Table_Area' id='" + name + "_cutoff_crystal_shape_area'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table' id='" + name + "_cutoff_crystal_shape_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Modify' id='" + name + "_cutoff_shape_modify'>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_new_cutoff_shape_btn'>New</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_delete_cutoff_shape_btn'>Delete</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_clear_cutoff_shape_btn'>Clear</button>";
    idx++;
    ihtml[idx] = "</div>";
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 다이얼로그를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    crystalBoundarySettingDialog.I._app._csManager.SetPrev(crystalBoundarySettingDialog.I._app._csManager._cs);
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }

  /**
   * 다이얼로그 내역을 적용시킨다.
   * */
  OnApply() {
    this._input_min_x = document.getElementById(this._name + "_boundary_min_x");
    this._input_max_x = document.getElementById(this._name + "_boundary_max_x");
    this._input_min_y = document.getElementById(this._name + "_boundary_min_y");
    this._input_max_y = document.getElementById(this._name + "_boundary_max_y");
    this._input_min_z = document.getElementById(this._name + "_boundary_min_z");
    this._input_max_z = document.getElementById(this._name + "_boundary_max_z");
    if ($(this._input_min_x).val() === '') {
      $(this._input_min_x).val(0);
    }
    if ($(this._input_min_y).val() === '') {
      $(this._input_min_y).val(0);
    }
    if ($(this._input_min_z).val() === '') {
      $(this._input_min_z).val(0);
    }
    if ($(this._input_max_x).val() === '') {
      $(this._input_max_x).val(0);
    }
    if ($(this._input_max_y).val() === '') {
      $(this._input_max_y).val(0);
    }
    if ($(this._input_max_z).val() === '') {
      $(this._input_max_z).val(0);
    }
    let minX = parseFloat($(this._input_min_x).val());
    let minY = parseFloat($(this._input_min_y).val());
    let minZ = parseFloat($(this._input_min_z).val());
    let maxX = parseFloat($(this._input_max_x).val());
    let maxY = parseFloat($(this._input_max_y).val());
    let maxZ = parseFloat($(this._input_max_z).val());
    this._app._csManager._cs._boundary.set(new Vector3(minX, minY, minZ), new Vector3(maxX, maxY, maxZ));
    this.generateStructure();
    this._app._3dRender._renderer.autofitCameraObjList([this._app._csManager._cs.getMesh()], 100);

    // 거리 각도 측정 삭제 호출
    this._app._uiHandler.ClearAllMeasures();
  }

  /**
   * 테이블에 cutoff palne을 추가한다.
   * @param {Number} id plane id
   * @param {Number} h h value
   * @param {Number} k k value
   * @param {Number} l l value
   * @param {Number} d distance
   * @param {Boolean} sym symmetry or not
   */
  AddShapeToTable(id, h, k, l, d, sym) {
    let innerHTML = "\
            <td id='" + this._name + "_cutoff_shape_no' style='display:none'>" + id + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_cutoff_shape_h'>" + h + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_cutoff_shape_k'>" + k + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_cutoff_shape_l'>" + l + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_cutoff_shape_distance'>" + d + "</td>\
            ";

    //      <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'><input type='checkbox' id='" + this._name + "_cutoff_shape_sym' checked='" + sym + "'></td>\

    this._shapeTable.appTable(innerHTML, true);
    let elements = document.querySelectorAll('tr.sortable');
    Array.from(elements).forEach(function (element) {
      $(element).mousedown(function () {
        crystalBoundarySettingDialog.I.UpdateSelect();
      });
    });
  }

  /**
   * 선택된 row 값을 읽어 입력창을 갱신한다.
   * */
  UpdateSelect() {
    let selected = this._shapeTable.getSelected();
    if (selected.length === 1) {
      rayLog(3, selected);
      let tokens = selected[0].innerText.split("\t");
      $(this._input_h).val(tokens[1]);
      $(this._input_k).val(tokens[2]);
      $(this._input_l).val(tokens[3]);
      $(this._input_d).val(tokens[4]);
    }
  }
  /**
   * 선택된 row를 입력값을 바탕으로 업데이트한다.
   * */
  ChangeSelected() {
    let selected = this._shapeTable.getSelected();
    if (selected.length === 1) {
      this.UpdateSelectByInput();
    }
  }

  /**
   * 입력값을 선택된 row에 적용한다.
   * */
  UpdateSelectByInput() {
    let selected = this._shapeTable.getSelected();
    if (selected.length === 1) {
      let idx = parseInt($(selected[0]).find("#" + this._name + "_cutoff_shape_no").html());
      let cutoffPlane = this._app._csManager._cs._boundary._cutoffPlanes[idx];
      this.SetCutOffPlaneByInput(cutoffPlane);
      this.UpdateSelectedCutOffPlaneRow(selected[0], cutoffPlane);
    }
  }

  /**
   * 현재 선택된 row에 plane의 데이터를 반영한다.
   * @param {HTMLElement} selectedCutOffPlaneRow 선택된 plane row
   * @param {Plane} plane row에 반영할 plane 객체
   */
  UpdateSelectedCutOffPlaneRow(selectedCutOffPlaneRow, plane) {
    $(selectedCutOffPlaneRow).find("#" + this._name + "_cutoff_shape_h").html(plane._h);
    $(selectedCutOffPlaneRow).find("#" + this._name + "_cutoff_shape_k").html(plane._k);
    $(selectedCutOffPlaneRow).find("#" + this._name + "_cutoff_shape_l").html(plane._l);
    $(selectedCutOffPlaneRow).find("#" + this._name + "_cutoff_shape_d").html(plane._d);
  }

  /**
   * CStructure generate
   * */
  generateStructure() {
    this._app._csManager._cs.generate(this._app.GetSymmetryIdxList());
    this._app.UpdateStructureProperty();
    this._app.UpdateRenderOptions();
  }
  UpdateBoundary() {
    $(this._input_min_x).val(this._app._csManager._cs._boundary._min._x);
    $(this._input_min_y).val(this._app._csManager._cs._boundary._min._y);
    $(this._input_min_z).val(this._app._csManager._cs._boundary._min._z);
    $(this._input_max_x).val(this._app._csManager._cs._boundary._max._x);
    $(this._input_max_y).val(this._app._csManager._cs._boundary._max._y);
    $(this._input_max_z).val(this._app._csManager._cs._boundary._max._z);
  }
  SetCutOffPlaneByInput(cutoffPlane) {
    cutoffPlane._h = parseFloat($(this._input_h).val());
    cutoffPlane._k = parseFloat($(this._input_k).val());
    cutoffPlane._l = parseFloat($(this._input_l).val());
    cutoffPlane._d = parseFloat($(this._input_d).val());
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalCreateVectorDialog.js



/**
 * Vector 생성 다이얼로그
 * */
class crystalCreateVectorDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app Crystal Editor 앱 참조
   * @param {HTMLElement} div_elem crystalCreateVectorDialog가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalCreateVectorDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxHeight: 240,
      height: 240,
      maxWidth: 400,
      width: 400,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Create Vector",
      buttons: {
        "OK": function () {
          if (crystalCreateVectorDialog.I._bModified) {
            crystalCreateVectorDialog.I._app._bModified = true;
            crystalCreateVectorDialog.I._app._csManager.AddUndo();
          }
          crystalCreateVectorDialog.I.OnApply();
          crystalCreateVectorDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalCreateVectorDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalCreateVectorDialog.I._show = false;
      }
    });
    this._vectorColor = document.getElementById(name + "_vector_color_background");
    this._input_u = document.getElementById(name + "_lattice_vector_u");
    this._input_v = document.getElementById(name + "_lattice_vector_v");
    this._input_w = document.getElementById(name + "_lattice_vector_w");
    this._radius = document.getElementById(name + "_vector_radius");
    $(this._vectorColor).colorpicker({
      modal: true,
      buttonColorize: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
      }
    });
    $(this._input_u).on("input", function () {
      if (crystalCreateVectorDialog.I._mode === cryst.Mode.ModifyVector) {
        crystalCreateVectorDialog.I._bModified = true;
      }
    });
    $(this._input_v).on("input", function () {
      if (crystalCreateVectorDialog.I._mode === cryst.Mode.ModifyVector) {
        crystalCreateVectorDialog.I._bModified = true;
      }
    });
    $(this._input_w).on("input", function () {
      if (crystalCreateVectorDialog.I._mode === cryst.Mode.ModifyVector) {
        crystalCreateVectorDialog.I._bModified = true;
      }
    });
    $(this._radius).on("input", function () {
      if (crystalCreateVectorDialog.I._mode === cryst.Mode.ModifyVector) {
        crystalCreateVectorDialog.I._bModified = true;
      }
    });
  }

  /**
   * CreateVectorDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_vector_radius'>Radius:</label>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Normal_Td' type='number' id='" + name + "_vector_radius'>";
    idx++;
    ihtml[idx] = "</div><br>";
    idx++;

    // fieldset = label + input number + input number + input number
    ihtml[idx] = "<div>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Vector components</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_lattice_vector_notation'>Lattice vector notation [u v w]:</label><br>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_lattice_vector_u'>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_lattice_vector_v'>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_lattice_vector_w'>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // label + input number + input number + input number + color picker
    ihtml[idx] = "<div><br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_vector_color'>Color:</label>";
    idx++;
    ihtml[idx] = "<input type='text' id='" + name + "_vector_color_background'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 다이얼로그를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    this._dialog.dialog("open");
    this._show = true;
    if (this._mode === cryst.Mode.AddVector) this.SetDefault();else this.SetSelected();
  }

  /**
   * 다이얼로그를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
    this._bModified = false;
    this._app.UpdateUI();
  }

  /**
   * 다이얼로그 내역을 적용시킨다.
   * */
  OnApply() {
    if (this._mode === cryst.Mode.AddVector) {
      this.AddVector();
      crystalCreateVectorDialog.I._app._dlgEditVectors._vectors_tab._crystal_vectors_table.initSelect();
      crystalCreateVectorDialog.I._app._dlgEditVectors._vectors_tab._crystal_vectors_table.selectLast();
    } else if (this._mode === cryst.Mode.ModifyVector) this.ModifyVector();
  }

  /**
   * 입력란 초기화
   * */
  SetDefault() {
    $(this._input_u).val(0.1);
    $(this._input_v).val(0.0);
    $(this._input_w).val(0.0);
    $(this._radius).val(0.1);
    $(this._vectorColor).val("ff0000");
    $(this._vectorColor).css("background-color", "rgb(255,0,0)");
  }

  /**
   * 선택된 row 데이터를 입력창에 적용한다.
   * */
  SetSelected() {
    let selected = this._app._dlgEditVectors._vectors_tab._crystal_vectors_table.getSelected();
    if (selected.length === 1) {
      let u = parseFloat($(selected[0]).find("#" + this._name + "_edit_vectors_u").text());
      let v = parseFloat($(selected[0]).find("#" + this._name + "_edit_vectors_v").text());
      let w = parseFloat($(selected[0]).find("#" + this._name + "_edit_vectors_w").text());
      let radius = parseFloat($(selected[0]).find("#" + this._name + "_edit_vectors_radius").text());
      let color = crystalVariable.HTMLColorRGB($(selected[0]).find("#" + this._name + "_vectors_tab_vector_color").text().split(","));
      let rgb = crystalVariable.HexStringtoColor(color);
      $(this._input_u).val(u);
      $(this._input_v).val(v);
      $(this._input_w).val(w);
      $(this._radius).val(radius);
      $(this._vectorColor).val(color);
      $(this._vectorColor).css("background-color", "rgb(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + ")");
    }
  }

  /**
   * 벡터를 추가한다.
   * */
  AddVector() {
    let u = parseFloat($(this._input_u).val());
    let v = parseFloat($(this._input_v).val());
    let w = parseFloat($(this._input_w).val());
    let radius = parseFloat($(this._radius).val());
    let color = crystalVariable.HexStringtoColor($(this._vectorColor).val());
    let tvector = new tVector([u, v, w], color, radius);

    // csManager에 추가하기
    this._app._csManager._cs.addtVector(tvector);

    // table에 추가하기
    this._app._dlgEditVectors._vectors_tab._crystal_vectors_table.appTable("\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_u'>" + u + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_v'>" + v + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_w'>" + w + "</td >\
            <td class='cryUI_Big_Td'>0</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_radius'>" + radius + "</td>\
            <td id='" + this._name + "_vectors_tab_vector_number' style='display:none'>" + tvector._number + "</td>\
            <td id='" + this._name + "_vectors_tab_vector_color' style='display:none'>" + color[0] + "," + color[1] + "," + color[2] + "</td>\
            ", true);
  }

  /**
   * 기존 벡터를 수정한다.
   * */
  ModifyVector() {
    let currentVector = this._app._dlgEditVectors._vectors_tab._crystal_vectors_table.getSelected();
    if (currentVector.length === 1) {
      let currentRow = currentVector[0];
      let number = parseInt($(currentRow).find("#" + this._name + "_vectors_tab_vector_number").html());
      let u = parseFloat($(this._input_u).val());
      let v = parseFloat($(this._input_v).val());
      let w = parseFloat($(this._input_w).val());
      let radius = parseFloat($(this._radius).val());

      // csManager로부터 해당 vector를 가져온다
      let vector = this._app._csManager._cs.gettVectorByNumber(number)[0];
      vector._vector = [u, v, w];
      let color = crystalVariable.HexStringtoColor($(this._vectorColor).val());
      vector._color = color;
      vector._radius = radius;
      this._app._csManager._cs.generateMesh4iVectors();

      // row 재설정
      $(currentRow).find("#" + this._name + "_vectors_tab_vector_color").html(color[0] + "," + color[1] + "," + color[2]);
      $(currentRow).find("#" + this._name + "_edit_vectors_u").html(u);
      $(currentRow).find("#" + this._name + "_edit_vectors_v").html(v);
      $(currentRow).find("#" + this._name + "_edit_vectors_w").html(w);

      // 현재 이 벡터를 참조하고 있는 atom의 벡터를 모두 갱신한다.
      crystalCreateVectorDialog.I._app._dlgEditVectors.generateStructure();
      crystalCreateVectorDialog.I._app.UpdateStructureProperty();
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditBondConfirmDialog.js
/**
 * ������ Clear ���̾�α�
 * */
class crystalEditBondConfirmDialog {
  /**
   * ������
   * @param {String} name �ٸ� �۰� �����ϱ� ���� �̸�
   * @param {crystalEditor} app ���� �� ��ü
   * @param {HTMLElement} div_elem EditBondConfirmDialog�� ������ html element
   * */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    crystalEditBondConfirmDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxWidth: 200,
      maxHeight: 120,
      width: 200,
      height: 120,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Clear Bond",
      buttons: {
        "OK": function () {
          crystalEditBondConfirmDialog.I._app._csManager.AddUndo();
          crystalEditBondConfirmDialog.I.OnApply();
          crystalEditBondConfirmDialog.I._app._dlgEditVectors.RestoreAddedVectorFromCS();
          crystalEditBondConfirmDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalEditBondConfirmDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalEditBondConfirmDialog.I._show = false;
      }
    });
  }

  /**
   * EditBondConfirmDialog�� ���� html element�� �ۼ��Ѵ�.
   * 
   * @param {String} name �ٸ� �۰� �����ϱ� ���� �̸�
   * @returns {String} HTML ���ڿ�
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div>Are you sure to clear all bonds?</div>";
    idx++;
    return ihtml.join("");
  }
  /**
   * edit Bond confirm dialog�� ����.
   * */
  ShowDialog() {
    if (this._show) return;
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * ���̾�α� â�� �ݴ´�.
   *
   * @memberof crystalEditBondConfirmDialog
   */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }

  /**
   * ���� ���¸� �����Ѵ�.
   * */
  OnApply() {
    crystalEditBondConfirmDialog.I._app._csManager._cs.clearBond();
    crystalEditBondConfirmDialog.I._app._dlgEditBond._bondTable.clearAll();
    crystalEditBondConfirmDialog.I._app._dlgEditBond.DisableInput(true);
    crystalEditBondConfirmDialog.I._app._dlgEditBond.generateStructure();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditBondDialog.js








/**
 * Bond 편집 다이얼로그
 * */
class crystalEditBondDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalEditBondDialog가 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    crystalEditBondDialog.I = this;
    this._div.innerHTML = this._appElementHTML(this._name);
    this._bModified = false;
    this._div_bondTable_area = document.getElementById(name + "_bonds_table_area");
    this._div_bondTable = document.getElementById(name + "_bonds_table");
    this._bondTable = new crystalTable(this._name, this._app, this._div_bondTable, "bondTable");
    this._bondTable.createHeader("\
            <tr>\
                <th class='cryUI_Big_Td'>No.</th>\
                <th class='cryUI_Big_Td'>Atom 1</th>\
                <th class='cryUI_Big_Td'>Atom 2</th>\
                <th class='cryUI_Normal_Td'>Min.</th>\
                <th class='cryUI_Normal_Td'>Max.</th>\
                <th class='cryUI_Normal_Td'>Bound.</th>\
                <th class='cryUI_Normal_Td'>Poly.</th>\
            </tr>");
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxHeight: 340,
      height: 340,
      maxWidth: 610,
      width: 610,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Bond",
      buttons: {
        "OK": function () {
          if (crystalEditBondDialog.I._bModified) {
            crystalEditBondDialog.I._app._bModified = true;
            crystalEditBondDialog.I._app._dlgEditVectors.RestoreAddedVectorFromCS();
            crystalEditBondDialog.I._app._csManager.AddUndo();
          }
          crystalEditBondDialog.I.OnApply();
          crystalEditBondDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalEditBondDialog.I.CloseDialog();
        }
        /*
        "Apply": function () {
            crystalEditBondDialog.I.OnApply();
        },
        */
      },

      close: function () {
        crystalEditBondDialog.I._show = false;
        crystalEditBondDialog.I._app.UpdateUI();
      }
    });
    this._btnNewBond = document.getElementById(name + "_new_bond_btn");
    this._btnDeleteBond = document.getElementById(name + "_delete_bond_btn");
    this._btnClearBond = document.getElementById(name + "_clear_bond_btn");
    this._inputMinLength = document.getElementById(name + "_min_length");
    this._inputMaxLength = document.getElementById(name + "_max_length");
    this._selectAtom1 = document.getElementById(name + "_select_atom1");
    this._selectAtom2 = document.getElementById(name + "_select_atom2");
    $(this._inputMinLength).on("input", function () {
      crystalEditBondDialog.I.ChangeSelected();
    });
    $(this._inputMaxLength).on("input", function () {
      crystalEditBondDialog.I.ChangeSelected();
    });
    $(this._selectAtom1).change(function () {
      crystalEditBondDialog.I.ChangeSelected();
    });
    $(this._selectAtom2).change(function () {
      crystalEditBondDialog.I.ChangeSelected();
    });
    $(this._btnNewBond).button();
    $(this._btnDeleteBond).button();
    $(this._btnClearBond).button();
    $(this._btnNewBond).click(function (event) {
      crystalEditBondDialog.I._bModified = true;
      let atom1Idx = $(crystalEditBondDialog.I._selectAtom1)[0].selectedIndex;
      let atom2Idx = $(crystalEditBondDialog.I._selectAtom2)[0].selectedIndex;
      let atom1 = crystalEditBondDialog.I._app._csManager._cs._atoms[atom1Idx];
      let atom2 = crystalEditBondDialog.I._app._csManager._cs._atoms[atom2Idx];
      let min = parseFloat($(crystalEditBondDialog.I._inputMinLength).val());
      let max = parseFloat($(crystalEditBondDialog.I._inputMaxLength).val());
      let bound = 2;
      let is_poly = true;
      if (atom1 && atom2) {
        let bond = crystalEditBondDialog.I.createBond(crystalEditBondDialog.I._app._csManager._cs.assignBondIdx(), atom1, atom2, min, max);
        crystalEditBondDialog.I.AddBondToTable(bond._idx, atom1Idx, atom2Idx, min, max, bound, is_poly);
        if (!crystalEditBondDialog.I._app._csManager._cs) {
          crystalEditBondDialog.I._app._csManager._cs = new CStructure();
          crystalEditBondDialog.I._app._csManager._cs._boundary.set(new Vector3(0, 0, 0), new Vector3(1, 1, 1));
        }
        crystalEditBondDialog.I._app._csManager._cs.addBond(bond);
        crystalEditBondDialog.I.generateStructure(); // 렌더러 갱신

        crystalEditBondDialog.I._bondTable.initSelect();
        crystalEditBondDialog.I._bondTable.selectLast();
        crystalEditBondDialog.I.UpdateSelect();
      } else {
        alert("Bond can not be created");
      }
    });
    $(this._btnDeleteBond).click(function (event) {
      crystalEditBondDialog.I._bModified = true;
      let bondRows = crystalEditBondDialog.I._bondTable.getSelected();
      for (let idx in bondRows) {
        idx = parseInt(idx);
        if (isNaN(idx)) break;

        // bondRows[idx]에서 atom1과 atom2를 가져오기..
        let atom1 = bondRows[idx].getElementsByClassName(crystalEditBondDialog.I._name + "_edit_bond_table_atom1")[0].innerHTML;
        let atom2 = bondRows[idx].getElementsByClassName(crystalEditBondDialog.I._name + "_edit_bond_table_atom2")[0].innerHTML;
        crystalEditBondDialog.I._app._csManager._cs.removeBond(atom1, atom2); // bond 삭제

        crystalEditBondDialog.I._bondTable.deleteSelected(); // 삭제

        crystalEditBondDialog.I.generateStructure(); // 렌더러 갱신
      }

      if (crystalEditBondDialog.I._bondTable.getAllRow().length === 0) crystalEditBondDialog.I.DisableInput(true);
      crystalEditBondDialog.I._bondTable.updateTable();
    });
    $(this._btnClearBond).click(function (event) {
      crystalEditBondDialog.I._bModified = true;
      crystalEditBondDialog.I._app._dlgEditBondConfirm.ShowDialog();
    });
    this._div_structure_select = document.getElementById(this._name + "_bonds_structure_select");
    this._div_phase = document.getElementById(this._name + "_bonds_phase");
    this._div_structure_dropdown = document.getElementById(this._name + "_bonds_structure_dropdown");
    this._div_search_area = document.getElementById(this._name + "_bonds_search_area");
    this._div_search_mode = document.getElementById(this._name + "_bonds_search_mode");
    this._div_boundary_mode = document.getElementById(this._name + "_bonds_boundary_mode");
    this._div_search_value = document.getElementById(this._name + "_bonds_search_value");
    this._div_table_area = document.getElementById(this._name + "_bonds_table_area");
    this._div_table = document.getElementById(this._name + "_bonds_table");
    this._div_modify_table = document.getElementById(this._name + "_bonds_modify_table");
    $(this._div_table).css("table-layout", "fixed");
    $(this._div_table).css("overflow", "auto");
    this._div_search_mode_0 = document.getElementById(this._name + "_check_search_mode_0");
    this._div_search_mode_1 = document.getElementById(this._name + "_check_search_mode_1");
    this._div_search_mode_2 = document.getElementById(this._name + "_check_search_mode_2");
    this._div_boundary_mode_0 = document.getElementById(this._name + "_check_boundary_mode_0");
    this._div_boundary_mode_1 = document.getElementById(this._name + "_check_boundary_mode_1");
    this._div_boundary_mode_2 = document.getElementById(this._name + "_check_boundary_mode_2");
    $('input[name="search_mode"]').change(function () {
      $('input[name="search_mode"]').each(function () {
        if ($(this).prop('checked')) cryst.Mode.Search = parseInt($(this).val());
      });
    });
    $('input[name="boundary_mode"]').change(function () {
      $('input[name="boundary_mode"]').each(function () {
        if ($(this).prop('checked')) {
          cryst.Mode.Boundary = parseInt($(this).val());
          crystalEditBondDialog.I._app._csManager._cs.setClipOption(cryst.Mode.Boundary);
        }
      });
    });
    $(this._div_search_mode_0).prop('checked', true);
    $(this._div_boundary_mode_1).prop('checked', true);
    this.DisableInput(true);
    $(this._selectAtom1).on("change", function () {
      crystalEditBondDialog.I._bModified = true;
    });
    $(this._selectAtom2).on("change", function () {
      crystalEditBondDialog.I._bModified = true;
    });
    $(this._inputMaxLength).on("input", function () {
      crystalEditBondDialog.I._bModified = true;
    });
    $(this._inputMinLength).on("input", function () {
      crystalEditBondDialog.I._bModified = true;
    });
  }

  /**
   * EditBondDialog에 대한 html element를 작성한다.
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div id='" + name + "_edit_bond_dialog'>";
    idx++;

    /*
    ihtml[idx] = "<div class='cryUI_Bonds_Structure_Select' id='" + name + "_bonds_structure_select'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Bonds_Phase' id='"+name+"_bonds_phase'><tr><td>Phase:</td><td><input class='cryUI_Normal_Td' type='number'></td></tr></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Bonds_Structure_Dropdown' id='" + name + "_bonds_structure_dropdown'><td>dropdown</td></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */

    /*
    ihtml[idx] = "<div class='cryUI_Bonds_Search_Area' id='" + name + "_bonds_search_area'>";
    idx++;
      ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Search bonds and atoms</legend>";
    idx++;
        ihtml[idx] = "<div class='cryUI_Bonds_Search_Mode' id='" + name + "_bonds_search_mode'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Search mode</legend>"
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_search_mode_0' value='0' name='search_mode'><label for='search_mode_one'>Search A2 bonded to A1</label><br>";
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_search_mode_1' value='1' name='search_mode'><label for='search_mode_two'>Search atoms bonded to A1</label><br>";
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_search_mode_2' value='2' name='search_mode'><label for='search_mode_three'>Search molecules</label>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
      idx++;
        ihtml[idx] = "<div class='cryUI_Bonds_Boundary_Mode' id='" + name + "_bonds_binary_mode'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Boundary mode</legend>";
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_boundary_mode_0' value='0' name='boundary_mode'><label for='boundary_mode_one'>Do not search atoms beyond the boundary</label><br>";
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_boundary_mode_1' value='1' name='boundary_mode'><label for='boundary_mode_two'>Search additional atoms if A1 is included in the boundary</label><br>";
    idx++;
    ihtml[idx] = "<input type='radio' id='" + name + "_check_boundary_mode_2' value='2' name='boundary_mode'><label for='boundary_mode_three'>Search additional atoms recursively if either A1 or A2 is visible</label>";
    idx++;
    ihtml[idx] = "</fieldset></div>"
    idx++;
      ihtml[idx] = "<div class='cryUI_Bonds_Search_Value_I' id='" + name + "_bonds_search_value'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Div_Element'><input type='checkbox'> Search by Label</div ><div class='cryUI_Div_Element'><input type='checkbox'>Show polyhedra</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */
    ihtml[idx] = "<div class='cryUI_Bonds_Search_Value_II' id='" + name + "_bonds_search_value'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Div_Element'><label for='atom1'>Atom1:</label>";
    idx++;
    ihtml[idx] = "<select name='atom1' id='" + name + "_select_atom1'></select></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Div_Element'><label for='atom2'>Atom2:</label>";
    idx++;
    ihtml[idx] = "<select name='atom2' id='" + name + "_select_atom2'></select></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Div_Element'><label for='min_length'>Min. Length:</label>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Big_Td' name='min_length' type='number' value=0 id='" + name + "_min_length'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Div_Element'><label for='max_length'>Max. Length:</label>";
    idx++;
    ihtml[idx] = "<input class='cryUI_Big_Td' name='max_length' type='number' value=5 id='" + name + "_max_length'></div></div>";
    idx++;
    ihtml[idx] = "</fieldset></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Bonds_Table_Area' id='" + name + "_bonds_table_area'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Bonds_Table' id='" + name + "_bonds_table'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Bonds_Modify_Table' id='" + name + "_bonds_table_modify_table'>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Normal_Btn_Margin_Bottom ui - button ui - widget ui - corner - all' id='" + name + "_new_bond_btn'>New</button>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Normal_Btn_Margin_Bottom ui - button ui - widget ui - corner - all' id='" + name + "_delete_bond_btn'>Delete</button>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Normal_Btn_Margin_Bottom ui - button ui - widget ui - corner - all' id='" + name + "_clear_bond_btn'>Clear</button>";
    idx++;
    ihtml[idx] = "</div></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 테이블에 bond를 추가한다.
   * @param {Number} idx bond index
   * @param {Number} atom1Idx catom index
   * @param {Number} atom2Idx catom index
   * @param {Number} min min length
   * @param {Number} max max length
   * @param {Number} bound 
   * @param {Boolean} is_poly
   */
  AddBondToTable(idx, atom1Idx, atom2Idx, min, max, bound, is_poly) {
    let atom1 = this._app._csManager._cs._atoms[atom1Idx]._def._atom_id;
    let atom2 = this._app._csManager._cs._atoms[atom2Idx]._def._atom_id;
    let innerHTML = "\
            <td style='display:none' id='" + this._name + "_bond_idx_" + idx + "'>\
            <td class='cryUI_Big_Td " + this._name + "_edit_bond_table_atom1'>" + atom1 + "</td>\
            <td id='" + this._name + "_bond_atom1_idx' style='display:none'>" + atom1Idx + "</td>\
            <td class='cryUI_Big_Td " + this._name + "_edit_bond_table_atom2'>" + atom2 + "</td>\
            <td id='" + this._name + "_bond_atom2_idx' style='display:none'>" + atom2Idx + "</td>\
            <td class='cryUI_Normal_Td' id='" + this._name + "_bond_min_length'>" + min + "</td>\
            <td class='cryUI_Normal_Td' id='" + this._name + "_bond_max_length'>" + max + "</td>\
            <td class='cryUI_Normal_Td'>" + bound + "</td>\
            <td class='cryUI_Normal_Td'> <input type='checkbox' checked='" + is_poly + "'></td>";
    this._bondTable.appTable(innerHTML, true);
  }

  /**
   * CStructure generate
   * */
  generateStructure() {
    let renderer = crystalEditBondDialog.I._app._3dRender;
    let csManager = crystalEditBondDialog.I._app._csManager;
    renderer.Clear();
    csManager._cs.generate(crystalEditBondDialog.I._app.GetSymmetryIdxList());
    crystalEditBondDialog.I._app.UpdateStructureProperty();
    crystalEditBondDialog.I._app.UpdateRenderOptions();
    renderer._renderer._scene.children.pop();
    renderer._renderer._scene.add(csManager._cs._groupMesh);
  }

  /**
   * 결합을 생성한다.
   * @param {Number} idx bond index
   * @param {String} atom1 atom1 name
   * @param {String} atom2 atom2 name
   * @param {Number} min min length
   * @param {Number} max max length
   * @param {Number} bound
   * @param {Boolean} is_poly 
   * 
   * @returns {CBond} 생성된 결합
   */
  createBond(idx, atom1, atom2, min, max, bound, is_poly) {
    let newBond = new CBond();
    newBond.setLength(min, max);
    newBond.setAtom(atom1, atom2);
    newBond._idx = idx;
    return newBond;
  }

  /**
   * edit bond dialog를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    crystalEditBondDialog.I._app._csManager.SetPrev(crystalEditBondDialog.I._app._csManager._cs);
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * dialog를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
    this._bModified = false;
  }

  /**
   * 테이블 업데이트
   * */
  UpdateTable() {
    // atom 가져오기
    let cs = crystalEditBondDialog.I._app._csManager._cs;
    let atoms = cs._atoms;

    // 현재 존재하는 원자 이름들을 가져와 배열에 넣기
    let atomNameList = [];
    for (let i = 0; i < atoms.length; ++i) {
      let atomName = AtomDef_AtomDef.GetDefWithNumber(atoms[i]._id)._atom_id;
      atomNameList.push(atomName);
    }

    // select 모두 지우고 업데이트하기
    $(this._selectAtom1).find('option').remove();
    $(this._selectAtom2).find('option').remove();
    for (let i = 0; i < atomNameList.length; ++i) {
      $(this._selectAtom1).append('<option>' + atomNameList[i] + '</option>');
    }
    for (let i = 0; i < atomNameList.length; ++i) {
      $(this._selectAtom2).append('<option>' + atomNameList[i] + '</option>');
    }
    $(this._bondTable.getAllRow()).removeClass("ui-selected");
  }

  /**
   * 선택된 row를 바탕으로 입력란을 업데이트한다.
   * */
  UpdateSelect() {
    let selected = this._bondTable.getSelected();
    if (selected.length === 1) {
      rayLog(3, selected);
      this.DisableInput(false);
      let tokens = selected[0].innerText.split("\t");
      $(crystalEditBondDialog.I._selectAtom1).val(tokens[1]);
      $(crystalEditBondDialog.I._selectAtom2).val(tokens[2]);
      $(crystalEditBondDialog.I._inputMinLength).val(parseFloat(tokens[3]));
      $(crystalEditBondDialog.I._inputMaxLength).val(parseFloat(tokens[4]));
    } else {
      this.DisableInput(true);
    }
  }

  /**
   * 입력값을 바탕으로 선택된 row를 업데이트한다.
   * */
  UpdateSelectByInput() {
    let selected = this._bondTable.getSelected();
    if (selected.length === 1) {
      let idx = selected[0].innerText.split("\t")[0];
      let atom1Idx = $(crystalEditBondDialog.I._selectAtom1)[0].selectedIndex;
      let atom2Idx = $(crystalEditBondDialog.I._selectAtom2)[0].selectedIndex;
      let atom1 = this._app._csManager._cs._atoms[atom1Idx]._def._atom_id;
      let atom2 = this._app._csManager._cs._atoms[atom2Idx]._def._atom_id;
      let min = parseFloat($(crystalEditBondDialog.I._inputMinLength).val());
      let max = parseFloat($(crystalEditBondDialog.I._inputMaxLength).val());
      let innerHTML = "\
                <div class='handle'><span class='ui-icon ui-icon-carat-2-n-s'></span></div>\
                <td class='position cryUI_Normal_Td'>" + idx + "</td>\
                <td style='display:none' id='" + this._name + "_bond_idx_" + idx + "'>\
                <td class='cryUI_Big_Td " + this._name + "_edit_bond_table_atom1'>" + atom1 + "</td>\
                <td id='" + this._name + "_bond_atom1_idx' style='display:none'>" + atom1Idx + "</td>\
                <td class='cryUI_Big_Td " + this._name + "_edit_bond_table_atom2'>" + atom2 + "</td>\
                <td id='" + this._name + "_bond_atom2_idx' style='display:none'>" + atom2Idx + "</td>\
                <td class='cryUI_Normal_Td' id='" + this._name + "_bond_min_length'>" + min + "</td>\
                <td class='cryUI_Normal_Td' id='" + this._name + "_bond_max_length'>" + max + "</td>\
                <td class='cryUI_Normal_Td'></td>\
                <td class='cryUI_Normal_Td'> <input type='checkbox' checked=''></td>";
      selected[0].innerHTML = innerHTML;
    }
  }

  /**
   * CStructure를 바탕으로 테이블을 재구성한다.
   * @param {CStructure} cs 참고할 CStructure
   */
  UpdateTableByCS(cs) {
    for (let i = 0; i < cs._bonds.length; ++i) {
      this.AddBondToTable(cs._bonds[i]._idx, cs._bonds[i]._A1Idx, cs._bonds[i]._A2Idx, cs._bonds[i]._minLength, cs._bonds[i]._maxLength, 2, true);
    }
  }

  /**
   * 테이블 데이터를 바탕으로 bond를 재생성한다.
   * */
  UpdateRenderer() {
    crystalEditBondDialog.I._app._csManager._cs.clearBond();
    let dataList = crystalEditBondDialog.I._bondTable.getAllRow();
    for (let elem of dataList) {
      // let tokens = elem.innerText.split("\t");

      let atom1 = crystalEditBondDialog.I._app._csManager._cs._atoms[parseInt($(elem).find("#" + crystalEditBondDialog.I._name + "_bond_atom1_idx").html())];
      let atom2 = crystalEditBondDialog.I._app._csManager._cs._atoms[parseInt($(elem).find("#" + crystalEditBondDialog.I._name + "_bond_atom2_idx").html())];

      // let tokens = $(elem).text().replace(/\s+/g, ' ').split(' ');
      let min = parseFloat($(elem).find("#" + crystalEditBondDialog.I._name + "_bond_min_length").html());
      let max = parseFloat($(elem).find("#" + crystalEditBondDialog.I._name + "_bond_max_length").html());
      let bond = new CBond();
      if (atom1 && atom2) {
        bond.setLength(min, max);
        bond.setAtom(atom1, atom2);
        crystalEditBondDialog.I._app._csManager._cs.addBond(bond);
      } else {
        elem.remove();
      }
    }
    crystalEditBondDialog.I.generateStructure();
  }

  /**
   * 현재 상태를 적용한다.
   * */
  OnApply() {
    crystalEditBondDialog.I.UpdateRenderer();
    // camera auto fit 호출하기
    // crystalEditBondDialog.I._app._3dRender._renderer.autofitCameraObjList([crystalEditBondDialog.I._app._csManager._cs._groupMesh]);
    // 거리 각도 측정 삭제 호출
    crystalEditBondDialog.I._app._uiHandler.ClearAllMeasures();
    crystalEditBondDialog.I._app._dlgEditVectors.UpdateTable();
  }

  /**
   * 선택된 table row 업데이트
   * */
  ChangeSelected() {
    let selected = this._bondTable.getSelected();
    if (selected.length === 1) {
      this.UpdateSelectByInput();
    } else {
      this.DisableInput(true);
    }
  }

  /**
   * 입력란을 비활성화한다.
   * @param {Boolean} bDisable 입력란 비활성화 여부
   */
  DisableInput(bDisable = true) {
    $(this._inputMinLength).attr("disabled", bDisable);
    $(this._inputMaxLength).attr("disabled", bDisable);
    $(this._selectAtom1).attr("disabled", bDisable);
    $(this._selectAtom2).attr("disabled", bDisable);
    if (bDisable) {
      $(this._inputMinLength).val(0);
      $(this._inputMaxLength).val(0);
      $(this._selectAtom1).attr("selected", "selected");
      ;
      $(this._selectAtom2).attr("selected", "selected");
      ;
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditDataConfirmDialog.js
/**
 * 데이터 Clear 다이얼로그
 * */
class crystalEditDataConfirmDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem EditDataConfirmDialog가 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    crystalEditDataConfirmDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxWidth: 200,
      maxHeight: 120,
      width: 200,
      height: 120,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Clear Data",
      buttons: {
        "OK": function () {
          crystalEditDataConfirmDialog.I._app._csManager.AddUndo();
          crystalEditDataConfirmDialog.I.OnApply();
          crystalEditDataConfirmDialog.I._app._dlgEditVectors.RestoreAddedVectorFromCS();
          crystalEditDataConfirmDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalEditDataConfirmDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalEditDataConfirmDialog.I._show = false;
      }
    });
  }

  /**
   * EditDataConfirmDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div>Are you sure to clear all atoms?</div>";
    idx++;
    return ihtml.join("");
  }
  /**
   * edit data confirm dialog를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그 창을 닫는다.
   *
   * @memberof crystalEditDataConfirmDialog
   */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }

  /**
   * 현재 상태를 적용한다.
   * */
  OnApply() {
    crystalEditDataConfirmDialog.I._app._csManager._cs.clearAtom();
    crystalEditDataConfirmDialog.I._app._dlgEditData._atomTable.clearAll();
    crystalEditDataConfirmDialog.I._app._csManager._cs.clearBond();
    crystalEditDataConfirmDialog.I._app._dlgEditBond._bondTable.clearAll();
    crystalEditDataConfirmDialog.I._app._dlgEditData.DisableInput(true);
    crystalEditDataConfirmDialog.I._app._dlgEditBond.DisableInput(true);
    crystalEditDataConfirmDialog.I._app._dlgEditData.DisableAnisotropicInput(true);
    crystalEditDataConfirmDialog.I._app._dlgEditData.generateStructure();
    crystalEditDataConfirmDialog.I._app._dlgEditData.SetTab4Size();
    crystalEditDataConfirmDialog.I._app._dlgEditBond.UpdateTable();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTableData.js




/**
 * Symmetry Matrix 모음 테이블
 * */
class crystalTableData {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditDataDialog} crystalEditDataDiglog 상위 객체
   */
  constructor(name, crystalEditDataDiglog) {
    this._name = name;
    this._dlgEditData = crystalEditDataDiglog;
    crystalTableData.I = this;
    this._system_table = this._dlgEditData._system_table;
    this._space_group_table = this._dlgEditData._space_group_table;
    this._setting_table = this._dlgEditData._setting_table;
    this._system_table.createHeader("\
            <th class='cryUI_Unit_Cell_Td'>System</th>\
        ", false);
    this._space_group_table.createHeader("\
            <th class='cryUI_Unit_Cell_Num_Td'>No.</th>\
            <th class='cryUI_Unit_Cell_Td'>Space Group</th>\
        ", false);
    this._setting_table.createHeader("\
            <th class='cryUI_Unit_Cell_Num_Td'>No.</th>\
            <th class='cryUI_Unit_Cell_Setting_Td'>Setting</th>\
        ", false);
    this._bMagnetic = false;
    this._selectedSystem = null;
    this._selectedSpaceGroup = null;
    this._selectedSetting = null;
    crystalTableData.I = this;
    this._system_table.applySelectable(this.clickSystemData);
    this._space_group_table.applySelectable(this.clickSpaceGroupData);
    this._setting_table.applySelectable(this.clickSettingData);
    this._systemArray = [null, null, [0, 1], [2, 14], [15, 73], [74, 141], [142, 166], [167, 193], [194, 229]];
    this.addSystemData();
    let idx = 0;
    for (let elem of Array.prototype.slice.call(crystalTableData.I._system_table._div.getElementsByTagName('tr'))) {
      idx++;
      if (idx % 2 === 0) crystalTableData.I.applyColor(elem, false);else crystalTableData.I.applyColor(elem, true);
    }
    this.addSpaceGroupData();
    this.hideElement(this._space_group_table._div.getElementsByTagName('tr'), true);
    this.hideElement(this._space_group_table._div.getElementsByTagName('tr')[0], false);
  }

  /**
   * 시스템 테이블 추가
   * */
  addSystemData() {
    let sysData = SystemDef._defList;
    for (let data of Object.keys(sysData)) {
      this._system_table.appTable("\
                <td class='cryUI_Unit_Cell_Td'>" + data + "</td>\
                ");
    }

    // add mouse event listener => get selected
    let table = document.getElementById(this._name + "_System");
    if (table != null) {
      for (let i = 0; i < table.rows.length; i++) {
        for (let j = 0; j < table.rows[i].cells.length; j++) table.rows[i].cells[j].onmouseup = function () {
          crystalTableData.I.clickSystemData();
        };
      }
    }
  }

  /**
   * 시스템 테이블 클릭 시 처리
   * */
  clickSystemData() {
    let selected = crystalTableData.I._system_table.getSelected();
    if (selected.length !== 1) {
      crystalTableData.I._system_table.initSelect();
      crystalTableData.I._selectedSystem = null;
      return;
    } else {
      crystalTableData.I._selectedSystem = selected;
      crystalTableData.I._setting_table.clearAll();

      // 선택된 system data에 따라 space group row를 enable 혹은 disable 시킨다.
      let systemKey = crystalTableData.I._selectedSystem[0].innerText;
      let range = SystemDef._defList[systemKey]._range;
      let lattice = SystemDef._defList[systemKey]._enableLattice;
      if (range[0] !== -1) {
        crystalTableData.I.hideElement(crystalTableData.I._space_group_table._div.getElementsByTagName('tr'), true);
        crystalTableData.I.hideElement(Array.prototype.slice.call(crystalTableData.I._space_group_table._div.getElementsByTagName('tr'))[0], false);
        crystalTableData.I.hideElement(Array.prototype.slice.call(crystalTableData.I._space_group_table._div.getElementsByTagName('tr')).slice(range[0], range[1] + 1), false);
        let idx = 0;
        for (let elem of Array.prototype.slice.call(crystalTableData.I._space_group_table._div.querySelectorAll('tr:not([style*="display:none"])'))) {
          idx++;
          if (idx % 2 === 0) crystalTableData.I.applyColor(elem, false);else crystalTableData.I.applyColor(elem, true);
        }
      } else {
        if (systemKey === 'Custom' || systemKey === 'Molecule') {
          crystalTableData.I.hideElement(crystalTableData.I._space_group_table._div.getElementsByTagName('tr'), true);
          crystalTableData.I.hideElement(Array.prototype.slice.call(crystalTableData.I._space_group_table._div.getElementsByTagName('tr'))[0], false);
          let idx = 0;
          for (let elem of Array.prototype.slice.call(crystalTableData.I._space_group_table._div.querySelectorAll('tr:not([style*="display:none"])'))) {
            idx++;
            if (idx % 2 === 0) crystalTableData.I.applyColor(elem, false);else crystalTableData.I.applyColor(elem, true);
          }
        }
      }
      if (crystalTableData.I._selectedSpaceGroup) {
        crystalTableData.I._selectedSpaceGroup.removeClass('ui-selected');
        crystalTableData.I._selectedSpaceGroup = null;
      }
      if (crystalTableData.I._selectedSetting) {
        crystalTableData.I._selectedSetting.removeClass('ui-selected');
        crystalTableData.I._selectedSetting = null;
      }
      if (lattice) {
        $(crystalTableData.I._dlgEditData._input_a_length).attr("disabled", !lattice._enableA);
        $(crystalTableData.I._dlgEditData._input_b_length).attr("disabled", !lattice._enableB);
        $(crystalTableData.I._dlgEditData._input_c_length).attr("disabled", !lattice._enableC);
        $(crystalTableData.I._dlgEditData._input_alpha).attr("disabled", !lattice._enableAlpha);
        $(crystalTableData.I._dlgEditData._input_beta).attr("disabled", !lattice._enableBeta);
        $(crystalTableData.I._dlgEditData._input_gamma).attr("disabled", !lattice._enableGamma);
      }
    }
  }

  /**
   * 스페이스 그룹 클릭 시 처리
   * */
  clickSpaceGroupData() {
    if (crystalTableData.I._selectedSystem === null) {
      crystalTableData.I._selectedSpaceGroup = null;
      crystalTableData.I._selectedSetting = null;
      alert("Please Select System Category");
      return;
    }
    let selected = crystalTableData.I._space_group_table.getSelected();
    $(selected[0]).attr("disable");
    if (selected.length !== 1 || $(selected[0]).attr("disabled")) {
      crystalTableData.I._space_group_table.initSelect();
      crystalTableData.I._selectedSpaceGroup = null;
      return;
    } else {
      crystalTableData.I._selectedSpaceGroup = selected;
      if (crystalTableData.I._selectedSetting) {
        crystalTableData.I._selectedSetting.removeClass('ui-selected');
        crystalTableData.I._selectedSetting = null;
      }

      // clear all setting data
      crystalTableData.I._setting_table.clearAll();

      // add updated setting data
      crystalTableData.I.addSettingData();
      let idx = 0;
      for (let elem of Array.prototype.slice.call(crystalTableData.I._setting_table._div.querySelectorAll('tr:not([style*="display:none"])'))) {
        idx++;
        if (idx % 2 === 0) crystalTableData.I.applyColor(elem, false);else crystalTableData.I.applyColor(elem, true);
      }
    }
    crystalTableData.I._selectedSystem.addClass("ui-selected");
  }

  /**
   * 세팅 데이터 클릭 시 처리
   * */
  clickSettingData() {
    if (crystalTableData.I._selectedSystem === null || crystalTableData.I._selectedSpaceGroup === null) {
      crystalTableData.I._selectedSetting = null;
      if (crystalTableData.I._selectedSystem === null) alert("Please Select System Category");
      if (crystalTableData.I._selectedSpaceGroup === null) alert("Please Select Space Group Category");
      return;
    }
    crystalTableData.I._selectedSystem.addClass("ui-selected");
    crystalTableData.I._selectedSpaceGroup.addClass("ui-selected");
    let selected = crystalTableData.I._setting_table.getSelected();
    if (selected.length !== 1) {
      crystalTableData.I._setting_table.initSelect();
      crystalTableData.I._selectedSetting = null;
      return;
    } else {
      crystalTableData.I._selectedSetting = selected;
      let settingKey, lattice, enableLattice;
      if (crystalTableData.I._mode) {
        settingKey = crystalTableData.I._selectedSetting[0].getElementsByClassName('cryUI_Unit_Cell_Setting_Td')[0].innerText;
        lattice = SettingDef._defOnList[settingKey]._lattice;
        enableLattice = SettingDef._defOnList[settingKey]._enableLattice;
      } else {
        settingKey = crystalTableData.I._selectedSetting[0].getElementsByClassName('cryUI_Unit_Cell_Setting_Td')[0].innerText;
        lattice = SettingDef._defOffList[settingKey]._lattice;
        enableLattice = SettingDef._defOffList[settingKey]._enableLattice;
      }
      if (lattice) {
        crystalTableData.I._dlgEditData._input_a_length.value = lattice._a;
        crystalTableData.I._dlgEditData._input_b_length.value = lattice._b;
        crystalTableData.I._dlgEditData._input_c_length.value = lattice._c;
        crystalTableData.I._dlgEditData._input_alpha.value = lattice._alpha;
        crystalTableData.I._dlgEditData._input_beta.value = lattice._beta;
        crystalTableData.I._dlgEditData._input_gamma.value = lattice._gamma;
      }
      if (enableLattice) {
        $(crystalTableData.I._dlgEditData._input_a_length).attr("disabled", !enableLattice._enableA);
        $(crystalTableData.I._dlgEditData._input_b_length).attr("disabled", !enableLattice._enableB);
        $(crystalTableData.I._dlgEditData._input_c_length).attr("disabled", !enableLattice._enableC);
        $(crystalTableData.I._dlgEditData._input_alpha).attr("disabled", !enableLattice._enableAlpha);
        $(crystalTableData.I._dlgEditData._input_beta).attr("disabled", !enableLattice._enableBeta);
        $(crystalTableData.I._dlgEditData._input_gamma).attr("disabled", !enableLattice._enableGamma);
      }
    }
  }

  /**
   * 스페이스 그룹 데이터 추가
   * */
  addSpaceGroupData() {
    let idx = 0;
    for (let data of Object.keys(SpaceGroupDef._defList)) {
      idx++;
      this._space_group_table.appTable("\
                <td class='cryUI_Unit_Cell_Num_Td'>" + idx + "</td>\
                <td class='cryUI_Unit_Cell_Space_Group_Td'>" + data + "<td>\
                ");
    }
  }

  /**
   * 세팅 데이터 추가
   * */
  addSettingData() {
    if (!crystalTableData.I._selectedSystem || !crystalTableData.I._selectedSpaceGroup) {
      return;
    }
    let currentKey = crystalTableData.I._selectedSpaceGroup[0].getElementsByClassName('cryUI_Unit_Cell_Space_Group_Td')[0].innerText;
    let idx = 0;
    if (this._mode) {
      for (const settingData of Object.entries(SettingDef._defOnList)) {
        if (settingData[1]._spaceGroupName === currentKey) {
          idx++;
          this._setting_table.appTable("\
                    <td class='cryUI_Unit_Cell_Num_Td'>" + idx + "</td>\
                    <td class='cryUI_Unit_Cell_Setting_Td'>" + settingData[0] + "</td>");
        }
      }
    } else {
      for (const settingData of Object.entries(SettingDef._defOffList)) {
        if (settingData[1]._spaceGroupName === currentKey) {
          idx++;
          this._setting_table.appTable("\
                    <td class='cryUI_Unit_Cell_Num_Td'>" + idx + "</td>\
                    <td class='cryUI_Unit_Cell_Setting_Td'>" + settingData[0] + "</td>");
        }
      }
    }
  }

  /**
   * table row 선택 가능 여부 설정
   * @param {HTMLElement} elem 선택 대상 
   * @param {Boolean} bEnable 활성화 여부
   */
  enableElement(elem, bEnable = true) {
    if (bEnable) {
      $(elem).removeAttr("disabled");
      $(elem).css("opacity", 1.0);
    } else {
      $(elem).attr("disabled", true);
      $(elem).css("opacity", 0.4);
    }
  }

  /**
   * table row 감추기
   * @param {HTMLElement} elem 선택 대상
   * @param {Boolean} bHide 숨김 여부
   */
  hideElement(elem, bHide = false) {
    if (bHide) {
      $(elem).css("display", "none");
    } else {
      $(elem).css("display", "");
    }
  }

  /**
   * table row 색상 적용
   * @param {HTMLElement} elem 색상 적용 대상
   * @param {Boolean} bDark 어두운 색상 적용 여부
   */
  applyColor(elem, bDark = false) {
    if (bDark) {
      $(elem).css("background-color", "#a1a1a1");
    } else {
      $(elem).css("background-color", "transparent");
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditDataDialog.js










/**
 * 메인 메뉴의 [Edit] - [Edit Data] 다이얼로그 클래스
 *
 * @class crystalEditDataDialog
 */
class crystalEditDataDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem EditDataDialog가 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    this._tabsEdit = document.getElementById(name + "_edit_data_Tabs");
    // this._div_tab1 = document.getElementById(name + "_edit_data_Tab1");
    this._div_tab2 = document.getElementById(name + "_edit_data_Tab2");
    this._div_tab3 = document.getElementById(name + "_edit_data_Tab3");
    this._div_tab4 = document.getElementById(name + "_edit_data_Tab4");
    this._div_tab5 = document.getElementById(name + "_edit_data_Tab5");
    crystalEditDataDialog.I = this;
    this._input_cs_name = document.getElementById(name + "_cs_name");
    this._input_cs_pos_x = document.getElementById(name + "_cs_pos_x");
    this._input_cs_pos_y = document.getElementById(name + "_cs_pos_y");
    this._input_cs_pos_z = document.getElementById(name + "_cs_pos_z");
    this._input_cs_dir_x = document.getElementById(name + "_cs_dir_x");
    this._input_cs_dir_y = document.getElementById(name + "_cs_dir_y");
    this._input_cs_dir_z = document.getElementById(name + "_cs_dir_z");
    this._input_a_length = document.getElementById(name + "_a_length");
    this._input_b_length = document.getElementById(name + "_b_length");
    this._input_c_length = document.getElementById(name + "_c_length");
    this._input_alpha = document.getElementById(name + "_alpha");
    this._input_beta = document.getElementById(name + "_beta");
    this._input_gamma = document.getElementById(name + "_gamma");
    this._input_su_a_length = document.getElementById(name + "_su_a_length");
    this._input_su_b_length = document.getElementById(name + "_su_b_length");
    this._input_su_c_length = document.getElementById(name + "_su_c_length");
    this._input_su_alpha = document.getElementById(name + "_su_alpha");
    this._input_su_beta = document.getElementById(name + "_su_beta");
    this._input_su_gamma = document.getElementById(name + "_su_gamma");
    this._div_system_table = document.getElementById(name + "_edit_unit_cell_system_table");
    this._div_space_group_table = document.getElementById(name + "_edit_unit_cell_space_group_table");
    this._div_setting_table = document.getElementById(name + "_edit_unit_cell_setting_table");
    this._system_table = new crystalTable(this._name, this._app, this._div_system_table, "System");
    this._space_group_table = new crystalTable(this._name, this._app, this._div_space_group_table, "Space_Group");
    this._setting_table = new crystalTable(this._name, this._app, this._div_setting_table, "Setting");
    this._crystalTableData = new crystalTableData(name, this);
    this._div_blank_left = document.getElementById(name + "_edit_strcture_blank_left");
    this._div_info = document.getElementById(name + "_edit_structure_info");
    this._div_inner_1_info = document.getElementById(name + "_edit_structure_inner_1_info");
    this._div_inner_2_info = document.getElementById(name + "_edit_structure_inner_2_info");
    this._div_inner_3_info = document.getElementById(name + "_edit_structure_inner_3_info");
    this._div_blank_right = document.getElementById(name + "_edit_structure_blank_right");
    this._div_table = document.getElementById(name + "_edit_structure_table");
    $(this._div_table).css("table-layout", "fixed");
    $(this._div_table).css("overflow", "auto");
    this._div_modify = document.getElementById(name + "_edit_structure_modify");
    this._div_info_area = document.getElementById(name + "_edit_structure_info_area");
    this._div_table_area = document.getElementById(name + "_edit_structure_table_area");
    this._div_import_area = document.getElementById(name + "_edit_structure_import_area");
    this._div_etc_area = document.getElementById(name + "_edit_structure_etc_area");
    this._div_import_text = document.getElementById(name + "_edit_structure_import_text");
    this._div_atomTable_area = document.getElementById(name + "_edit_structure_table_area");
    this._div_atomTable = document.getElementById(name + "_edit_structure_table");
    this._atomTable = new crystalTable(this._name, this._app, this._div_atomTable, "atomTable");
    this._atomTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Atom</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Label</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>x</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>y</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>z</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Occ.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>U</th>\
        ", false);

    // 버튼 가져와서 event 처리 붙이기
    this._div_atomTable_btn_area = document.getElementById(name + "_atom_table_btn_area");
    this._btnNewAtom = document.getElementById(name + "_new_atom_btn");
    this._btnNewFromTxt = document.getElementById(name + "_new_atom_from_txt_btn");
    this._btnDeleteAtom = document.getElementById(name + "_delete_atom_btn");
    this._btnClearAtom = document.getElementById(name + "_clear_atom_btn");
    this._btnSymbol = document.getElementById(name + "_atom_symbol_btn");
    this._div_table_objs = document.getElementById(name + "_objects_table");
    this._btnImport = document.getElementById(name + "_import_atom_btn");
    this._btnNewShape = document.getElementById(name + "_new_shape_btn");
    this._btnDeleteShape = document.getElementById(name + "_delete_shape_btn");
    this._btnClearShape = document.getElementById(name + "_clear_shape_btn");
    this._selectedShapeColor = [1, .5, 0];
    this._selectedCatomColor = null;
    this._bModified = false;
    this._bModifiedUnitcell = false;
    this._div_shapeTable = document.getElementById(name + "_edit_crystal_shape_table");
    this._shapeTable = new crystalTable(this._name, this._app, this._div_shapeTable, "shapeTable");
    this._shapeTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>h</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>k</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>l</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>d(A)</th>\
        ", false);

    /*
    <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>color</th>\
    <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>sym.</th>\
    */

    $(this._div_shapeTable).css("table-layout", "fixed");
    $(this._div_shapeTable).css("overflow", "auto");
    $(this._btnNewAtom).button();
    $(this._btnNewFromTxt).button();
    $(this._btnDeleteAtom).button();
    $(this._btnClearAtom).button();
    $(this._btnSymbol).button();
    $(this._btnImport).button();
    $(this._btnNewShape).button();
    $(this._btnDeleteShape).button();
    $(this._btnClearShape).button();
    $(this._btnNewAtom).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      crystalEditDataDialog.I.UpdateVariable();
      if (!crystalEditDataDialog.I._app._csManager._cs) {
        crystalEditDataDialog.I._app._csManager._cs = new CStructure();
        let a = crystalEditDataDialog.I._variable["a"];
        let b = crystalEditDataDialog.I._variable["b"];
        let c = crystalEditDataDialog.I._variable["c"];
        let abc = crystalEditDataDialog.I._variable["abc"];
        let unitcell = crystalEditDataDialog.I._app._csManager._cs._unitcell;
        unitcell.set(abc[0], abc[1], abc[2], a, b, c);
        crystalEditDataDialog.I._app._csManager._cs._unitcell.set(abc[0], abc[1], abc[2], a, b, c);
        crystalEditDataDialog.I._app._3dRender.RebuildAxisGeom(unitcell._axis._va, unitcell._axis._vb, unitcell._axis._vc);
      }
      let symbol = crystalEditDataDialog.I._variable["atom"];
      let id = crystalEditDataDialog.I._variable["id"];
      let label = crystalEditDataDialog.I._variable["label"];
      let x = crystalEditDataDialog.I._variable["x"];
      let y = crystalEditDataDialog.I._variable["y"];
      let z = crystalEditDataDialog.I._variable["z"];
      let occ = crystalEditDataDialog.I._variable["occ"];
      let su_pos = [crystalEditDataDialog.I._variable["su_x"], crystalEditDataDialog.I._variable["su_y"], crystalEditDataDialog.I._variable["su_z"]];
      let u_arr = [crystalEditDataDialog.I._variable["u11"], crystalEditDataDialog.I._variable["u22"], crystalEditDataDialog.I._variable["u33"], crystalEditDataDialog.I._variable["u12"], crystalEditDataDialog.I._variable["u13"], crystalEditDataDialog.I._variable["u23"]];
      let anisoType = crystalEditDataDialog.I._variable["anisoType"];
      let isoType = crystalEditDataDialog.I._variable["isoType"];
      let u = crystalEditDataDialog.I._variable["u"];
      let color = crystalEditDataDialog.I._variable["catomColor"];
      let atom = crystalEditDataDialog.I.createAtom(crystalEditDataDialog.I._app._csManager._cs.assignAtomIdx(), id, label, x, y, z, occ, su_pos, anisoType, u_arr, isoType, u, color);
      crystalEditDataDialog.I._app._csManager._cs.addAtom(atom);
      crystalEditDataDialog.I.AddAtomToTable(atom._idx, id, symbol, label, x, y, z, occ, u);
      crystalEditDataDialog.I.SetTab4Size();

      // 마지막 추가된 row 선택되도록 설정
      crystalEditDataDialog.I._atomTable.initSelect();
      crystalEditDataDialog.I._atomTable.selectLast();

      // input 창 업데이트
      crystalEditDataDialog.I.UpdateSelect();
    });
    $(this._btnNewFromTxt).click(function (event) {
      // txt input dialog 띄우기
      crystalEditDataDialog.I._app._dlgInputText.ShowDialog();
    });
    $(this._btnDeleteAtom).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      let atomRows = crystalEditDataDialog.I._atomTable.getSelected();
      for (let atomRow of atomRows) {
        rayLog(3, $(atomRow).text()[0]);
        let idx = parseInt($(atomRow).find("#" + crystalEditDataDialog.I._app._name + "_atom_idx").html());
        let atom = crystalEditDataDialog.I._app._csManager._cs.getAtomByIdx(idx);
        crystalEditDataDialog.I._app._csManager._cs.removeAtom(atom);
      }
      crystalEditDataDialog.I._atomTable.deleteSelected(); // table 상의 선택된 atom row를 모두 삭제한다.

      crystalEditDataDialog.I.SetTab4Size();
      crystalEditDataDialog.I._app._dlgEditBond.UpdateTable();
      if (crystalEditDataDialog.I._atomTable.getAllRow().length === 0) crystalEditDataDialog.I.DisableInput(true);
      crystalEditDataDialog.I._atomTable.updateTable();
    });
    $(this._btnClearAtom).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      // 확인 다이얼로그를 띄운다.
      crystalEditDataDialog.I._app._dlgEditDataConfirm.ShowDialog();
    });

    // dialog가 열리도록 설정 dialog div elem은 app에 부착하도록 한다.
    $(this._btnSymbol).click(function (event) {
      crystalEditDataDialog.I._app.MenuPeriodic();
    });
    $(this._btnImport).click(function (event) {});
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxWidth: 680,
      maxHeight: 555,
      width: 680,
      height: 555,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Edit Data",
      buttons: {
        "OK": function () {
          if (crystalEditDataDialog.I._bModified) {
            crystalEditDataDialog.I._app._bModified = true;
            crystalEditDataDialog.I._app._dlgEditVectors.RestoreAddedVectorFromCS();
            crystalEditDataDialog.I._app._csManager.AddUndo();
          }
          crystalEditDataDialog.I.OnApply();
          crystalEditDataDialog.I.CloseDialog();
        },
        "Close": function () {
          crystalEditDataDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalEditDataDialog.I._show = false;
        crystalEditDataDialog.I._app.UpdateUI();
      },
      open: function () {
        crystalEditDataDialog.I.SetTabSize();
      }
    });
    $(this._tabsEdit).tabs({
      active: 0
    });

    // 입력란 모두 가져오기
    this._input_no = document.getElementById(name + "_tr_no");
    this._input_pos_x = document.getElementById(name + "_atom_pos_x");
    this._input_pos_y = document.getElementById(name + "_atom_pos_y");
    this._input_pos_z = document.getElementById(name + "_atom_pos_z");
    this._input_symbol = document.getElementById(name + "_atom_symbol");
    this._input_label = document.getElementById(name + "_atom_label");
    this._input_occ = document.getElementById(name + "_atom_occ");
    this._input_u = document.getElementById(name + "_atom_u");
    this._input_charge = document.getElementById(name + "_atom_charge");
    this._input_su_x = document.getElementById(name + "_su_x");
    this._input_su_y = document.getElementById(name + "_su_y");
    this._input_su_z = document.getElementById(name + "_su_z");
    this._input_U11 = document.getElementById(name + "_U11");
    this._input_U22 = document.getElementById(name + "_U22");
    this._input_U33 = document.getElementById(name + "_U33");
    this._input_U12 = document.getElementById(name + "_U12");
    this._input_U13 = document.getElementById(name + "_U13");
    this._input_U23 = document.getElementById(name + "_U23");
    this._label_u = document.getElementById(name + "_u_label");
    this._label_U11 = document.getElementById(name + "_U11_label");
    this._label_U22 = document.getElementById(name + "_U22_label");
    this._label_U33 = document.getElementById(name + "_U33_label");
    this._label_U12 = document.getElementById(name + "_U12_label");
    this._label_U13 = document.getElementById(name + "_U13_label");
    this._label_U23 = document.getElementById(name + "_U23_label");
    this._input_h = document.getElementById(name + "_miller_indice_h");
    this._input_k = document.getElementById(name + "_miller_indice_k");
    this._input_l = document.getElementById(name + "_miller_indice_l");
    this._input_d = document.getElementById(name + "_distance_from_origin_A");
    this._input_color_background = document.getElementById(name + "_shape_color_background");
    this._input_alpha_background = document.getElementById(name + "_shape_alpha_background");
    $(this._input_color_background).css("background-color", "#" + $(this._input_color_background).val());
    this._input_catom_color = document.getElementById(name + "_catom_color_picker");
    $(this._input_symbol).attr("disabled", true);

    // on change event listener 달기
    $(this._input_a_length).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_b_length).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_c_length).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_alpha).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_beta).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_gamma).on("input", function () {
      crystalEditDataDialog.I._bModifiedUnitcell = true;
    });
    $(this._input_pos_x).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_pos_y).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_pos_z).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_symbol).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_label).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_occ).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_u).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_su_x).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_su_y).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_su_z).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U11).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U22).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U33).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U12).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U13).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_U23).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._selectedCatomColor).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedAtom();
    });
    $(this._input_h).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    $(this._input_k).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    $(this._input_l).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    $(this._input_d).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    $(this._selectedShapeColor).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    $(this._input_alpha_background).on("input", function () {
      crystalEditDataDialog.I.ChangeSelectedShape();
    });
    this.DisableInput(true);
    this.DisableAnisotropicInput(true);
    $(this._input_color_background).colorpicker({
      modal: true,
      buttonColorize: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
        crystalEditDataDialog.I.OnChangeColorBackground([formatted.rgb["r"], formatted.rgb["g"], formatted.rgb["b"]]);
        crystalEditDataDialog.I.ChangeSelectedShape();
      }
    });
    $(this._input_catom_color).colorpicker({
      modal: true,
      buttonColorize: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
        crystalEditDataDialog.I.OnChangeCAtomColor([formatted.rgb["r"], formatted.rgb["g"], formatted.rgb["b"]]);
        crystalEditDataDialog.I.ChangeSelectedAtom();
      }
    });
    $(this._btnNewShape).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      let id = crystalEditDataDialog.I._app._csManager._cs.assignShapeId();
      let h = parseFloat($(crystalEditDataDialog.I._input_h).val());
      let k = parseFloat($(crystalEditDataDialog.I._input_k).val());
      let l = parseFloat($(crystalEditDataDialog.I._input_l).val());
      let d = parseFloat($(crystalEditDataDialog.I._input_d).val());
      if (h === 0 && k === 0 && l === 0) {
        alert("hkl can not be all zero");
        return;
      }
      let color = crystalEditDataDialog.I._selectedShapeColor;
      let alpha = parseFloat($(crystalEditDataDialog.I._input_alpha_background).val());
      crystalEditDataDialog.I.AddShapeToTable(id, h, k, l, d, color, alpha, true);
      let plane = new Plane_Plane();
      let lattice_axis = crystalEditDataDialog.I._app._csManager._cs.getLatticeAxis();
      plane.setMillerIndices(lattice_axis, h, k, l, d);
      plane.setColor(color[0], color[1], color[2], alpha);
      plane._id = id;
      crystalEditDataDialog.I._app._csManager._cs.addPlane(plane);
      crystalEditDataDialog.I._app._dlgEditData.generateStructure();
      crystalEditDataDialog.I._shapeTable.initSelect();
      crystalEditDataDialog.I._shapeTable.selectLast();
    });
    $(this._btnDeleteShape).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      let shapeRows = crystalEditDataDialog.I._shapeTable.getSelected();
      for (let shapeRow of shapeRows) {
        let id = parseInt($(shapeRow).find("#" + crystalEditDataDialog.I._app._name + "_shape_no").html());
        crystalEditDataDialog.I._app._csManager._cs.removePlaneById(id);
      }
      crystalEditDataDialog.I._shapeTable.deleteSelected();
      crystalEditDataDialog.I._app._dlgEditData.generateStructure();
      crystalEditDataDialog.I._shapeTable.updateTable();
    });
    $(this._btnClearShape).click(function (event) {
      crystalEditDataDialog.I._bModified = true;
      crystalEditDataDialog.I._app._csManager._cs.clearPlane();
      crystalEditDataDialog.I._app._dlgEditData._shapeTable.clearAll();
      crystalEditDataDialog.I._app._dlgEditData.generateStructure();
    });
    this._selectAnisotropic = document.getElementById(name + "_atom_anisotropic");
    this._selectIsotropic = document.getElementById(name + "_atom_isotropic");
    $(this._selectAnisotropic).selectmenu({
      width: '80px',
      change: function (event, ui) {
        crystalEditDataDialog.I.OnChangeAnisotropic(crystalEditDataDialog.I._selectAnisotropic.value);
      }
    });
    $(this._selectIsotropic).selectmenu({
      width: '60px',
      change: function (event, ui) {
        crystalEditDataDialog.I.OnChangeIsotropic(crystalEditDataDialog.I._selectIsotropic.value);
      }
    });
  }

  /**
   * editDataDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;

    // Tab1 - Phase
    ihtml[idx] = "<div id='" + name + "_edit_data_Tabs'>";
    idx++;
    ihtml[idx] = "<ul>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_data_Tab4' class='cryUI_TabBtn'>Info</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_data_Tab2' class='cryUI_TabBtn'>Unit Cell</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_data_Tab3' class='cryUI_TabBtn'>CStructure</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_data_Tab5' class='cryUI_TabBtn'>Crystal Shape</a></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    ///////////////////// [Tab4 - Structure Parameters] /////////////////////
    ihtml[idx] = "<div id='" + name + "_edit_data_Tab4' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>CStructure Info</legend>";
    idx++;
    ihtml[idx] = "<table class='cryUI_Lattice_Wrapper_Table'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Lattice_Left_Blank'></div>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>name</td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td><td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='text' id='" + name + "_cs_name'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>pos x</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>pos y</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>pos z</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>dir x</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>dir y</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>dir z</td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_pos_x' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_pos_y' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_pos_z' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_dir_x' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_dir_y' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_cs_dir_z' value=0></td></tr>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    //////////////////////////////////////////////////////////////////////////

    // Tab2 - Unit Cell
    ihtml[idx] = "<div id='" + name + "_edit_data_Tab2' class='cryUI_Tabs'>";
    idx++;

    // Symmetry

    // A area
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_Symmetry' id='" + name + "_edit_unit_cell_symmetry'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Symmetry</legend>";
    idx++;

    // A' area
    /*
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_Magnetic_Structure' id='" + name + "_edit_unit_cell_magnetic_structre'>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_magnetic_structure_check'>Magnetic structure</label>";
    idx++;
    ihtml[idx] = "<input id='" + name + "_magnetic_structure_check' type='checkbox'></input>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */

    // A'' area
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_System_Space_Group_Setting' id='" + name + "_edit_unit_cell_system_space_group_setting'>";
    idx++;

    // A''-1 area
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_System' id='" + name + "_edit_unit_cell_system_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // A''-2 area
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_Space_Group' id='" + name + "_edit_unit_cell_space_group_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // A''-3 area
    ihtml[idx] = "<div class='cryUI_Edit_Unit_Cell_Setting' id='" + name + "_edit_unit_cell_setting_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div></fieldset></div>";
    idx++;

    // B Area
    // Lattice Parameters
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Lattice parameters</legend>";
    idx++;
    ihtml[idx] = "<table class='cryUI_Lattice_Wrapper_Table'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Lattice_Left_Blank'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>a(?)</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>b(?)</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>c(?)</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>α(?)</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>β(?)</td><td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'>γ(?)</td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_Big_Td_With_Margin'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_a_length' value=" + cryst.Unitcell.a + "></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_b_length' value=" + cryst.Unitcell.b + "></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_c_length' value=" + cryst.Unitcell.c + "></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_alpha' value=" + cryst.Unitcell.alpha + "></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_beta' value=" + cryst.Unitcell.beta + "></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td' type='number' id='" + name + "_gamma' value=" + cryst.Unitcell.gamma + "></td></tr>";
    idx++;

    /*
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>s.u.:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_a_length'></td><td class='cryUI_Big_Td'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_b_length'></td><td class='cryUI_Big_Td'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_c_length'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_alpha'></td><td class='cryUI_Big_Td'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_beta'></td><td class='cryUI_Big_Td'><input class='cryUI_Big_Td' type='number' id='" + name + "_su_gamma'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    */
    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</fieldset></div>";
    idx++;

    // [Tab - CStructure]
    ihtml[idx] = "<div id='" + name + "_edit_data_Tab3' class='cryUI_Tabs'><fieldset>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Info_Area' id='" + name + "_edit_structure_info_area'>";
    idx++;

    // A 공간
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Blank_Left' id='" + name + "_edit_strcture_blank_left'></div>";
    idx++;

    // B 공간
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Info' id='" + name + "_edit_structure_info'>";
    idx++;
    /*
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Inner_1_Info' id='" + name + "_edit_structure_inner_1_info'>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>Atomic displacement parameter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>";
    idx++;
        ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><label for='" + name + "_atom_anisotropic'>Anisotropic:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><select  id='" + name + "_atom_anisotropic'>";
    idx++;
    ihtml[idx] = "<option value='none'>None</option>";
    idx++;
    ihtml[idx] = "<option value='u'>U</option>";
    idx++;
    ihtml[idx] = "<option value='beta'>beta</option>";
    idx++;
    ihtml[idx] = "</select>";
    idx++;
    ihtml[idx] = "</td>";
    idx++;
    ihtml[idx] = "&nbsp;&nbsp;&nbsp;&nbsp;";
     idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><label for='" + name + "_atom_isotropic'>Isotropic:</label></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><select id='" + name + "_atom_isotropic'>";
    idx++;
    ihtml[idx] = "<option value='u'>U</option>";
    idx++;
    ihtml[idx] = "<option value='b'>B</option>";
    idx++;
    ihtml[idx] = "</select>";
    idx++;
    ihtml[idx] = "</td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */

    ihtml[idx] = "<div class='cryUI_Edit_Structure_Inner_2_Info' id='" + name + "_edit_structure_inner_2_info'>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>No:</td><td><input type='number' class='cryUI_Big_Td_With_Margin' id='" + name + "_tr_no'>&nbsp;&nbsp;&nbsp;&nbsp;</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><button id='" + name + "_atom_symbol_btn' class='cryUI_Normal_Btn'>Symbol...</button></td><td><input type='text' id='" + name + "_atom_symbol' class='cryUI_Big_Td_With_Margin'>&nbsp;&nbsp;&nbsp;&nbsp;</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>Label:</td><td><input type='text' id='" + name + "_atom_label' class='cryUI_Big_Td_With_Margin'>&nbsp;&nbsp;&nbsp;&nbsp;</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>Charge:</td>";
    idx++;
    ihtml[idx] = "<td><input class='cryUI_Big_Td_With_Margin' type='number' value=0 step='1' id='" + name + "_atom_charge'>&nbsp;&nbsp;&nbsp;&nbsp;</td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Inner_3_Info' id='" + name + "_edit_structure_inner_3_info'>";
    idx++;
    ihtml[idx] = "<table>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>x:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1' class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_atom_pos_x'></td><td class='cryUI_Big_Td_With_Margin'>y:</td><td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_atom_pos_y'></td><td class='cryUI_Big_Td_With_Margin'>z:</td><td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_atom_pos_z'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>Occ:</td><td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=1 id='" + name + "_atom_occ'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    /*
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>s.u.(x):</td><td><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_su_x'></td><td class='cryUI_Big_Td_With_Margin'>s.u.(y):</td><td><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_su_y'></td><td class='cryUI_Big_Td_With_Margin'>s.u.(z):</td><td><input type='number' step='0.1' class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_su_z'></td>"
    idx++;
    */
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_u_label'>U:</td><td><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_atom_u'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'>Color:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input type='text' class='cryUI_Normal_Td_Left' id='" + name + "_catom_color_picker'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;

    /*
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U11_label'>U11:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U11'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U22_label'>U22:</td><td><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U22'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U33_label'>U33:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin'><input type='number' step='0.1'  class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U33'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
     */

    /*
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U12_label'>U12:</td><td><input type='number' step='0.1' class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U12'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U13_label'>U13:</td><td><input type='number' step='0.1' class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U13'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Big_Td_With_Margin' id='" + name + "_U23_label'>U23:</td><td><input type='number' step='0.1' class='cryUI_Normal_Td_Left' value=0.0 id='" + name + "_U23'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    */

    ihtml[idx] = "</table>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // C 공간
    /*
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Blank_Right' id='" + name + "_edit_structure_blank_right'></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */

    // D,E 공간

    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table_Area' id='" + name + "_edit_structure_table_area'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table' id='" + name + "_edit_structure_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Modify' id='" + name + "_edit_structure_modify'>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_new_atom_btn'>New</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_new_atom_from_txt_btn'>Txt</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_delete_atom_btn'>Delete</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_clear_atom_btn'>Clear</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // F,G 공간
    /*
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Import_Area' id='" + name + "_edit_structure_import_area'>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_edit_structure_import_text' class='cryUI_Edit_Structure_Import_Text'>";
    idx++;
    ihtml[idx] = "<input type='text' class='cryUI_Edit_Structure_Import_Text'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_edit_structure_import_btn' class='cryUI_Edit_Structure_Import_Btn'>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Normal_Thick_Btn ui - button ui - widget ui - corner - all' id='" + name + "_import_atom_btn'>Import</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */
    /*
    // Link / Right Bottom 공간
    ihtml[idx] = "<div></div>";
    idx++;
    */

    ihtml[idx] = "</fieldset></div>";
    idx++;

    ////////////////////////////////////////////

    // Tab4 - Volumetric Data
    /*
    ihtml[idx] = "<div id='" + name + "_edit_data_Tab4' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    */

    // Tab5 - Crystal Shape
    ihtml[idx] = "<div id='" + name + "_edit_data_Tab5' class=cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<table class='cryUI_Lattice_Wrapper_Table'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Lattice_Left_Blank'>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Miller indices (hkl):</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_miller_indice_h' value=1></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_miller_indice_k' value=0></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_miller_indice_l' value=0></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Distance from origin:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_distance_from_origin_A' value=1></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Color (RGB):</td>";
    idx++;
    // color picker 추가하기
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Normal_Td' type='text' id='" + name + "_shape_color_background' value='ff7b00'></td>";
    idx++;
    // ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Normal_Td' type='number' id='" + name + "_shape_alpha_background' value=255 onkeyup='if (value < 0) value = 0; if (value > 255) value=255;'></td>";
    // idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    // table
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table_Area' id='" + name + "_edit_crystal_shape_area'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table' id='" + name + "_edit_crystal_shape_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Modify' id='" + name + "_edit_shape_modify'>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_new_shape_btn'>New</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_delete_shape_btn'>Delete</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_clear_shape_btn'>Clear</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }
  OnChangeAnisotropic(value) {
    let selected = this._atomTable.getSelected();
    let idx = parseInt($(selected[0]).find("#" + this._name + "_atom_idx").html());
    let catom = this._app._csManager._cs.getAtomByIdx(idx);
    switch (value) {
      case "none":
        // disable input
        crystalEditDataDialog.I.DisableAnisotropicInput();
        if (catom) catom._anisotype = -1;
        break;
      case "u":
        if (crystalEditDataDialog.I._atomTable.getSelected().length === 1) {
          // change input label
          crystalEditDataDialog.I.DisableAnisotropicInput(false);
          $(crystalEditDataDialog.I._label_U11).html("U11:");
          $(crystalEditDataDialog.I._label_U22).html("U22:");
          $(crystalEditDataDialog.I._label_U33).html("U33:");
          $(crystalEditDataDialog.I._label_U12).html("U12:");
          $(crystalEditDataDialog.I._label_U13).html("U13:");
          $(crystalEditDataDialog.I._label_U23).html("U23:");
          if (catom._anisoU.length === 6) {
            $(crystalEditDataDialog.I._input_U11).val(catom._anisoU[0]);
            $(crystalEditDataDialog.I._input_U22).val(catom._anisoU[1]);
            $(crystalEditDataDialog.I._input_U33).val(catom._anisoU[2]);
            $(crystalEditDataDialog.I._input_U12).val(catom._anisoU[3]);
            $(crystalEditDataDialog.I._input_U13).val(catom._anisoU[4]);
            $(crystalEditDataDialog.I._input_U23).val(catom._anisoU[5]);
          } else {
            $(crystalEditDataDialog.I._input_U11).val(0.0);
            $(crystalEditDataDialog.I._input_U22).val(0.0);
            $(crystalEditDataDialog.I._input_U33).val(0.0);
            $(crystalEditDataDialog.I._input_U12).val(0.0);
            $(crystalEditDataDialog.I._input_U13).val(0.0);
            $(crystalEditDataDialog.I._input_U23).val(0.0);
          }
          if (catom) catom._anisotype = 0;
        }
        break;
      case "beta":
        if (crystalEditDataDialog.I._atomTable.getSelected().length === 1) {
          // change input label
          crystalEditDataDialog.I.DisableAnisotropicInput(false);
          $(crystalEditDataDialog.I._label_U11).html("beta11:");
          $(crystalEditDataDialog.I._label_U22).html("beta22:");
          $(crystalEditDataDialog.I._label_U33).html("beta33:");
          $(crystalEditDataDialog.I._label_U12).html("beta12:");
          $(crystalEditDataDialog.I._label_U13).html("beta13:");
          $(crystalEditDataDialog.I._label_U23).html("beta23:");
          if (catom._anisoBeta.length === 6) {
            $(crystalEditDataDialog.I._input_U11).val(catom._anisoBeta[0]);
            $(crystalEditDataDialog.I._input_U22).val(catom._anisoBeta[1]);
            $(crystalEditDataDialog.I._input_U33).val(catom._anisoBeta[2]);
            $(crystalEditDataDialog.I._input_U12).val(catom._anisoBeta[3]);
            $(crystalEditDataDialog.I._input_U13).val(catom._anisoBeta[4]);
            $(crystalEditDataDialog.I._input_U23).val(catom._anisoBeta[5]);
          } else {
            $(crystalEditDataDialog.I._input_U11).val(0.0);
            $(crystalEditDataDialog.I._input_U22).val(0.0);
            $(crystalEditDataDialog.I._input_U33).val(0.0);
            $(crystalEditDataDialog.I._input_U12).val(0.0);
            $(crystalEditDataDialog.I._input_U13).val(0.0);
            $(crystalEditDataDialog.I._input_U23).val(0.0);
          }
          if (catom) catom._anisotype = 1;
        }
        break;
    }

    // 현재 선택된 atom row의 모드를 변경하여야 한다.
  }

  /**
   * Isotropic 옵션 변경 적용
   * @param {String} value u / b
   */
  OnChangeIsotropic(value) {
    let selected = this._atomTable.getSelected();
    let idx = parseInt($(selected[0]).find("#" + this._name + "_atom_idx").html());
    let catom = this._app._csManager._cs.getAtomByIdx(idx);
    let atomRows;
    switch (value) {
      case "u":
        // [미구현] : 테이블 header와 모든 데이터들을 바꿔야 한다.
        $(crystalEditDataDialog.I._label_u).html("U:");
        $(this._input_u).val(catom._isoU);
        this._atomTable.removeHeader();
        this._atomTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Atom</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Label</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>x</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>y</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>z</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Occ.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>U</th>", false);
        atomRows = this._atomTable.getAllRow();
        for (let atomRow of atomRows) {
          let idx = parseInt($(atomRow).find("#" + crystalEditDataDialog.I._app._name + "_atom_idx").html());
          let catom = crystalEditDataDialog.I._app._csManager._cs.getAtomByIdx(idx);
          $(atomRow).find("#" + crystalEditDataDialog.I._app._name + "_v").html(catom._isoU);
        }
        break;
      case "b":
        // [미구현] : 테이블 header와 모든 데이터들을 바꿔야 한다.
        $(crystalEditDataDialog.I._label_u).html("B:");
        $(this._input_u).val(catom._isoB);

        // remove header and create new one
        this._atomTable.removeHeader();
        this._atomTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Atom</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Label</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>x</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>y</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>z</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>Occ.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>B</th>", false);

        // get all row
        atomRows = this._atomTable.getAllRow();
        for (let atomRow of atomRows) {
          let idx = parseInt($(atomRow).find("#" + crystalEditDataDialog.I._app._name + "_atom_idx").html());
          let catom = crystalEditDataDialog.I._app._csManager._cs.getAtomByIdx(idx);
          $(atomRow).find("#" + crystalEditDataDialog.I._app._name + "_v").html(catom._isoB);
        }
        break;
    }

    // 현재 선택된 atom row의 모드를 변경하고 값을 초기화한다.
  }

  /**
   * 탭 사이즈 설정
   * */
  SetTabSize() {
    this.SetTab4Size();
  }

  /**
   * 탭 4 사이즈 설정
   * */
  SetTab4Size() {
    // B의 너비는 전체 너비에서 A, C를 뺀 너비다
    let div_info_w = $(this._div_info_area).width() - $(this._div_blank_left).width() - $(this._div_blank_right).width();
    this._div_info.style.width = div_info_w + "px";

    // B''의 높이는 B에서 B', B''를 뺀 높이다
    let div_info_h = $(this._div_info).height();
    this._div_inner_2_info.style.height = div_info_h - $(this._div_inner_1_info).height() - $(this._div_inner_3_info).height() + "px";

    // D의 너비는 전체 너비에서 E를 뺀 너비다
    let div_table_w = $(this._div_table_area).width() - $(this._div_modify).width() - 2;
    this._div_table.style.width = div_table_w + "px";

    // G의 너비는 전체 너비에서 F를 뺀 너비다

    // let div_import_text_w = $(this._div_import_area).width() - $(this._div_import_btn).width() - 30;
    // this._div_import_text.style.width = div_import_text_w + "px";
  }

  /**
   * EditDataDialog를 띄운다.
   */
  ShowDialog() {
    if (this._show) return;
    crystalEditDataDialog.I._app._csManager.SetPrev(crystalEditDataDialog.I._app._csManager._cs);

    // this.UpdateUI();
    this._dialog.dialog("open");
    this.SetTabSize();
    this._show = true;
  }

  /**
   * 다이얼로그 창을 닫는다.
   *
   * @memberof crystalEditDataDialog
   */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
    this._bModified = false;
    this._bModifiedUnitcell = false;
    this._app.UpdateUI();
  }

  /**
   * 현재 상황을 적용한다.
   * */
  OnApply() {
    let tabIdx = this.GetActiveTabIndex();
    this.UpdateVariable();
    switch (tabIdx) {
      case 1:
        // unitcell update

        let a = this._variable["a"];
        let b = this._variable["b"];
        let c = this._variable["c"];
        let abc = this._variable["abc"];
        if (!crystalEditDataDialog.I._app._csManager._cs) {
          crystalEditDataDialog.I._app._csManager._cs = new CStructure();
          let minx = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_min_x).val());
          let miny = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_min_y).val());
          let minz = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_min_z).val());
          let maxx = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_max_x).val());
          let maxy = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_max_y).val());
          let maxz = parseFloat($(crystalEditDataDialog.I._app._dlgBoundarySetting._input_max_z).val());
          crystaleditDataDialog.I._app._csManager._cs._boundary.set(new Vector3(minx, miny, minz), new Vector3(maxx, maxy, maxz));
        }
        let unitcell = crystalEditDataDialog.I._app._csManager._cs._unitcell;
        crystalEditDataDialog.I._app._csManager._cs._unitcell.set(abc[0], abc[1], abc[2], a, b, c);
        crystalEditDataDialog.I._app._csManager._cs._unitcell._axis.calculate();
        crystalEditDataDialog.I._app._3dRender.RebuildAxisGeom(unitcell._axis._va, unitcell._axis._vb, unitcell._axis._vc);
        break;
      case 0:
        let name = this._variable["name"];
        let pos_x = this._variable["pos_x"];
        let pos_y = this._variable["pos_y"];
        let pos_z = this._variable["pos_z"];
        let dir_x = this._variable["dir_x"];
        let dir_y = this._variable["dir_y"];
        let dir_z = this._variable["dir_z"];
        crystalEditDataDialog.I._app._csManager._cs._name = name;
        crystalEditDataDialog.I._app._csManager._cs._position.set(pos_x, pos_y, pos_z);
        crystalEditDataDialog.I._app._csManager._cs._direction.set(dir_x, dir_y, dir_z);
        break;
    }

    // 거리 각도 측정 삭제 호출
    crystalEditDataDialog.I._app._uiHandler.ClearAllMeasures();

    // generate structure
    // crystalEditDataDialog.I.UpdateRenderer();
    crystalEditDataDialog.I._app._dlgEditBond.UpdateRenderer();
    crystalEditDataDialog.I._app._property.UpdateUI();
    crystalEditDataDialog.I._app._dlgEditBond.UpdateTable();
    crystalEditDataDialog.I._app._dlgEditVectors._crystal_graphic_sites_tab.UpdateTable();
    crystalEditDataDialog.I._app._dlgEditVectors._individual_atom_tab.UpdateTable();
    if (crystalEditDataDialog.I._bModifiedUnitcell) {
      crystalEditDataDialog.I._app._3dRender._renderer.autofitCameraObjList([crystalEditDataDialog.I._app._csManager._cs.getMesh()], 100);
    }
    crystalEditDataDialog.I._app._property._propertyStyle.OnApply();
  }

  /**
   * Structure 테이블에 새로운 원자를 추가한다.
   *
   * @param {String} atom_name 원자명
   * @param {String} label_name 라벨
   * @param {Number} x x좌표
   * @param {Number} y y좌표
   * @param {Number} z z좌표
   * @param {Number} Occ Occ
   * @param {Number} v v
   * @memberof crystalEditDataDialog
   */
  AddAtomToTable(idx, id, atom_name, label_name, x, y, z, Occ, v) {
    let innerHTML = "\
            <td style='display:none' id='" + this._name + "_atom_idx'>" + idx + "</td>\
            <td style='display:none' class='atom_id cryUI_Text_Center' id='" + this._name + "_atom_id'>" + id + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_atom_name'>" + atom_name + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_label_name'>" + label_name + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_pos_x'>" + x + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_pos_y'>" + y + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_pos_z'>" + z + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_occ'>" + Occ + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_v'>" + v + "</td>";
    this._atomTable.appTable(innerHTML, true);
    $(this._atomTable.getAllRow()).last().on("click", function () {
      crystalEditDataDialog.I.UpdateSelect();
    });
  }

  /**
   * crystal shape를 테이블에 추가한다.
   * 
   * @param {Number} id crystal shape id
   * @param {Number} h miller index h
   * @param {Number} k miller index k
   * @param {Number} l miller index l
   * @param {Number} d distance
   * @param {Array} color color array
   * @param {Number} alpha alpha value
   * @param {Boolean} sym symmetry
   */
  AddShapeToTable(id, h, k, l, d, color, alpha, sym) {
    let innerHTML = "\
            <td id='" + this._name + "_shape_no' style='display:none'>" + id + "</td>\
            <td id='" + this._name + "_shape_no_" + id + "' style='display:none'></td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_h'>" + h + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_k'>" + k + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_l'>" + l + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_distance'>" + d + "</td>\
            ";
    /*
    <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_color'></td>\
    <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_shape_alpha' style='display:none'>" + alpha + "</td>\
    <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center'><input type='checkbox' id='" + this._name + "_shape_sym' checked='" + sym + "'></td>\
    */

    this._shapeTable.appTable(innerHTML, true);
    /*
    $("#" + this._name + "_shape_no_" + id).parent().find("#" + this._name + "_shape_color").css("background-color", '#' + crystalVariable.HTMLColorRGB(color));
    */

    $(this._shapeTable.getAllRow()).last().on("click", function () {
      crystalEditDataDialog.I.UpdateSelect();
    });
  }

  /**
   * 렌더러에 새로운 원자를 추가한다.
   *
   * @param {String} atom_name 원자명
   * @param {String} label_name 라벨
   * @param {Number} x x좌표
   * @param {Number} y y좌표
   * @param {Number} z z좌표
   * @param {Number} Occ Occ
   * @param {Number} v v
   * @memberof crystalEditDataDialog
   */
  AddAtomToRenderer(id, label_name, x, y, z, Occ, v) {
    let csManager = crystalEditDataDialog.I._app._csManager;
    let newAtom = new CAtom();
    newAtom._position.set(x, y, z);
    newAtom._id = id;
    newAtom._label = label_name;
    if (!csManager._cs) {
      csManager._cs = new CStructure();
    }
    csManager._cs.addAtom(newAtom);
    csManager._cs._boundary.set(new Vector3(0, 0, 0), new Vector3(1, 1, 1));
    csManager._cs.generate(crystalEditDataDialog.I._app.GetSymmetryIdxList());
    renderer._scene.add(csManager._cs._groupMesh);
    return newAtom._id;
  }

  /**
   * 원자를 생성한다.
   * @param {Number} idx 원자 인덱스
   * @param {Number} id 원자 아이디
   * @param {String} label 라벨
   * @param {Number} x x 좌표
   * @param {Number} y y 좌표
   * @param {Number} z z 좌표
   * @param {Number} occ occ
   * @param {Array} su_arr su xyz
   * @param {String} anisoType ansiotropic 타입
   * @param {Array} u_arr anisotropic U / anisotropic Beta
   * @param {String} isoType isotropic 타입
   * @param {Number} u u / b
   * @param {Array} color color array
   * 
   * @returns {CAtom} 생성된 원자
   */
  createAtom(idx, id, label, x, y, z, occ, su_arr, anisoType, u_arr, isoType, u, color) {
    let newAtom = new CAtom();
    newAtom._position.set(x, y, z);
    newAtom._idx = idx;
    newAtom._id = id;
    newAtom._label = label;
    newAtom._occ = occ;
    newAtom._su = su_arr;
    newAtom._anisotype = anisoType;
    if (anisoType == 0) newAtom._anisoU = u_arr;else if (anisoType == 1) newAtom._anisoBeta = u_arr;
    newAtom._isotype = isoType;
    if (isoType == 0) newAtom._isoU = u;else if (isoType == 1) newAtom._isoB = u;
    newAtom._color = color;
    return newAtom;
  }

  /**
   * CStructure generate
   * */
  generateStructure() {
    let csManager = crystalEditDataDialog.I._app._csManager;
    crystalEditDataDialog.I._app._3dRender.Clear();

    // boundary input 값 가져와서 설정하기
    let dlgBoundary = crystalEditDataDialog.I._app._dlgBoundarySetting;
    let minX = parseFloat($(dlgBoundary._input_min_x).val());
    let minY = parseFloat($(dlgBoundary._input_min_y).val());
    let minZ = parseFloat($(dlgBoundary._input_min_z).val());
    let maxX = parseFloat($(dlgBoundary._input_max_x).val());
    let maxY = parseFloat($(dlgBoundary._input_max_y).val());
    let maxZ = parseFloat($(dlgBoundary._input_max_z).val());
    csManager._cs._boundary.set(new Vector3(minX, minY, minZ), new Vector3(maxX, maxY, maxZ));
    csManager._cs.generate();
    crystalEditBondDialog.I._app.UpdateRenderOptions();
    crystalEditBondDialog.I._app.UpdateStructureProperty();
    crystalEditDataDialog.I._app._3dRender._renderer._scene.children.pop();
    crystalEditDataDialog.I._app._3dRender._renderer._scene.add(csManager._cs._groupMesh);
  }

  /**
   * 주어진 크기의 CStructure를 생성한다.
   *
   * @param {Number} a a angle
   * @param {Number} b b angle
   * @param {Number} c c angle
   * @memberof crystalEditDataDialog
   */
  SetCStrucre(a, b, c) {
    let csManager = crystalEditDataDialog.I._app._csManager;
    if (crystalRender._geomRenderer) {
      let cs = csManager._cs;
      if (!cs) {
        csManager._cs = new CStructure();
        cs = csManager._cs;
      }
      cs._unicell._axis.setAngle(a, b, c);
    }
  }

  /**
   * 현재 탭의 인덱스를 반환한다.
   *
   * @return {Number} 현재 탭 인덱스 
   * @memberof crystalEditDataDialog
   */
  GetActiveTabIndex() {
    return $(this._tabsEdit).tabs("option", "active");
  }
  UpdateSelect() {
    let tabIdx = this.GetActiveTabIndex();
    if (tabIdx === 1) {
      let selectedSystem = this._system_table.getSelected();
      let selectedSpaceGroup = this._space_group_table.getSelected();
      let selectedSetting = this._setting_table.getSelected();
      if (selectedSystem && selectedSystem.length === 1) {
        rayLog(3, selectedSystem);
      }
      if (selectedSpaceGroup && selectedSpaceGroup.length === 1) {
        rayLog(3, selectedSpaceGroup);
      }
      if (selectedSetting && selectedSetting.length === 1) {
        rayLog(3, selectedSetting);
      }
    } else if (tabIdx === 2) {
      let selected = this._atomTable.getSelected();
      if (selected.length === 1) {
        rayLog(3, selected);
        this.DisableInput(false);
        let tokens = selected[0].innerText.split("\t");
        let idx = parseInt($(selected[0]).find("#" + this._name + "_atom_idx").html());
        let catom = this._app._csManager._cs.getAtomByIdx(idx);
        $("#" + this._name + "_tr_no").val(tokens[0]);
        $("#" + this._name + "_atom_symbol").val(tokens[1]);
        $("#" + this._name + "_atom_label").val(tokens[2]);
        $("#" + this._name + "_atom_pos_x").val(tokens[3]);
        $("#" + this._name + "_atom_pos_y").val(tokens[4]);
        $("#" + this._name + "_atom_pos_z").val(tokens[5]);
        $("#" + this._name + "_atom_occ").val(tokens[6]);
        $("#" + this._name + "_atom_u").val(tokens[7]);

        /**
         * Anisotropic, Isotropic 메뉴 dropdown과 input enable, disable control
         */
        this.SetInputByCAtom(catom);
      } else {
        this.DisableInput(true);
      }
    } else if (tabIdx === 3) {
      let selected = this._shapeTable.getSelected();
      if (selected.length === 1) {
        let id = parseInt($(selected[0]).find("#" + this._name + "_shape_no").html());
        let plane = this._app._csManager._cs.getPlaneById(id)[0];
        $(this._input_h).val(plane._h);
        $(this._input_k).val(plane._k);
        $(this._input_l).val(plane._l);
        $(this._input_d).val(plane._d);

        /*
        $(this._input_color_background).css("background-color", "rgb(" + plane._color[0] * 255 + "," + plane._color[1] * 255 + "," + plane._color[2] * 255 + ")");
        $(this._input_color_background).val(crystalVariable.HTMLColorRGB([plane._color[0], plane._color[1], plane._color[2]]));
        $(this._input_alpha_background).val(plane._color[3]);
        */

        plane.setMillerIndices(crystalEditDataDialog.I._app._csManager._cs.getLatticeAxis(), plane._h, plane._k, plane._l, plane._d);
      }
    }
  }

  /**
   * 입력값에 맞게 atom 업데이트
   * */
  UpdateSelectedAtomByInput() {
    let selected = this._atomTable.getSelected();
    if (selected.length === 1) {
      let idx = parseInt($(selected[0]).find("#" + this._name + "_atom_idx").html());

      // 일단 선택된 녀석으로 입력란을 업데이트한다.

      let cs_atom = this._app._csManager._cs.getAtomByIdx(idx);
      this.SetCAtomByInput(cs_atom);
      this.UpdateSelectedAtomTableRow(selected[0], cs_atom); // table row 업데이트도 수행한다.
    }
  }

  /**
   * 입력값에 맞게 crystal shape 업데이트
   * */
  UpdateSelectedShapeByInput() {
    let selected = this._shapeTable.getSelected();
    if (selected.length === 1) {
      let id = parseInt($(selected[0]).find("#" + this._name + "_shape_no").html());
      let plane = crystalEditDataDialog.I._app._csManager._cs.getPlaneById(id)[0];
      this.SetPlaneByInput(plane);
      this.UpdateSelectedShapeTableRow(selected[0], plane);
    }
  }

  /**
   * 선택된 row에 해당하는 catom에 맞는 입력란으로 변경한다.
   * @param {CAtom} catom
   */
  UpdateInputUI(catom) {
    if (catom._anisotype === -1) {
      // 입력란 disable
      this.DisableAnisotropicInput(true);
      $(this._selectAnisotropic).val("none");
      $(this._selectAnisotropic).selectmenu("refresh");
    } else if (catom._anisotype === 0) {
      this.DisableAnisotropicInput(false);
      $(this._selectAnisotropic).val("u");
      $(this._selectAnisotropic).selectmenu("refresh");
    } else if (catom._anisotype === 1) {
      this.DisableAnisotropicInput(false);
      $(this._selectAnisotropic).val("beta");
      $(this._selectAnisotropic).selectmenu("refresh");
    }
    if (catom._isotype === 0) {
      $(this._selectIsotropic).val("b");
      $(this._selectIsotropic).selectmenu("refresh");
    } else if (catom._isotype === 1) {
      $(this._selectIsotropic).val("u");
      $(this._selectIsotropic).selectmenu("refresh");
    }
  }

  /**
   * 선택된 row의 정보를 catom 데이터를 바탕으로 업데이트한다.
   * @param {HTMLElement} selectedAtomRow 선택된 atom row
   * @param {CAtom} catom catom
   */
  UpdateSelectedAtomTableRow(selectedAtomRow, catom) {
    $(selectedAtomRow).find("#" + this._name + "_atom_name").html(AtomDef_AtomDef.GetDefWithNumber(catom._id)._atom_id);
    $(selectedAtomRow).find("#" + this._name + "_label_name").html(catom._label);
    $(selectedAtomRow).find("#" + this._name + "_pos_x").html(catom._position._x);
    $(selectedAtomRow).find("#" + this._name + "_pos_y").html(catom._position._y);
    $(selectedAtomRow).find("#" + this._name + "_pos_z").html(catom._position._z);
    $(selectedAtomRow).find("#" + this._name + "_occ").html(catom._occ);
    if (catom._isotype === 0) $(selectedAtomRow).find("#" + this._name + "_v").html(catom._isoU);else if (catom._isotype === 1) $(selectedAtomRow).find("#" + this._name + "_v").html(catom._isoB);
  }

  /**
   * 선택된 row의 정보를 plane 데이터를 바탕으로 업데이트한다.
   * @param {HTMLElement} selectedPlaneRow 선택된 plane row
   * @param {Plane} plane plane
   */
  UpdateSelectedShapeTableRow(selectedPlaneRow, plane) {
    $(selectedPlaneRow).find("#" + this._name + "_shape_h").html(plane._h);
    $(selectedPlaneRow).find("#" + this._name + "_shape_k").html(plane._k);
    $(selectedPlaneRow).find("#" + this._name + "_shape_l").html(plane._l);
    $(selectedPlaneRow).find("#" + this._name + "_shape_distance").html(plane._d);
    /*
    $(selectedPlaneRow).find("#" + this._name + "_shape_color").css("background-color", "rgb(" + plane._color[0] * 255 + "," + plane._color[1] * 255 + "," + plane._color[2] * 255 + ")");
    $(selectedPlaneRow).find("#" + this._name + "_shape_alpha").html(plane._color[3]);
    */
  }

  /**
   * 입력값을 바탕으로 갱신한 variable 변수를 통해 catom을 설정한다.
   * @param {CAtom} catom 설정할 catom
   */
  SetCAtomByInput(catom) {
    this.UpdateVariable();
    catom._id = this._variable["id"];
    catom._label = this._variable["label"];
    catom._position._x = this._variable["x"];
    catom._position._y = this._variable["y"];
    catom._position._z = this._variable["z"];
    catom._su = [this._variable["su_x"], this._variable["su_y"], this._variable["su_z"]];
    catom._occ = this._variable["occ"];
    catom._anisotype = this._variable["anisoType"];
    catom._isotype = this._variable["isoType"];
    catom._color = this._variable["catomColor"];
    if (catom._anisotype === 0) {
      catom._anisoU = [this._variable["u11"], this._variable["u22"], this._variable["u33"], this._variable["u12"], this._variable["u13"], this._variable["u23"]];
    } else if (catom._anisotype === 1) {
      catom._anisoBeta = [this._variable["u11"], this._variable["u22"], this._variable["u33"], this._variable["u12"], this._variable["u13"], this._variable["u23"]];
    }
    if (catom._isotype === 0) {
      catom._isoU = this._variable["u"];
    } else if (catom._isotype === 1) {
      catom._isoB = this._variable["u"];
    }
  }

  /**
   * 입력값을 바탕으로 갱신한 variable 변수를 통해 plane을 설정한다.
   * @param {Plane} plane 설정할 plane
   */
  SetPlaneByInput(plane) {
    this.UpdateVariable();
    plane._h = this._variable["h"];
    plane._k = this._variable["k"];
    plane._l = this._variable["l"];
    plane._d = this._variable["d"];
    plane._color = [this._variable["shapeColor"][0], this._variable["shapeColor"][1], this._variable["shapeColor"][2]];
    let lattice_axis = crystalEditDataDialog.I._app._csManager._cs.getLatticeAxis();
    plane.setMillerIndices(lattice_axis, plane._h, plane._k, plane._l, plane._d);
  }

  /**
   * 주어진 catom을 통해 입력란의 정보를 설정한다.
   * 
   * @param {CAtom} catom 
   */
  SetInputByCAtom(catom) {
    $(this._input_symbol).val(AtomDef_AtomDef.GetDefWithNumber(catom._id)._atom_id);
    $(this._input_label).val(catom._label);
    $(this._input_pos_x).val(catom._position._x);
    $(this._input_pos_y).val(catom._position._y);
    $(this._input_pos_z).val(catom._position._z);
    $(this._input_occ).val(catom._occ);
    $(this._input_su_x).val(catom._su[0]);
    $(this._input_su_y).val(catom._su[1]);
    $(this._input_su_z).val(catom._su[2]);
    $(this._input_catom_color).val(crystalVariable.HTMLColorRGB(catom._color)); // colorpicker 업데이트하는 방법 pv에서 찾아보기
    $(this._input_catom_color).css("background-color", "rgb(" + catom._color[0] * 255 + "," + catom._color[1] * 255 + "," + catom._color[2] * 255 + ")");
    if (catom._anisotype === -1) {
      $(this._selectAnisotropic).val("none");
      $(this._selectAnisotropic).selectmenu("refresh");
      $(this._input_U11).val(0);
      $(this._input_U22).val(0);
      $(this._input_U33).val(0);
      $(this._input_U12).val(0);
      $(this._input_U13).val(0);
      $(this._input_U23).val(0);
      this.DisableAnisotropicInput(true);
    } else if (catom._anisotype === 0) {
      if (catom._anisoU.length === 6) {
        $(this._selectAnisotropic).val("u");
        $(this._selectAnisotropic).selectmenu("refresh");
        this.DisableAnisotropicInput(false);
        $(this._input_U11).val(catom._anisoU[0]);
        $(this._input_U22).val(catom._anisoU[1]);
        $(this._input_U33).val(catom._anisoU[2]);
        $(this._input_U12).val(catom._anisoU[3]);
        $(this._input_U13).val(catom._anisoU[4]);
        $(this._input_U23).val(catom._anisoU[5]);
      } else {
        rayLog(3, "CAtom AnisoU length is not 6");
      }
    } else if (catom._anisotype === 1) {
      if (catom._anisoBeta.length === 6) {
        $(this._selectAnisotropic).val("beta");
        $(this._selectAnisotropic).selectmenu("refresh");
        this.DisableAnisotropicInput(false);
        $(this._input_U11).val(catom._anisoBeta[0]);
        $(this._input_U22).val(catom._anisoBeta[1]);
        $(this._input_U33).val(catom._anisoBeta[2]);
        $(this._input_U12).val(catom._anisoBeta[3]);
        $(this._input_U13).val(catom._anisoBeta[4]);
        $(this._input_U23).val(catom._anisoBeta[5]);
      } else {
        rayLog(3, "CAtom AnisoBeta length is not 6");
      }
    }
    if (catom._isotype === 0) {
      $(this._selectIsotropic).val("u");
      $(this._selectIsotropic).selectmenu("refresh");
      $(this._input_u).val(catom._isoU);
    } else if (catom._isotype === 1) {
      $(this._selectIsotropic).val("b");
      $(this._selectIsotropic).selectmenu("refresh");
      $(this._input_u).val(catom._isoB);
    } else {
      rayLog(3, "CAtom Isotropic Type Error");
    }
  }

  /**
   * 입력 데이터 값을 관리한다.
   * */
  UpdateVariable() {
    this._variable = {};
    this._variable["name"] = $(this._input_cs_name).val();
    this._variable["pos_x"] = parseFloat($(this._input_cs_pos_x).val());
    this._variable["pos_y"] = parseFloat($(this._input_cs_pos_y).val());
    this._variable["pos_z"] = parseFloat($(this._input_cs_pos_z).val());
    this._variable["dir_x"] = parseFloat($(this._input_cs_dir_x).val());
    this._variable["dir_y"] = parseFloat($(this._input_cs_dir_y).val());
    this._variable["dir_z"] = parseFloat($(this._input_cs_dir_z).val());
    this._variable["a"] = parseFloat($(this._input_a_length).val());
    this._variable["b"] = parseFloat($(this._input_b_length).val());
    this._variable["c"] = parseFloat($(this._input_c_length).val());
    this._variable["abc"] = [parseFloat($(crystalEditDataDialog.I._input_alpha).val()), parseFloat($(crystalEditDataDialog.I._input_beta).val()), parseFloat($(crystalEditDataDialog.I._input_gamma).val())];
    this._variable["atom"] = $("#" + this._name + "_atom_symbol").val();
    if (this._variable["atom"] === "") this._variable["atom"] = "H";
    this._variable["id"] = AtomDef_AtomDef.GetDefWithID(this._variable["atom"])._atom_number;
    this._variable["label"] = $(this._input_label).val();
    this._variable["x"] = parseFloat($(this._input_pos_x).val());
    this._variable["y"] = parseFloat($(this._input_pos_y).val());
    this._variable["z"] = parseFloat($(this._input_pos_z).val());
    this._variable["occ"] = parseFloat($(this._input_occ).val());
    this._variable["u"] = parseFloat($(this._input_u).val());
    this._variable["su_x"] = parseFloat($(this._input_su_x).val());
    this._variable["su_y"] = parseFloat($(this._input_su_y).val());
    this._variable["su_z"] = parseFloat($(this._input_su_z).val());
    this._variable["u11"] = parseFloat($(this._input_U11).val());
    this._variable["u22"] = parseFloat($(this._input_U22).val());
    this._variable["u33"] = parseFloat($(this._input_U33).val());
    this._variable["u12"] = parseFloat($(this._input_U12).val());
    this._variable["u13"] = parseFloat($(this._input_U13).val());
    this._variable["u23"] = parseFloat($(this._input_U23).val());
    this._variable["h"] = parseFloat($(this._input_h).val());
    this._variable["k"] = parseFloat($(this._input_k).val());
    this._variable["l"] = parseFloat($(this._input_l).val());
    this._variable["d"] = parseFloat($(this._input_d).val());
    this._variable["shapeColor"] = this._selectedShapeColor;
    // this._variable["alpha"] = parseFloat($(this._input_alpha_background).val());

    if ($(this._input_catom_color).val()) this._variable["catomColor"] = crystalVariable.HexStringtoColor($(this._input_catom_color).val());else this._variable["catomColor"] = AtomDef_AtomDef.GetDefWithNumber(1)._color;
    let anisoStr = $(this._selectAnisotropic).val();
    let isoStr = $(this._selectIsotropic).val();
    switch (anisoStr) {
      case "none":
        this._variable["anisoType"] = -1;
        break;
      case "u":
        this._variable["anisoType"] = 0;
        break;
      case "beta":
        this._variable["anisoType"] = 1;
        break;
    }
    switch (isoStr) {
      case "u":
        this._variable["isoType"] = 0;
        break;
      case "b":
        this._variable["isoType"] = 1;
        break;
    }
  }

  /**
   * 선택된 atom row가 바뀌면 입력란을 업데이트한다.
   * */
  ChangeSelectedAtom() {
    let selected = this._atomTable.getSelected();
    if (selected.length === 1) {
      this.UpdateSelectedAtomByInput();
      this._bModified = true;
    }
  }

  /**
   * 선택된 shape row가 바뀌면 입력란을 업데이트한다.
   * */
  ChangeSelectedShape() {
    let selected = this._shapeTable.getSelected();
    if (selected.length === 1) {
      this.UpdateSelectedShapeByInput();
    }
  }

  /**
   * 변경된 cstructure의 내용을 적용한다.
   * */
  UpdateRenderer() {
    crystalEditDataDialog.I.generateStructure();
  }

  /**
   * CStructure 데이터를 통해 테이블을 갱신한다.
   * @param {CStructure} cs
   */
  UpdateTableByCS(cs) {
    for (let i = 0; i < cs._atoms.length; ++i) {
      this.AddAtomToTable(cs.assignAtomIdx(), cs._atoms[i]._id, AtomDef_AtomDef.GetDefWithNumber(cs._atoms[i]._id)._id, cs._atoms[i]._label, cs._atoms[i]._position._x, cs._atoms[i]._position._y, cs._atoms[i]._position._z, 0, 0);
    }
    for (let i = 0; i < cs._crystalPlanes.length; ++i) {
      this.AddShapeToTable(cs.assignShapeId(), cs._crystalPlanes[i]._h, cs._crystalPlanes[i]._k, cs._crystalPlanes[i]._l, cs._crystalPlanes[i]._d, cs._crystalPlanes[i]._color, 100, true);
    }
  }
  UpdateUnitcellByCS(cs) {
    $(this._input_a_length).val(cs._unitcell._axis._la);
    $(this._input_b_length).val(cs._unitcell._axis._lb);
    $(this._input_c_length).val(cs._unitcell._axis._lc);
    $(this._input_alpha).val(cs._unitcell._axis._a);
    $(this._input_beta).val(cs._unitcell._axis._b);
    $(this._input_gamma).val(cs._unitcell._axis._c);
  }

  /**
   * 입력창 비활성화
   * @param {Boolean} bDisable 비활성화 여부
   */
  DisableInput(bDisable = true) {
    $(this._btnSymbol).attr("disabled", bDisable);
    $(this._input_no).attr("disabled", bDisable);
    $(this._input_pos_x).attr("disabled", bDisable);
    $(this._input_pos_y).attr("disabled", bDisable);
    $(this._input_pos_z).attr("disabled", bDisable);
    // $(this._input_symbol).attr("disabled", bDisable);
    $(this._input_label).attr("disabled", bDisable);
    $(this._input_occ).attr("disabled", bDisable);
    $(this._input_u).attr("disabled", bDisable);
    $(this._input_charge).attr("disabled", bDisable);
    $(this._input_su_x).attr("disabled", bDisable);
    $(this._input_su_y).attr("disabled", bDisable);
    $(this._input_su_z).attr("disabled", bDisable);
    $(this._input_catom_color).attr("disabled", bDisable);
    if (bDisable) {
      $(this._input_symbol).val("");
      $(this._input_no).val("");
      $(this._input_catom_color).val("");
    }
  }

  /**
   * Anisotropic 입력창 비활성화
   * @param {Boolean} bDisable 비활성화 여부
   */
  DisableAnisotropicInput(bDisable = true) {
    $(this._input_U11).attr("disabled", bDisable);
    $(this._input_U22).attr("disabled", bDisable);
    $(this._input_U33).attr("disabled", bDisable);
    $(this._input_U12).attr("disabled", bDisable);
    $(this._input_U13).attr("disabled", bDisable);
    $(this._input_U23).attr("disabled", bDisable);
  }

  /**
   * shape color 지정
   * @param {Array} col color array
   */
  OnChangeColorBackground(col) {
    this._selectedShapeColor = col;
    Array.from($(this._shapeTable.getAllRow())).forEach(function (element) {
      rayLog(3, element);
      let idx = parseInt($(element).find("#cryapp_shape_no")[0].innerText);
      let plane = crystalEditDataDialog.I._app._csManager._cs._crystalPlanes[idx];
      plane._color = [crystalEditDataDialog.I._selectedShapeColor[0], crystalEditDataDialog.I._selectedShapeColor[1], crystalEditDataDialog.I._selectedShapeColor[2], crystalEditDataDialog.I._selectedShapeColor[3]];
    });
  }

  /**
   * atom color 지정
   * @param {Array} col shape array
   */
  OnChangeCAtomColor(col) {
    this._selectedCatomColor = col;
  }
  UpdateCrystalColor() {
    let plane = this._app._csManager._cs._crystalPlanes[0];
    if (plane) {
      $(this._input_color_background).css("background-color", "rgb(" + plane._color[0] * 255 + "," + plane._color[1] * 255 + "," + plane._color[2] * 255 + ")");
      $(this._input_color_background).val(crystalVariable.HTMLColorRGB([plane._color[0], plane._color[1], plane._color[2]]));
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditLatticePlaneDialog.js





/**
 * Lattice Plane 편집 다이얼로그
 * */
class crystalEditLatticePlaneDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem edit lattice plane dialog가 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    this._div_latticeTable = document.getElementById(name + "_edit_lattice_shape_table");
    this._bModified = false;
    crystalEditLatticePlaneDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxWidth: 650,
      maxHeight: 450,
      width: 650,
      height: 450,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Lattice Plane",
      buttons: {
        "OK": function () {
          if (crystalEditLatticePlaneDialog.I._bModified) {
            crystalEditLatticePlaneDialog.I._app._bModified = true;
            crystalEditLatticePlaneDialog.I._app._csManager.AddUndo();
          }
          crystalEditLatticePlaneDialog.I.OnApply();
          crystalEditLatticePlaneDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalEditLatticePlaneDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalEditLatticePlaneDialog.I._show = false;
      }
    });
    this._selectedLatticeColor = [1, 0, 0];
    this._input_lattice_h = document.getElementById(name + "_edit_lattice_miller_indice_h");
    this._input_lattice_k = document.getElementById(name + "_edit_lattice_miller_indice_k");
    this._input_lattice_l = document.getElementById(name + "_edit_lattice_miller_indice_l");
    this._input_lattice_d = document.getElementById(name + "_edit_lattice_distance_from_origin_A");
    this._input_lattice_color = document.getElementById(name + "_edit_lattice_color_background");
    this._btnNewLattice = document.getElementById(name + "_new_lattice_plane_btn");
    this._btnDeleteLattice = document.getElementById(name + "_delete_lattice_plane_btn");
    this._btnClearLattice = document.getElementById(name + "_clear_lattice_plane_btn");
    $(this._input_lattice_color).colorpicker({
      modal: true,
      buttonColorisze: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
        crystalEditLatticePlaneDialog.I.OnChangeLatticeColor([formatted.rgb["r"], formatted.rgb["g"], formatted.rgb["b"]]);
        crystalEditLatticePlaneDialog.I.ChangeSelected();
      }
    });
    $(this._input_lattice_h).on("input", function () {
      crystalEditLatticePlaneDialog.I.ChangeSelected();
    });
    $(this._input_lattice_k).on("input", function () {
      crystalEditLatticePlaneDialog.I.ChangeSelected();
    });
    $(this._input_lattice_l).on("input", function () {
      crystalEditLatticePlaneDialog.I.ChangeSelected();
    });
    $(this._input_lattice_d).on("input", function () {
      crystalEditLatticePlaneDialog.I.ChangeSelected();
    });
    $(this._btnNewLattice).button();
    $(this._btnDeleteLattice).button();
    $(this._btnClearLattice).button();
    $(this._btnNewLattice).click(function (event) {
      crystalEditLatticePlaneDialog.I._bModified = true;
      let len = crystalEditLatticePlaneDialog.I._app._csManager._cs._latticePlanes.length;
      let h = parseFloat($(crystalEditLatticePlaneDialog.I._input_lattice_h).val());
      let k = parseFloat($(crystalEditLatticePlaneDialog.I._input_lattice_k).val());
      let l = parseFloat($(crystalEditLatticePlaneDialog.I._input_lattice_l).val());
      let d = parseFloat($(crystalEditLatticePlaneDialog.I._input_lattice_d).val());
      let color = crystalEditLatticePlaneDialog.I._selectedLatticeColor;
      if (h === 0 && k === 0 && l === 0) {
        alert("hkl can not be all zero");
        return;
      }
      crystalEditLatticePlaneDialog.I.AddLatticeToTable(len, h, k, l, d, color);
      let plane = new Plane_Plane();
      let lattice_axis = crystalEditLatticePlaneDialog.I._app._csManager._cs.getLatticeAxis();
      plane.setMillerIndices(lattice_axis, h, k, l, d);
      plane.setColor(color[0], color[1], color[2]);
      crystalEditLatticePlaneDialog.I._app._csManager._cs.addLatticePlane(plane);
      crystalEditLatticePlaneDialog.I._latticeTable.initSelect();
      crystalEditLatticePlaneDialog.I._latticeTable.selectLast();
    });
    $(this._btnDeleteLattice).click(function (event) {
      crystalEditLatticePlaneDialog.I._bModified = true;
      let latticeRows = crystalEditLatticePlaneDialog.I._latticeTable.getSelected();
      for (let latticeRow of latticeRows) {
        let idx = parseInt($(latticeRow).find("#" + crystalEditLatticePlaneDialog.I._app._name + "_lattice_id").html());
        crystalEditLatticePlaneDialog.I._app._csManager._cs.removeLatticePlaneByIdx(idx);
      }
      crystalEditLatticePlaneDialog.I._latticeTable.deleteSelected();
      crystalEditLatticePlaneDialog.I._latticeTable.updateTable();
    });
    $(this._btnClearLattice).click(function (event) {
      crystalEditLatticePlaneDialog.I._bModified = true;
      crystalEditLatticePlaneDialog.I._app._csManager._cs.clearLatticePlane();
      crystalEditLatticePlaneDialog.I._latticeTable.clearAll();
    });
    this._latticeTable = new crystalTable(this._name, this._app, this._div_latticeTable, "latticeTable");
    this._latticeTable.createHeader("\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>No.</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>h</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>k</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>l</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>d(A)</th>\
                <th class='cryUI_Text_Center cryUI_Big_Td_With_Margin'>color</th>\
            ", false);
  }

  /**
   * table에 lattice plane을 추가한다.
   * @param {Number} id lattice plane id
   * @param {Number} h h
   * @param {Number} k k
   * @param {Number} l l
   * @param {Number} d distance
   * @param {Array} color color array
   */
  AddLatticeToTable(id, h, k, l, d, color) {
    let innerHTML = "\
            <td id='" + this._name + "_lattice_id' style='display:none'>" + id + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_no_" + id + "' style='display:none'></td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_h'>" + h + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_k'>" + k + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_l'>" + l + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_distance'>" + d + "</td>\
            <td class='cryUI_Big_Td_With_Margin cryUI_Text_Center' id='" + this._name + "_lattice_color'></td>\
            ";
    this._latticeTable.appTable(innerHTML, true);
    $("#" + this._name + "_lattice_no_" + id).parent().find("#" + this._name + "_lattice_color").css("background-color", '#' + crystalVariable.HTMLColorRGB(color));
    $(this._latticeTable.getAllRow()).last().on("click", function () {
      crystalEditLatticePlaneDialog.I.UpdateSelect();
    });
  }

  /**
   * 선택한 row를 바탕으로 입력창을 업데이트한다.
   * */
  UpdateSelect() {
    let selected = this._latticeTable.getSelected();
    if (selected.length === 1) {
      let id = parseInt($(selected[0]).find("#" + this._name + "_lattice_id").html());
      let plane = this._app._csManager._cs.getLatticePlaneByIdx(id);
      this.SetInputByLattice(plane);
    }
  }

  /**
   * EditLatticePlaneDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<table class='cryUI_Lattice_Wrapper_Table'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Lattice_Left_Blank'>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Miller indices (hkl):</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_edit_lattice_miller_indice_h' value=1></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_edit_lattice_miller_indice_k' value=1></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_edit_lattice_miller_indice_l' value=0></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Distance from origin:</td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Big_Td_With_Margin' type='number' id='" + name + "_edit_lattice_distance_from_origin_A' value=1></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "<tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Float_Td'>Color (RGB):</td>";
    idx++;
    // color picker 추가하기
    ihtml[idx] = "<td class='cryUI_Lattice_Input'><input class='cryUI_Normal_Td' type='text' id='" + name + "_edit_lattice_color_background' value='ff0000' style='background-color: red'></td>";
    idx++;
    ihtml[idx] = "</tr>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    // table
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table_Area' id='" + name + "_edit_lattice_shape_area'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table' id='" + name + "_edit_lattice_shape_table'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Modify' id='" + name + "_edit_lattice_modify'>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_new_lattice_plane_btn'>New</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_delete_lattice_plane_btn'>Delete</button>";
    idx++;
    ihtml[idx] = "<button class='ui - button ui - widget ui - corner - all cryUI_Normal_Thick_Btn' id='" + name + "_clear_lattice_plane_btn'>Clear</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * edit lattice plane dialog를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    crystalEditLatticePlaneDialog.I._app._csManager.SetPrev(crystalEditLatticePlaneDialog.I._app._csManager._cs);
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그 창을 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }

  /**
   * 바뀐 color로 lattice color를 설정한다.
   * @param {Array} col color array
   */
  OnChangeLatticeColor(col) {
    this._selectedLatticeColor = col;
  }

  /**
   * 선택된 lattice table에 입력값을 적용한다.
   * */
  ChangeSelected() {
    let selected = this._latticeTable.getSelected();
    if (selected.length === 1) {
      this.UpdateSelectByInput();
    }
  }

  /**
   * 선택된 row에 입력값을 적용한다.
   * */
  UpdateSelectByInput() {
    let selected = this._latticeTable.getSelected();
    if (selected.length === 1) {
      let id = parseInt($(selected[0]).find("#" + this._name + "_lattice_id").html());
      let plane = this._app._csManager._cs.getLatticePlaneByIdx(id);
      this.SetLatticeByInput(plane);
      this.UpdateSelectedLatticeTableRow(selected[0], plane);
    }
  }

  /**
   * lattice plane 값을 바탕으로 입력란을 업데이트한다.
   * @param {LatticePlanes} plane lattice plane
   */
  SetInputByLattice(plane) {
    $(this._input_lattice_h).val(plane._h);
    $(this._input_lattice_k).val(plane._k);
    $(this._input_lattice_l).val(plane._l);
    $(this._input_lattice_d).val(plane._d);
    $(this._input_lattice_color).val(crystalVariable.HTMLColorRGB(plane._color));
    $(this._input_lattice_color).css("background-color", "rgb(" + plane._color[0] * 255 + "," + plane._color[1] * 255 + "," + plane._color[2] * 255 + ")");
  }

  /**
   * 입력값을 바탕으로 lattice plane을 업데이트한다.
   * @param {LatticePlanes} plane lattice plane
   */
  SetLatticeByInput(plane) {
    this.UpdateVariable();
    plane._h = this._variable["h"];
    plane._k = this._variable["k"];
    plane._l = this._variable["l"];
    plane._d = this._variable["d"];
    plane._color = this._variable["latticeColor"];
    let lattice_axis = crystalEditLatticePlaneDialog.I._app._csManager._cs.getLatticeAxis();
    plane.setMillerIndices(lattice_axis, plane._h, plane._k, plane._l, plane._d);
  }

  /**
   * 입력 데이터 값을 관리한다.
   * */
  UpdateVariable() {
    this._variable = {};
    this._variable["h"] = parseFloat($(this._input_lattice_h).val());
    this._variable["k"] = parseFloat($(this._input_lattice_k).val());
    this._variable["l"] = parseFloat($(this._input_lattice_l).val());
    this._variable["d"] = parseFloat($(this._input_lattice_d).val());
    if (this._selectedLatticeColor) this._variable["latticeColor"] = this._selectedLatticeColor;
  }

  /**
   * 선택된 lattice 정보를 바탕으로 선택된 lattice row를 업데이트한다.
   * @param {HTMLElement} selectedLatticeRow 선택된 lattice row
   * @param {LatticePlanes} lattice lattice plane
   */
  UpdateSelectedLatticeTableRow(selectedLatticeRow, lattice) {
    $(selectedLatticeRow).find("#" + this._name + "_lattice_h").html(lattice._h);
    $(selectedLatticeRow).find("#" + this._name + "_lattice_k").html(lattice._k);
    $(selectedLatticeRow).find("#" + this._name + "_lattice_l").html(lattice._l);
    $(selectedLatticeRow).find("#" + this._name + "_lattice_distance").html(lattice._d);
    // $(selectedLatticeRow).find("#" + this._name + "_lattice_color").html(crystalVariable.HTMLColorRGB(lattice._color));
    $(selectedLatticeRow).find("#" + this._name + "_lattice_color").css("background-color", "rgb(" + lattice._color[0] * 255 + "," + lattice._color[1] * 255 + "," + lattice._color[2] * 255 + ")");
  }
  UpdateTableByCS(cs) {
    for (let i = 0; i < cs._latticePlanes.length; ++i) {
      this.AddLatticeToTable(i, cs._latticePlanes[i]._h, cs._latticePlanes[i]._k, cs._latticePlanes[i]._l, cs._latticePlanes[i]._d, cs._latticePlanes[i]._color);
    }
  }
  OnApply() {
    crystalEditLatticePlaneDialog.I._app._csManager._cs.generateLatticePlanes();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditVectorsVectorsTab.js



/**
 * Vector 편집 다이얼로그
 * */
class crystalEditVectorsVectorsTab {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalEditVectorsVectorsTab이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalEditVectorsVectorsTab.I = this;
    this._div_vectors_modify_btn_area = document.getElementById(name + "_vectors_modify_btn_area");
    this._div_crystal_vectors_table = document.getElementById(name + "_vectors_table_area");
    this._crystal_vectors_table = new crystalTable(name, app, this._div_crystal_vectors_table, "Vectors");
    this._crystal_vectors_table.createHeader("\
            <th class='cryUI_Big_Td_With_Margin'>No.</th>\
            <th class='cryUI_Big_Td'>u</th>\
            <th class='cryUI_Big_Td'>v</th>\
            <th class='cryUI_Big_Td'>w</th>\
            <th class='cryUI_Big_Td'>Modulus</th>\
            <th class='cryUI_Big_Td'>r(A)</th>\
            ", false);
    this._new_vector_btn = document.getElementById(name + "_vector_tab_new_vector");
    this._edit_vector_btn = document.getElementById(name + "_vector_tab_edit_vector");
    this._delete_vector_btn = document.getElementById(name + "_vector_tab_delete_vector");
    $(this._new_vector_btn).button().click(function () {
      // show dialog
      crystalEditVectorsVectorsTab.I._app._dlgCreateVector._mode = cryst.Mode.AddVector;
      crystalEditVectorsVectorsTab.I._app._dlgCreateVector.ShowDialog();
    });
    $(this._edit_vector_btn).button().click(function () {
      // show dialog
      crystalEditVectorsVectorsTab.I._app._dlgCreateVector._mode = cryst.Mode.ModifyVector;
      crystalEditVectorsVectorsTab.I._app._dlgCreateVector.ShowDialog();
    });
    $(this._delete_vector_btn).button().click(function () {
      let selected = crystalEditVectorsVectorsTab.I._crystal_vectors_table.getSelected();
      let idx = parseInt($(selected[0]).find("#" + crystalEditVectorsVectorsTab.I._name + "_vectors_tab_vector_number").text());
      let v = crystalEditVectorsVectorsTab.I._app._csManager._cs._tvectors[idx];
      crystalEditVectorsVectorsTab.I._app._csManager._cs.removetVector(v);
      crystalEditVectorsVectorsTab.I._crystal_vectors_table.deleteSelected();
      crystalEditVectorsVectorsTab.I.UpdateTable();
    });
    this._div.classList.add("cryUI_Vectors");
  }
  /**
   * EditVectorsVectorsTab에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    // 버튼 공간
    ihtml[idx] = "<div class='cryUI_Vectors_Modify_Btn_Area' id='" + name + "_vectors_modify_btn_area'>";
    idx++;
    ihtml[idx] = "<button class='ui-button ui-widget ui-corner-all cryUI_Vectors_Btn' id='" + name + "_vector_tab_new_vector'>New</button>";
    idx++;
    ihtml[idx] = "<button class='ui-button ui-widget ui-corner-all cryUI_Vectors_Btn' id='" + name + "_vector_tab_edit_vector'>Edit</button>";
    idx++;
    ihtml[idx] = "<button class='ui-button ui-widget ui-corner-all cryUI_Vectors_Btn' id='" + name + "_vector_tab_delete_vector'>Delete</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // 테이블 공간
    ihtml[idx] = "<div class='cryUI_Vectors_Table_Area' id='" + name + "_vectors_table_area'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 테이블 업데이트
   * */
  UpdateTable() {
    this._crystal_vectors_table.clearAll();
    this._app._csManager._cs.numberVectors();
    for (let i = 0; i < this._app._csManager._cs._tvectors.length; ++i) {
      let v = this._app._csManager._cs._tvectors[i];
      this.AddVectorToTable(v._vector[0], v._vector[1], v._vector[2], v._radius, v._number, v._color);
    }
  }

  /**
   * 테이블에 벡터를 추가한다.
   * @param {Number} u u
   * @param {Number} v v
   * @param {Number} w w
   * @param {Number} radius 벡터의 반지름
   * @param {Number} number 벡터 구분자
   * @param {Array} color color array
   */
  AddVectorToTable(u, v, w, radius, number, color) {
    let innerHTML = "\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_u'>" + u + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_v'>" + v + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_edit_vectors_w'>" + w + "</td >\
            <td class='cryUI_Big_Td'>0</td>\
            <td class='cryUI_Big_Td'>" + radius + "</td>\
            <td id='" + this._name + "_vectors_tab_vector_number' style='display:none'>" + number + "</td>\
            <td id='" + this._name + "_vectors_tab_vector_color' style='display:none'>" + color[0] + "," + color[1] + "," + color[2] + "</td>\
            ";
    this._crystal_vectors_table.appTable(innerHTML, true);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditVectorsCrystalGraphicSitesTab.js




/**
 * Crystal Graphic Sites 다이얼로그
 * */
class crystalEditVectorsCrystalGraphicSitesTab {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalEditVectorsCrystalGraphicSitesTab이 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    crystalEditVectorsCrystalGraphicSitesTab.I = this;
    this._crystal_graphic_site_table = new crystalTable(name, app, this._div, "Crystal_Graphic_Sites");
    this._div.classList.add('cryUI_Graphic_Site');
    this._crystal_graphic_site_table.createHeader("\
            <th class='cryUI_Big_Td_With_Margin'>No.</th>\
            <th class='cryUI_Normal_Td'>Atom</th>\
            <th class='cryUI_Normal_Td'>Label</th>\
            <th class='cryUI_Big_Td'>X</th>\
            <th class='cryUI_Big_Td'>Y</th>\
            <th class='cryUI_Big_Td'>Z</th>\
            <th class='cryUI_Big_Td'>Vector</th>\
            ", false);
  }

  /**
   * 테이블 업데이트
   * */
  UpdateTable() {
    // 원소 정보와 벡터 정보 가져오기
    // 원소 정보는 csManager로 부터 가져올 수 있다.
    // 벡터 정보는 가져온 원소 정보의 ivector를 살펴보면 가져올 수 있다.
    this._crystal_graphic_site_table.clearAll();
    for (let i = 0; i < this._app._csManager._cs._atoms.length; ++i) {
      let atom = this._app._csManager._cs._atoms[i];
      this.AddCrystalloGraphicToTable(atom._idx, AtomDef.GetDefWithNumber(atom._id)._id, atom._label, atom._position._x, atom._position._y, atom._position._z);
    }
  }

  /**
   * 테이블 데이터 추가
   * @param {Number} idx catom index
   * @param {String} atom catom name
   * @param {String} label label
   * @param {Number} x x 좌표
   * @param {Number} y y 좌표
   * @param {Number} z z 좌표
   */
  AddCrystalloGraphicToTable(idx, atom, label, x, y, z) {
    let innerHTML = "\
            <td style='display:none' id='" + this._name + "_crystallo_graphic_catom_idx'>" + idx + "</td>\
            <td class='cryUI_Normal_Td'>" + atom + "</td>\
            <td class='cryUI_Normal_Td'>" + label + "</td>\
            <td class='cryUI_Big_Td'>" + x + "</td>\
            <td class='cryUI_Big_Td'>" + y + "</td>\
            <td class='cryUI_Big_Td'>" + z + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_crystallo_vector_idxs'></td>";
    this._crystal_graphic_site_table.appTable(innerHTML, true);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditVectorsIndividualAtomTab.js



/**
 * Individual Atom Vector 편집 다이얼로그
 * */
class crystalEditVectorsIndividualAtomTab {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem EditVectorsIndividualAtomTab이 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    crystalEditVectorsIndividualAtomTab.I = this;
    this._individual_atom_table = new crystalTable(name, app, this._div, "Individual_Atom");
    this._individual_atom_table.createHeader("\
            <th class='cryUI_Big_Td_With_Margin'>No.</th>\
            <th class='cryUI_Normal_Td'>Atom</th>\
            <th class='cryUI_Normal_Td'>Label</th>\
            <th class='cryUI_Big_Td'>X</th>\
            <th class='cryUI_Big_Td'>Y</th>\
            <th class='cryUI_Big_Td'>Z</th>\
            <th class='cryUI_Big_Td'>Vector</th>\
            ", false);
    this._div.classList.add("cryUI_Individual_Atom");
  }

  /**
   * 테이블 업데이트
   * */
  UpdateTable() {
    this._individual_atom_table.clearAll();
    for (let i = 0; i < this._app._csManager._cs._iatomList.length; ++i) {
      let iatom = this._app._csManager._cs._iatomList[i];
      if (iatom._visible) this.AddIndividualAtomToTable(i, AtomDef.GetDefWithNumber(iatom._def._id)._id, iatom._def._label, iatom._position.x, iatom._position.y, iatom._position.z);
    }
  }

  /**
   * 테이블에 atom을 추가한다.
   * @param {Number} idx atom index
   * @param {String} atom atom 이름
   * @param {String} label 라벨
   * @param {Number} x x 좌표
   * @param {Number} y y 좌표
   * @param {Number} z z 좌표
   */
  AddIndividualAtomToTable(idx, atom, label, x, y, z) {
    let innerHTML = "\
            <td style='display:none' id='" + this._name + "_individual_atom_iatom_idx'>" + idx + "</td>\
            <td class='cryUI_Normal_Td'>" + atom + "</td>\
            <td class='cryUI_Normal_Td'>" + label + "</td>\
            <td class='cryUI_Big_Td'>" + x + "</td>\
            <td class='cryUI_Big_Td'>" + y + "</td>\
            <td class='cryUI_Big_Td'>" + z + "</td>\
            <td class='cryUI_Big_Td' id='" + this._name + "_individual_vector_idxs'></td>";
    this._individual_atom_table.appTable(innerHTML, true);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditVectorsDialog.js





/**
 * Vector 관련 다이얼로그
 * */
class crystalEditVectorsDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalEditVectorsDialog가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalEditVectorsDialog.I = this;
    this._tabsLeft = document.getElementById(name + "_edit_vectors_left_tab");
    this._tabsRight = document.getElementById(name + "_edit_vectors_right_tab");
    this._div_crystal_graphic_sties_tab = document.getElementById(name + "_edit_crystalgraphic_sites");
    this._div_individual_atom_tab = document.getElementById(name + "_edit_individual_atom");
    this._div_vectors_tab = document.getElementById(name + "_edit_vectors");
    this._individual_atom_tab = new crystalEditVectorsIndividualAtomTab(this._name, this._app, this._div_individual_atom_tab);
    this._crystal_graphic_sites_tab = new crystalEditVectorsCrystalGraphicSitesTab(this._name, this._app, this._div_crystal_graphic_sties_tab);
    this._vectors_tab = new crystalEditVectorsVectorsTab(this._name, this._app, this._div_vectors_tab);
    this._set_btn = document.getElementById(name + "_set_vector");
    this._remove_btn = document.getElementById(name + "_remove_vector");
    this._bModified = false;
    $(this._set_btn).click(function () {
      let tabIdx = crystalEditVectorsDialog.I.GetActiveTabIndex();

      // get current selected crystallographic sites
      let selectedCrystallo = crystalEditVectorsDialog.I._crystal_graphic_sites_tab._crystal_graphic_site_table.getSelected();
      let selectedIndividual = crystalEditVectorsDialog.I._individual_atom_tab._individual_atom_table.getSelected();

      // get current selected vector
      let selectedVector = crystalEditVectorsDialog.I._vectors_tab._crystal_vectors_table.getSelected();
      if (tabIdx === 0 && selectedCrystallo.length === 1 && selectedVector.length === 1) {
        crystalEditVectorsDialog.I._bModified = true;
        let idx = parseInt($(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_graphic_catom_idx").html());
        // get selected crystallo catom from csManager
        let catom = crystalEditVectorsDialog.I._app._csManager._cs.getAtomByIdx(idx);
        let number = parseInt($(selectedVector).find("#" + crystalEditVectorsDialog.I._name + "_vectors_tab_vector_number").html());
        // get selected vector ivector from csManager
        let tvector = crystalEditVectorsDialog.I._app._csManager._cs.gettVectorByNumber(number)[0];
        // addvector to catom
        crystalEditVectorsDialog.I._app._csManager._cs.addVector2CAtom(catom, tvector);
        crystalEditVectorsDialog.I.AddSelectedVectorToCrystallo(selectedVector, selectedCrystallo);

        // generate
        crystalEditVectorsDialog.I.generateStructure();
      } else if (tabIdx === 1 && selectedIndividual.length === 1 && selectedVector.length === 1) {
        crystalEditVectorsDialog.I._bModified = true;
        let idx = parseInt($(selectedIndividual).find("#" + crystalEditVectorsDialog.I._name + "_individual_atom_iatom_idx").html());
        let iatom = crystalEditVectorsDialog.I._app._csManager._cs._iatomList[idx];
        let number = parseInt($(selectedVector).find("#" + crystalEditVectorsDialog.I._name + "_vectors_tab_vector_number").html());
        // get selected vector ivector from csManager
        let tvector = crystalEditVectorsDialog.I._app._csManager._cs.gettVectorByNumber(number)[0];
        // addvector to catom
        crystalEditVectorsDialog.I._app._csManager._cs.addVector2iAtom(iatom, tvector);
        crystalEditVectorsDialog.I.AddSelectedVectorToIndividual(selectedVector, selectedIndividual);

        // generate
        crystalEditVectorsDialog.I.generateStructure();
      }
    });
    $(this._remove_btn).click(function () {
      rayLog(3, "vector remove button clicked");
      let tabIdx = crystalEditVectorsDialog.I.GetActiveTabIndex();

      // get current selected crystallographic sites
      let selectedCrystallo = crystalEditVectorsDialog.I._crystal_graphic_sites_tab._crystal_graphic_site_table.getSelected();
      let selectedIndividual = crystalEditVectorsDialog.I._individual_atom_tab._individual_atom_table.getSelected();
      if (tabIdx === 0 && selectedCrystallo.length === 1) {
        crystalEditVectorsDialog.I._bModified = true;
        let idx = parseInt($(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_graphic_catom_idx").html());
        // get selected crystallo catom from csManager
        let catom = crystalEditVectorsDialog.I._app._csManager._cs.getAtomByIdx(idx);
        // remove vector
        catom.clearVectors();
        crystalEditVectorsDialog.I.RemoveVectorFromSelectedCrystallo(selectedCrystallo);

        // generate
        crystalEditVectorsDialog.I.generateStructure();
      } else if (tabIdx === 1 && selectedIndividual.length === 1) {
        crystalEditVectorsDialog.I._bModified = true;
        let idx = parseInt($(selectedIndividual).find("#" + crystalEditVectorsDialog.I._name + "_individual_atom_iatom_idx").html());
        let iatom = crystalEditVectorsDialog.I._app._csManager._cs._iatomList[idx];
        crystalEditVectorsDialog.I._app._csManager._cs.removeAllVectors4iAtom(iatom);
        crystalEditVectorsDialog.I.RemoveVectorFromSelectedIndividual(selectedIndividual);
        crystalEditVectorsDialog.I.generateStructure();
      }
    });
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxHeight: 400,
      height: 400,
      maxWidth: 900,
      width: 900,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Vectors",
      buttons: {
        "OK": function () {
          if (crystalEditVectorsDialog.I._bModified) {
            crystalEditVectorsDialog.I._app._bModified = true;
            crystalEditVectorsDialog.I._app._csManager.AddUndo();
          }
          // crystalEditVectorsDialog.I.OnApply();
          crystalEditVectorsDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalEditVectorsDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalEditVectorsDialog.I._show = false;
        crystalEditVectorsDialog.I._app.UpdateUI();
      }
    });
    $(this._tabsLeft).tabs({
      active: 0
    });
    $(this._tabsRight).tabs({
      active: 0
    });
  }

  /**
   * EditVectorsDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    // left tab
    ihtml[idx] = "<div class='cryUI_Edit_Vectors_Left_Tab' id='" + name + "_edit_vectors_left_tab'>";
    idx++;
    ihtml[idx] = "<ul>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_crystalgraphic_sites' class='cryUI_TabBtn'>Crystallographic Sites</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_individual_atom' class='cryUI_TabBtn'>Individual Atom</a></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    // CrystalGraphic Sites
    ihtml[idx] = "<div id='" + name + "_edit_crystalgraphic_sites' class='cryUI_Tabs' style='overflow:auto'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // Individual Atom
    ihtml[idx] = "<div id='" + name + "_edit_individual_atom' class='cryUI_Tabs' style='overflow:auto'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Edit_Vectors_Button_Area' id='" + name + "_edit_vectors_button_area'>";
    idx++;
    ihtml[idx] = "<br><br><br>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Width_100 ui-button ui-widget ui-corner-all' id='" + name + "_set_vector'><< Set</button>";
    idx++;
    ihtml[idx] = "<br><br><br>";
    idx++;
    ihtml[idx] = "<button class='cryUI_Width_100 ui-button ui-widget ui-corner-all' id='" + name + "_remove_vector'>>> Remove</button>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // right tab
    ihtml[idx] = "<div class='cryUI_Edit_Vectors_Right_Tab' id='" + name + "_edit_vectors_right_tab'>";
    idx++;
    ihtml[idx] = "<ul>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_edit_vectors' class='cryUI_TabBtn'>Vectors</a></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    // Vectors
    ihtml[idx] = "<div id='" + name + "_edit_vectors' class='cryUI_Tabs' style='overflow:auto'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 다이얼로그를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    crystalEditVectorsDialog.I._app._csManager.SetPrev(crystalEditVectorsDialog.I._app._csManager._cs);
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
    this._bModified = false;
  }

  /**
   * CStructure generate
   * */
  generateStructure() {
    let renderer = crystalEditVectorsDialog.I._app._3dRender;
    let csManager = crystalEditVectorsDialog.I._app._csManager;
    renderer.Clear();
    csManager._cs.generate(crystalEditVectorsDialog.I._app.GetSymmetryIdxList());
    crystalEditVectorsDialog.I._app.UpdateStructureProperty();
    crystalEditVectorsDialog.I._app.UpdateRenderOptions();
    renderer._renderer._scene.children.pop();
    renderer._renderer._scene.add(csManager._cs._groupMesh);
  }

  /**
   * 현재 탭 인덱스를 반환한다.
   * @returns {Number} 현재 탭 인덱스
   * */
  GetActiveTabIndex() {
    return $(this._tabsLeft).tabs("option", "active");
  }

  /**
   * 선택된 vector를 선택된 crystallo에 추가한다.
   * @param {HTMLElement} selectedVector 선택된 vector
   * @param {HTMLElement} selectedCrystallo 선택된 crystallo
   */
  AddSelectedVectorToCrystallo(selectedVector, selectedCrystallo) {
    // get current selectedCrystallo vector string
    let crystalloStr = $(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_vector_idxs").html();
    let crystalloToken = crystalloStr.split(',');

    // get current selevcted vector number
    let number = $(selectedVector).find(".position").html();
    if (!crystalloToken.includes(number)) {
      // add number to selected crystallo
      rayLog(3, $(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_vector_idxs"));
      let res = "";
      if (crystalloStr.length > 0) res = crystalloStr + "," + number;else res = number;
      $(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_vector_idxs").html(res);
    }
  }

  /**
   * 선택된 vector를 선택된 individual에 추가한다.
   * @param {HTMLElement} selectedVector 선택된 vector
   * @param {HTMLElement} selectedIndividual 선택된 individual
   */
  AddSelectedVectorToIndividual(selectedVector, selectedIndividual) {
    let individualStr = $(selectedIndividual).find("#" + crystalEditVectorsDialog.I._name + "_individual_vector_idxs").html();
    let individualToken = individualStr.split(',');
    let number = $(selectedVector).find(".position").html();
    if (!individualToken.includes(number)) {
      let res = "";
      if (individualStr.length > 0) res = individualStr + "," + number;else res = number;
      $(selectedIndividual).find("#" + crystalEditVectorsDialog.I._name + "_individual_vector_idxs").html(res);
    }
  }

  /**
   * 선택된 crystallo로부터 vector를 제거한다.
   * @param {HTMLElement} selectedCrystallo 선택된 crystallo
   */
  RemoveVectorFromSelectedCrystallo(selectedCrystallo) {
    $(selectedCrystallo).find("#" + crystalEditVectorsDialog.I._name + "_crystallo_vector_idxs").html("");
  }

  /**
   * 선택된 individual로부터 vector를 제거한다.
   * @param {HTMLElement} selectedIndividual 선택된 individual
   */
  RemoveVectorFromSelectedIndividual(selectedIndividual) {
    $(selectedIndividual).find("#" + crystalEditVectorsDialog.I._name + "_individual_vector_idxs").html("");
  }

  /**
   * 테이블 업데이트
   * */
  UpdateTable() {
    this._crystal_graphic_sites_tab.UpdateTable();
    this._individual_atom_tab.UpdateTable();
    this._vectors_tab.UpdateTable();
  }

  /**
   * CStructure로부터 테이블을 복원한다.
   * */
  RestoreAddedVectorFromCS() {
    this.UpdateTable();
    // catom에 추가된 벡터 >> 

    // catom의 avectors를 순회한다.
    // avector의 def가 cs의 tvector의 어떤 것과 매칭되는지 판별
    // tvector의 index + 1의 값을 추가한다.
    for (let i = 0; i < this._app._csManager._cs._atoms.length; ++i) {
      let catom = this._app._csManager._cs._atoms[i];
      for (let j = 0; j < this._app._csManager._cs._atoms[i]._avectors.length; ++j) {
        let avector = catom._avectors[j];
        for (let k = 0; k < this._app._csManager._cs._tvectors.length; ++k) {
          if (avector._def === this._app._csManager._cs._tvectors[k]) {
            // atoms[i]에 해당하는 row에 k+1이라는 number를 추가하자.
            let row = this._crystal_graphic_sites_tab._crystal_graphic_site_table.getAllRow()[i];
            let txt = $(row).find("#" + this._name + "_crystallo_vector_idxs").text();
            if (txt.length) {
              txt += "," + (k + 1);
            } else txt += (k + 1).toString();
            $(row).find("#" + this._name + "_crystallo_vector_idxs").text(txt);
          }
        }
      }
    }

    // iatom에 추가된 벡터 >>

    // iatomList 순회
    // cs의 avectors에서 _index 조회
    // iatom의 index와 cs의 avectors의 index가 매칭되면 avector의 def에 해당하는 tvector의 index + 1 추가
    for (let i = 0; i < this._app._csManager._cs._iatomList.length; ++i) {
      let iatom = this._app._csManager._cs._iatomList[i];
      if (iatom._visible) {
        for (let j = 0; j < this._app._csManager._cs._avectors.length; ++j) {
          let avector = this._app._csManager._cs._avectors[j];
          // iatom의 index와 avector의 index가 같다면 avector._def에 해당하는 tvector의 index를 cs에서 찾아 index + 1을 추가
          if (iatom._index === avector._index && JSON.stringify(iatom._unitcellLoc) === JSON.stringify(avector._unitcellPos)) {
            let number = this._app._csManager._cs._tvectors.indexOf(avector._def);
            if (number >= 0) {
              number += 1;
              for (let k = 0; k < this._individual_atom_tab._individual_atom_table.getAllRow().length; ++k) {
                let idx = parseInt($(this._individual_atom_tab._individual_atom_table.getAllRow()[k]).find("#" + this._name + "_individual_atom_iatom_idx").text());
                if (idx === i) {
                  let row = this._individual_atom_tab._individual_atom_table.getAllRow()[k];
                  let txt = $(row).find("#" + this._name + "_individual_vector_idxs").text();
                  if (txt.split(",").includes(number.toString())) continue;
                  if (txt.length) {
                    txt += "," + number;
                  } else txt += number.toString();
                  $(row).find("#" + this._name + "_individual_vector_idxs").text(txt);
                }
              }
            }
          }
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalExportImageDialog.js


/**
 * 이미지를 외부로 내보내기 위한 UI 클래스
 */
class crystalExportImageDialog {
  /**
   * UI 초기화를 진행한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {cryUIApp} app 상위 앱 객체
   * @param {HTMLElement} div_elem cryUIDlgExportImage가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    // 앱 이름
    this._name = name;
    // 앱
    this._app = app;
    // 앱 루트 HTML DIV
    this._div = div_elem;

    // 다이얼로그 보이기 플래그
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnRadioByPixel = document.getElementById(name + "_radio_export_pixel");
    this._btnRadioByDPI = document.getElementById(name + "_radio_export_dpi");
    this._tabPixel = document.getElementById(name + "_tab_export_pixel");
    this._tabDPI = document.getElementById(name + "_tab_export_dpi");
    $(this._btnRadioByPixel).checkboxradio();
    $(this._btnRadioByDPI).checkboxradio();
    this._spinPixelWidth = document.getElementById(name + "_export_pixel_width");
    this._spinPixelHeight = document.getElementById(name + "_export_pixel_height");
    this._spinDPIWidth = document.getElementById(name + "_export_dpi_width");
    this._spinDPIHeight = document.getElementById(name + "_export_dpi_height");
    this._dropDPI = document.getElementById(name + "_export_dpi_select");
    this._imgWidth = "";
    this._imgHeight = "";
    crystalExportImageDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      height: "auto",
      width: "auto",
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Export Image",
      buttons: {
        "OK": function () {
          crystalExportImageDialog.I.OnOK();
        },
        "Cancel": function () {
          crystalExportImageDialog.I._dialog.dialog("close");
        }
      },
      close: function () {
        crystalExportImageDialog.I._show = false;
      }
    });
    $(this._btnRadioByPixel).click(function (event) {
      crystalExportImageDialog.I._tabPixel.style.display = "block";
      crystalExportImageDialog.I._tabDPI.style.display = "none";
    });
    $(this._btnRadioByDPI).click(function (event) {
      crystalExportImageDialog.I._tabPixel.style.display = "none";
      crystalExportImageDialog.I._tabDPI.style.display = "block";
    });
    $(this._spinPixelWidth).spinner({
      min: 32,
      max: 4096,
      step: 1
    });
    $(this._spinPixelWidth).spinner("value", 1024);
    $(this._spinPixelHeight).spinner({
      min: 32,
      max: 4096,
      step: 1
    });
    $(this._spinPixelHeight).spinner("value", 768);
    $(this._spinDPIWidth).spinner({
      min: 1,
      max: 30,
      step: 0.1
    });
    $(this._spinDPIWidth).spinner("value", 29.7);
    $(this._spinDPIHeight).spinner({
      min: 1,
      max: 30,
      step: 0.1
    });
    $(this._spinDPIHeight).spinner("value", 21.0);
    $(this._dropDPI).selectmenu({
      width: '112px'
    });
    $(this._btnRadioByPixel).prop("checked", true);
    $(this._btnRadioByPixel).checkboxradio("refresh");
    this._tabPixel.style.display = "block";
    this._tabDPI.style.display = "none";

    //this.ShowDialog();
  }

  /**
   * DlgExportImage에 대한 html element를 작성한다  
   * @param {String} name 다른 앱과 구분하기 위한 이름 
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<fieldset><table width='256px' height='200px' class='cryUI_Dlgs'><tr>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Widget_Spin'><label for='" + name + "_radio_export_pixel'>By Pixel</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='" + name + "_radio_export_by' id='" + name + "_radio_export_pixel'></td>";
    idx++;
    ihtml[idx] = "<td class='cryUI_Widget_Spin'><label for='" + name + "_radio_export_dpi'>By DPI</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='" + name + "_radio_export_by' id='" + name + "_radio_export_dpi'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td colspan='2'>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_tab_export_pixel'><fieldset><table height='120px'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Width</td><td><input id='" + name + "_export_pixel_width' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Height</td><td><input id='" + name + "_export_pixel_height' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td colspan='2'></td></tr></table></fieldset></div>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_tab_export_dpi'><fieldset><table height='120px'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>DPI</td><td><select id='" + name + "_export_dpi_select' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='150'>150</option><option value='300' selected>300</option><option value='600'>600</option></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Width (CM)</td><td><input id='" + name + "_export_dpi_width' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Height (CM)</td><td><input id='" + name + "_export_dpi_height' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "</table></fieldset></div></td></tr></table></fieldset>";
    idx++;
    return ihtml.join("");
  }

  /**
   * UI update를 수행한다
   * */
  UpdateUI() {}

  /**
   * 이미지 사이즈를 계산한다
   */
  CalcImageSize() {
    if ($(this._btnRadioByPixel).prop("checked")) {
      this._imgWidth = Number($(this._spinPixelWidth).val());
      this._imgHeight = Number($(this._spinPixelHeight).val());
    } else {
      var dpi = Number($(this._dropDPI).val());
      var cmw = Number($(this._spinDPIWidth).val());
      var cmh = Number($(this._spinDPIHeight).val());
      var pw = cmw / 2.54 * dpi;
      var ph = cmh / 2.54 * dpi;
      this._imgWidth = pw;
      this._imgHeight = ph;
    }
  }

  /**
   * 이미지 내보내기 기능을 수행한다 
   */
  OnOK() {
    this.CalcImageSize();
    rayLog(3, "Export Image with size = " + this._imgWidth + this._imgHeight);
    this._app.ExportRenderImage(this._imgWidth, this._imgHeight);
    this.CloseDialog();
  }

  /**
   * 다이얼로그를 띄운다
   */
  ShowDialog() {
    if (this._show) return;
    this.UpdateUI();
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그를 숨긴다
   */
  CloseDialog() {
    this._dialog.dialog("close");
    this._app.UpdateUI();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalInputTextDialog.js
/**
 * atom text 데이터 다이얼로그
 * */
class crystalInputTextDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalInputTextDialog가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalInputTextDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxHeight: 240,
      height: 240,
      maxWidth: 400,
      width: 400,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Text Input Dialog",
      buttons: {
        "OK": function () {
          crystalInputTextDialog.I.OnApply();
          crystalInputTextDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalInputTextDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalInputTextDialog.I._show = false;
      }
    });
    this._inputTxt = document.getElementById(name + "_atom_data_input_text");
  }

  /**
   * InputTextDialog에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div>";
    idx++;
    ihtml[idx] = "<textarea class='cryUI_InputTextDialog' id='" + name + "_atom_data_input_text' type='text'></textarea>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 다이얼로그를 띄운다.
   * */
  ShowDialog() {
    if (this._show) return;
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * 다이얼로그를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
    this._app.UpdateUI();
  }

  /**
   * 다이얼로그 내역을 적용시킨다.
   * */
  OnApply() {
    let txt = $(this._inputTxt).val();
    if (txt.length > 0) this._app._dlgEditData._bModified = true;
    crystalInputTextDialog.I._app.LoadAtomFromTxt(txt);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalMeasureTool.js
/**
 * 측정 도구 클래스
 * */
class crystalMeasureTool {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalMeasureTool이 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnRotate = document.getElementById(name + "_left_rotate");
    this._btnSelect = document.getElementById(name + "_left_select");
    //this._btnMove = document.getElementById(name + "_left_move");
    //this._btnMagnify = document.getElementById(name + "_left_magnify");

    this._btnDistance = document.getElementById(name + "_left_distance");
    this._btnAngle = document.getElementById(name + "_left_angle");
    //this._btnClearMeasure = document.getElementById(name + "_left_clear_measure");

    this._btnDihedral = document.getElementById(name + "_left_dihedral");
    this._btnInterfacial = document.getElementById(name + "_left_interfacial");
    $(this._btnRotate).button();
    $(this._btnSelect).button();
    $(this._btnMove).button();
    $(this._btnMagnify).button();
    $(this._btnDistance).button();
    $(this._btnAngle).button();
    $(this._btnClearMeasure).button();
    $(this._btnDihedral).button();
    $(this._btnInterfacial).button();
    $(this._btnRotate).css("background-image", "url(images/Icon_Rotate.png)");
    $(this._btnSelect).css("background-image", "url(images/Icon_Select.png)");
    //$(this._btnMove).css("background-image", "url(images/Icon_Translate.png)");
    //$(this._btnMagnify).css("background-image", "url(images/Icon_Magnify.png)");

    $(this._btnDistance).css("background-image", "url(images/Icon_Tool_Length.png)");
    $(this._btnAngle).css("background-image", "url(images/Icon_Tool_Angle.png)");
    //$(this._btnClearMeasure).css("background-image", "url(images/Icon_Tool_Delet.png)");

    $(this._btnDihedral).css("background-image", "url(images/Icon_Dihedral.png)");
    $(this._btnInterfacial).css("background-image", "url(images/Icon_Interfacial.png)");
    crystalMeasureTool.I = this;
    $(this._btnRotate).click(function (event) {
      crystalMeasureTool.I._app.MenuToolRotate();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnSelect).click(function (event) {
      crystalMeasureTool.I._app.MenuToolSelect();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnDistance).click(function (event) {
      crystalMeasureTool.I._app.MenuToolMeasureDistance();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnAngle).click(function (event) {
      crystalMeasureTool.I._app.MenuToolMeasureAngle();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnDihedral).click(function (event) {
      crystalMeasureTool.I._app.MenuToolMeasureAngleDihedral();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnInterfacial).click(function (event) {
      crystalMeasureTool.I._app.MenuToolMeasureAngleInterfacial();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
  }

  /**
   * MeasureTool에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    /*
    ihtml[idx] = "<table class='cryUI_leftToolbarTab'><tr>";
    idx++;
    ihtml[idx] = "<td><button title='Rotate' id='" + name + "_left_rotate' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Rotate</td>";
    idx++;
    ihtml[idx] = "<td><button title='Select' id='" + name + "_left_select' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Select</td>";
    idx++;
    ihtml[idx] = "<td><button title='Translate' id='" + name + "_left_move' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Translate</td>";
    idx++;
    ihtml[idx] = "<td><button title='Magnify' id='" + name + "_left_magnify' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Magnify</td>";
    idx++;
    ihtml[idx] = "<td><button title='Distance' id='" + name + "_left_distance' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Distance</td>";
    idx++;
    ihtml[idx] = "<td><button title='Angle' id='" + name + "_left_angle' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Angle</td>";
    idx++;
    ihtml[idx] = "<td><button title='Diheral id='" + name + "_left_diheral' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Diheral</td>";
    idx++;
    ihtml[idx] = "<td><button title='Interfacial' id='" + name + "_left_interfacial' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button>Interfacial</td>";
    idx++;
    ihtml[idx] = "</tr></table>";
    idx++;
    */
    ihtml[idx] = "<br/><br/><br/><br/><div align='center'>";
    idx++;
    ihtml[idx] = "<div><button title='Rotate' id='" + name + "_left_rotate' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "<div><button title='Select' id='" + name + "_left_select' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "<div><button title='Distance' id='" + name + "_left_distance' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "<div><button title='Angle' id='" + name + "_left_angle' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "<div><button title='Diheral' id='" + name + "_left_dihedral' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "<div><button title='Interfacial' id='" + name + "_left_interfacial' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 툴바 상태를 업데이트한다.
   * */
  UpdateToolbarState() {
    if (this._app._uiHandler) {
      if (this._app._uiHandler._mode === 0) $(this._btnRotate).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnRotate).removeClass("cryUI_topBar_Btn_Tool_Active");
      if (this._app._uiHandler._mode === 1) $(this._btnSelect).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnSelect).removeClass("cryUI_topBar_Btn_Tool_Active");
      if (this._app._uiHandler._bStartMeasureDistance) $(this._btnDistance).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnDistance).removeClass("cryUI_topBar_Btn_Tool_Active");
      if (this._app._uiHandler._bStartMeasureAngle) $(this._btnAngle).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnAngle).removeClass("cryUI_topBar_Btn_Tool_Active");
      if (this._app._uiHandler._bStartMeasureAngleDihedral) $(this._btnDihedral).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnDihedral).removeClass("cryUI_topBar_Btn_Tool_Active");
      if (this._app._uiHandler._bStartMeasureAngleInterfacial) $(this._btnInterfacial).addClass("cryUI_topBar_Btn_Tool_Active");else $(this._btnInterfacial).removeClass("cryUI_topBar_Btn_Tool_Active");
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalLeftToolBar.js


/**
 * 좌측 측정 모드 바
 * */
class crystalLeftToolBar {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalLeftToolBar가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = true;
    this._div.innerHTML = this._appElementHTML(name);
    this._div_visOptions = document.getElementById(name + "_left_visOption");
    this._viewVisOption = true;
    this._measureTool = new crystalMeasureTool(this._name, this._app, this._div_visOptions);
    crystalLeftToolBar.I = this;
  }
  /**
   * LeftToolBar에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div class='cryUI_VisOption_Title' id='" + name + "_left_visOption'></div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 툴바 상태를 업데이트한다.
   * */
  UpdateToolbarState() {
    if (this._measureTool) {
      this._measureTool.UpdateToolbarState();
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalLogBar.js
/**
 * log bar 클래스
 * */
class crystalLogBar {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalBoundarySettingDialog가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._show = true;
    this._div.innerHTML = this._appElementHTML(name);
    this._msgText = document.getElementById(name + "_cmdMsgText");
    this.SetShow(true);

    // this.AddMsgText("Log Bar Area");

    crystalLogBar.I = this;
  }

  /**
   * LogBar에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div class='cryUI_cmdBarMsgText' id='" + name + "_cmdMsgText'></div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * log bar visibility setting
   * @param {Boolean} show log bar visibility
   */
  SetShow(show) {
    this._show = show;
    if (this._show) {
      this._div.style.display = 'block';
    } else {
      this._div.style.display = 'none';
    }
    this._app.OnResize();
    // this._app.UpdateUI();
  }

  /**
   * log bar show toggle
   * */
  ToggleShow() {
    this.SetShow(!this._show);
  }

  /**
   * log bar clear
   * */
  ClearMsgText() {
    this._msgText.innerText = "";
  }
  /**
   * log bar add text
   * @param {String} txt
   */
  AddMsgText(txt) {
    this._msgText.innerText = txt;
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalNewConfirmDialog.js



class crystalNewConfirmDialog {
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._show = false;
    crystalNewConfirmDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      maxWidth: 240,
      maxHeight: 120,
      width: 240,
      height: 120,
      modal: true,
      closeOnEscape: true,
      resizable: false,
      title: "Clear Data",
      buttons: {
        "OK": function () {
          crystalNewConfirmDialog.I._app._csManager.ClearUndo();
          crystalNewConfirmDialog.I.OnApply();
          crystalNewConfirmDialog.I.CloseDialog();
        },
        "Cancel": function () {
          crystalNewConfirmDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalNewConfirmDialog.I._show = false;
      }
    });
  }
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div>Are you sure to clear current structure?</div>";
    idx++;
    return ihtml.join("");
  }
  ShowDialog() {
    if (this._show) return;
    this._dialog.dialog("open");
    this._show = true;
  }
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }
  OnApply() {
    cryst.RestoreDefault();
    this._app._csManager._cs = new CStructure();
    this._app.RestoreDefault();
    this._app._3dRender.Clear();
    this._app._csManager._cs.generate(this._app.GetSymmetryIdxList());
    this._app.UpdateStructureProperty();
    this._app.UpdateRenderOptions();
    for (let elem of this._app._3dRender._renderer._scene.children) {
      if (elem.name === "CStructure") this._app._3dRender._renderer._scene.remove(elem);
    }
    this._app._3dRender._renderer._scene.add(this._app._csManager._cs._groupMesh);
    this._app._dlgEditData._atomTable.clearAll();
    this._app._dlgEditData._shapeTable.clearAll();
    this._app._dlgEditData.DisableInput(true);
    this._app._dlgEditBond._bondTable.clearAll();
    this._app._dlgEditVectors._crystal_graphic_sites_tab._crystal_graphic_site_table.clearAll();
    this._app._dlgEditVectors._individual_atom_tab._individual_atom_table.clearAll();
    this._app._dlgEditVectors._vectors_tab._crystal_vectors_table.clearAll();
    this._app._dlgEditData.UpdateUnitcellByCS(this._app._csManager._cs);
    this._app._dlgBoundarySetting.UpdateBoundary();

    // object table update
    this._app._property.UpdateUI();
    this._app._3dRender._renderer.autofitCameraObjList([this._app._csManager._cs.getMesh()], 100);
    this._app._uiHandler.ClearAllMeasures();
    this._app._csManager.ClearUndo();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalPeriodicDialog.js






/**
 * 원소 주기율표 다이얼로그
 * */
class crystalPeriodicDialog {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalPeriodicDialog가 부착될 html element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._appElementHTML(name);
    this._show = false;
    crystalPeriodicDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      width: 930,
      height: 'auto',
      modal: true,
      closeOnEscape: true,
      buttons: {
        "Close": function () {
          crystalPeriodicDialog.I.CloseDialog();
        }
      },
      close: function () {
        crystalPeriodicDialog.I._show = false;
      },
      open: function () {}
    });
  }

  /**
   * PeriodicDialog에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    for (var i = 0; i < 162; i++) {
      ihtml[idx] = "<div class='pTableSpace' id='" + name + "_ptee_" + i + "'></div>";
      idx++;
    }
    for (var ai in AtomDef._atomDefList) {
      var aDef = AtomDef._atomDefList[ai];
      if (aDef._group === 0 || aDef._period === 0) continue;
      if (aDef._atom_number) {
        var idx = aDef._group - 1 + 18 * (aDef._period - 1);
        var css_color = "color: rgb(0, 0, 0);";
        if (aDef._color) {
          var r = parseInt(aDef._color[0] * 255.0);
          var g = parseInt(aDef._color[1] * 255.0);
          var b = parseInt(aDef._color[2] * 255.0);
          css_color = "color: rgb(" + r + "," + g + "," + b + ");";
        }
        var ehtml = "<div class='pTableElement' id='" + name + "_ptee_" + idx + "' atom_id='" + aDef._atom_id + "'>";
        ehtml += "<h4 class='periodic' id='" + name + "_favor_" + idx + "' atom_id='" + aDef._atom_id + "'>" + aDef._atom_number + "</h4>";
        ehtml += "<h3 class='periodic' style='" + css_color + "'>" + aDef._atom_id + "</h3></div>";
        ihtml[idx] = ehtml;
      }
    }
    this._div.innerHTML = ihtml.join("");
    for (var i = 0; i < 162; i++) {
      var elId = this._name + "_ptee_" + i;
      var el = document.getElementById(elId);
      if (el) {
        var cls = el.getAttribute("class");
        if (cls === "pTableElement") {
          el.addEventListener("mousedown", function (event) {
            var atom_id = event.currentTarget.getAttribute("atom_id");
            if (atom_id) {
              rayLog(3, "[DlgPeriodicTable] clicked atom " + atom_id);
              $('#' + crystalPeriodicDialog.I._app._dlgEditData._name + "_atom_symbol").val(atom_id);
              let color = AtomDef.GetDefWithID(atom_id.toUpperCase())._color;
              $('#' + crystalPeriodicDialog.I._app._dlgEditData._name + "_catom_color_picker").val(crystalVariable.HTMLColorRGB(color));
              $('#' + crystalPeriodicDialog.I._app._dlgEditData._name + "_catom_color_picker").css("background-color", "rgb(" + color[0] * 255 + "," + color[1] * 255 + "," + color[2] * 255 + ")");
              // tr 갱신하기
              crystalPeriodicDialog.I._app._dlgEditData.UpdateSelectedAtomByInput();
              crystalPeriodicDialog.I.CloseDialog();
            }
          });
        }
      }
    }
  }

  /**
   * periodic dialog를 보여준다.
   * */
  ShowDialog() {
    if (this._show) return;

    // this.UpdateUI();
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * dialog를 닫는다.
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._show = false;
  }

  /**
   * 즐겨찾기된 atom list를 반환한다.
   * */
  _getFavorAtomList() {
    var fa_list = [];
    for (var i = 0; i < 162; i++) {
      var is_favor = false;
      var favorId = this._name + "_favor_" + i;
      var fav_el = document.getElementById(favorId);
      if (fav_el) {
        var aid = fav_el.getAttribute("atom_id");
        if (aid && fav_el.className === "periodic_favor") {
          fa_list[aid] = aid;
        }
      }
    }
    this._fa_list = fa_list;
    return fa_list;
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalProgressDialog.js
/**
 * 작업 진행율 다이얼로그 UI 클래스
 * */
class crystalProgressDialog {
  /**
   * UI 초기화를 진행한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 앱 참조
   * @param {HTMLElement} div_elem crystalProgressDialog가 부착될 HTML Element
   * @param {HTMLElement} div_elem waiter object HTML Element
   */
  constructor(name, app, div_elem, div_waiter) {
    // 앱 이름
    this._name = name;

    // 앱
    this._app = app;

    // 앱 루트 HTML DIV
    this._div = div_elem;
    this._divWaiter = div_waiter;

    // 다이얼로그 보이기 플래그
    this._show = false;

    // 프로그레스 메시지
    this._msg = "";

    // 프로그레스 진행율 (%)
    this._ratio = 0;
    this._div.innerHTML = this._appElementHTML(name);
    this._divMsg = document.getElementById(name + "_dlgProgress_msg");
    this._divProgressBar = document.getElementById(name + "_dlgProgress_bar");
    this._divProgressLabel = document.getElementById(name + "_dlgProgress_label");
    crystalProgressDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      dialogClass: "no-close cryUI_Progress",
      height: "auto",
      width: "320px",
      position: {
        my: "center",
        at: "center",
        of: "#" + crystalProgressDialog.I._name + "_waiter"
      },
      modal: false,
      zIndex: 200,
      closeOnEscape: false,
      resizable: false,
      buttons: {
        "Cancel": function () {}
      },
      close: function () {
        this._show = false;
      }
    });
    this._progressBar = $(this._divProgressBar).progressbar({
      max: 1,
      change: function () {
        $(crystalProgressDialog.I._divProgressLabel).text(parseInt(parseFloat($(crystalProgressDialog.I._divProgressBar).progressbar("value")) * 100.0) + "%");
      }
    });
    this._progressBar.css("display", "none");
  }

  /**
   * Progress Dialog에 대한 html element를 작성한다
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @return {String} HTML 문자열 
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div class='cryUI_MsgBox_Msg' id = '" + name + "_dlgProgress_msg'></div>";
    idx++;
    ihtml[idx] = "<br/><div id = '" + name + "_dlgProgress_bar' style='position:relative;'>";
    idx++;
    ihtml[idx] = "<div id = '" + name + "_dlgProgress_label' style='position:absolute;left:50%;top:4px;'>...</div></div>";
    idx++;
    return ihtml.join("");
  }
  /**
   * 비동기 UI 업데이트 함수
   * @param {Number} msec 업데이트 대기 시간
   */
  async TSleep(msec) {
    return new Promise(resolve => setTimeout(resolve, msec));
  }

  /**
   * 다이얼로그를 보여준다
   * @param {String} title 다이얼로그 제목
   * @param {String} msg 다이얼로그 메시지
   */
  async ShowDialog(title, msg) {
    this._divMsg.innerText = msg;
    this._dialog.dialog("option", "title", title);
    this._dialog.dialog("open");
    this.SetProgress(0);
    this._show = true;
    this._divWaiter.style.visibility = "visible";
    await this.TSleep(10);

    //this._app.SetWaitForServerRequest();
  }

  /**
   * 다이얼로그 메시지를 설정한다
   * @param {String} msg 다이얼로그 메시지
   */
  async SetMsg(msg) {
    this._divMsg.innerText = msg;
    await this.TSleep(10);
  }

  /**
   * progress를 설정한다
   * @param {Number} ratio progress ratio
   */
  async SetProgress(ratio) {
    //kvis.Log("Set Progress " + ratio);
    this._progressBar.css("display", "block");
    this._progressBar.progressbar("value", ratio);
    await this.TSleep(10);
  }

  /**
   * 다이얼로그를 닫는다
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._divWaiter.style.visibility = "hidden";
    //this._app.ResetWaitForServerRequest();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalPropertyTool.js
/**
 * property tool 클래스
 * */
class crystalPropertyTool {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalPropertyTool이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalPropertyTool.I = this;
    // Tools Tab Btn
    //this._btnRotationModeDrag = document.getElementById(name + "_rotation_mode_1");
    //this._btnRotationModeAnimtaion = document.getElementById(name + "_rotation_mode_2");

    this._btnOrientationNoRotation = document.getElementById(name + "_orientation_mode_1");
    this._btnOrientationAroundXAxis = document.getElementById(name + "_orientation_mode_2");
    this._btnOrientationAroundYAxis = document.getElementById(name + "_orientation_mode_3");
    this._btnOrientationAroundZAxis = document.getElementById(name + "_orientation_mode_4");
    this._rotationMode = 0;
    this._orientationMode = -1;

    // Tools Tab Btn
    // $(this._btnRotationModeDrag).checkboxradio();
    // $(this._btnRotationModeAnimtaion).checkboxradio();

    $(this._btnOrientationNoRotation).checkboxradio();
    $(this._btnOrientationAroundXAxis).checkboxradio();
    $(this._btnOrientationAroundYAxis).checkboxradio();
    $(this._btnOrientationAroundZAxis).checkboxradio();
    for (let label of $(this._div).find("label")) {
      label.classList.add("cryUI_CheckRadio_Btn_NoBorder");
    }
    $(this._btnOrientationNoRotation).click(function (event) {
      crystalPropertyTool.I._orientationMode = -1;
    });
    $(this._btnOrientationNoRotation).prop("checked", true).checkboxradio('refresh');
    $(this._btnOrientationAroundXAxis).click(function (event) {
      crystalPropertyTool.I._orientationMode = 1;
    });
    $(this._btnOrientationAroundYAxis).click(function (event) {
      crystalPropertyTool.I._orientationMode = 0;
    });
    $(this._btnOrientationAroundZAxis).click(function (event) {
      crystalPropertyTool.I._orientationMode = 2;
    });
  }

  /**
   * PropertyTool에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    /*
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Rotation modes</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_rotation_mode_1'>Drag</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='rotation_mode' id='" + name + "_rotation_mode_1'>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_rotation_mode_2'>Animation</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='rotation_mode' id='" + name + "_rotation_mode_2'>";
    idx++;
    */
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Orientation</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_orientation_mode_1'>No rotation</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='orientation_mode' id='" + name + "_orientation_mode_1'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_orientation_mode_2'>Around X axis</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='orientation_mode' id='" + name + "_orientation_mode_2'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_orientation_mode_3'>Around Y axis</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='orientation_mode' id='" + name + "_orientation_mode_3'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_orientation_mode_4'>Around Z axis</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='orientation_mode' id='" + name + "_orientation_mode_4'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;

    /*
    ihtml[idx] = "</fieldset>";
    idx++;
    */
    ihtml[idx] = "</fieldset>";
    idx++;
    return ihtml.join("");
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalPropertyStyle.js



/**
 * property style 탭 클래스
 * */
class crystalPropertyStyle {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalPropertyStyle이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalPropertyStyle.I = this;
    this._showModels = false;
    this._showDotSurface = false;
    this._styleStructMode = null;
    this._showAtoms = true;
    this._showBonds = true;
    this._showSections = false;
    this._showIsoSurface = false;
    this._surfaceColoring = false;
    this._styleVolumeMode = null;
    this._showShapes = false;
    this._styleCrystalMode = null;

    // Structural style
    this._chkStructShowModels = document.getElementById(name + "_structural_modes_1");
    this._chkStructShowDotSurface = document.getElementById(name + "_structural_modes_2");
    this._chkStructuralStyle = [];
    this._chkStructuralStyle.push(document.getElementById(name + "_style_1"));
    this._chkStructuralStyle.push(document.getElementById(name + "_style_2"));
    this._chkStructuralStyle.push(document.getElementById(name + "_style_3"));
    this._chkStructuralStyle.push(document.getElementById(name + "_style_4"));
    this._chkStructuralStyle.push(document.getElementById(name + "_style_5"));
    this._chkAtomVisibility = document.getElementById(name + "_visibility_1");
    this._chkBondVisibility = document.getElementById(name + "_visibility_2");

    // Volumetric style
    this._chkVolumeShowSections = document.getElementById(name + "_volumetric_data_1");
    this._chkVolumeShowIsoSurface = document.getElementById(name + "_volumetric_data_2");
    this._chkVolumeSurfaceColoring = document.getElementById(name + "_volumetric_data_3");
    this._chkVolumetricStyle = [];
    this._chkVolumetricStyle.push(document.getElementById(name + "_volumetric_data_style_1"));
    this._chkVolumetricStyle.push(document.getElementById(name + "_volumetric_data_style_2"));
    this._chkVolumetricStyle.push(document.getElementById(name + "_volumetric_data_style_3"));

    // Crystal style
    this._chkCrystalShowShapes = document.getElementById(name + "_crystal_shapes_1");
    this._chkCrystalShapes = [];
    this._chkCrystalShapes.push(document.getElementById(name + "_crystal_shapes_style_1"));
    // this._chkCrystalShapes.push(document.getElementById(name + "_crystal_shapes_style_2"));
    this._chkCrystalShapes.push(document.getElementById(name + "_crystal_shapes_style_3"));
    this._btnProperties = document.getElementById(name + "_style_properties");
    this._btnBoundary = document.getElementById(name + "_style_boundary");
    // this._btnOrientation = document.getElementById(name + "_style_orientation");
    this._btnResize = document.getElementById(name + "_resizeable");

    // Style Tab Btn
    $(this._chkStructShowModels).checkboxradio();
    $(this._chkStructShowDotSurface).checkboxradio();
    for (let chkStructuralStyle of this._chkStructuralStyle) {
      $(chkStructuralStyle).checkboxradio();
    }
    $(this._chkVolumeShowSections).checkboxradio();
    $(this._chkVolumeShowIsoSurface).checkboxradio();
    $(this._chkVolumeSurfaceColoring).checkboxradio();
    for (let chkVolumetricStyle of this._chkVolumetricStyle) {
      $(chkVolumetricStyle).checkboxradio();
    }

    // Visibility
    $(this._chkAtomVisibility).checkboxradio();
    $(this._chkBondVisibility).checkboxradio();
    $(this._chkAtomVisibility).prop("checked", true);
    $(this._chkAtomVisibility).checkboxradio("refresh");
    $(this._chkBondVisibility).prop("checked", true);
    $(this._chkBondVisibility).checkboxradio("refresh");
    // Crystal shapes
    $(this._chkCrystalShowShapes).checkboxradio();
    for (let chkCrystalShapes of this._chkCrystalShapes) {
      $(chkCrystalShapes).checkboxradio();
    }

    // 하단 버튼
    $(this._btnProperties).button();
    $(this._btnBoundary).button();
    // $(this._btnOrientation).button();

    $(this._btnProperties).click(function () {
      // show property dialog
      crystalPropertyStyle.I._app._dlgStructureProperty.ShowDialog();
    });
    $(this._btnBoundary).click(function () {
      // show boundary setting dialog
      crystalPropertyStyle.I._app._dlgBoundarySetting.ShowDialog();
    });
    for (let label of $(this._div).find("label")) {
      label.classList.add("cryUI_CheckRadio_Btn_NoBorder");
    }
    for (let i = 0; i < this._chkStructuralStyle.length; ++i) {
      $(this._chkStructuralStyle[i]).change(function () {
        if (this.checked) {
          crystalPropertyStyle.I._app._csManager._cs.setRenderStyle(i);
          cryst.Style.StructuralMode = i;
          if (i === 2) {
            crystalPropertyStyle.I._app._csManager._cs.setVisiblePolyhedron(true);
          } else {
            crystalPropertyStyle.I._app._csManager._cs.setVisiblePolyhedron(false);
          }
        }
      });
    }
    $(this._chkCrystalShapes[0]).change(function () {
      let visible = $(crystalPropertyStyle.I._chkCrystalShowShapes).prop('checked');
      if (this.checked) {
        if (crystalPropertyStyle.I._app._csManager._cs._crystalShape._mesh) {
          crystalPropertyStyle.I._app._csManager._cs._crystalShape._mesh.material.wireframe = false;
        }

        // color는 crystal shape에 color picker를 다시 넣어서 거기서 가져오도록하자
        if (crystalPropertyStyle.I._app._csManager._cs._crystalShape) {
          crystalPropertyStyle.I._app._csManager._cs._crystalShape.dispose();
          crystalPropertyStyle.I._app._csManager._cs._crystalShape = null;
        }
        crystalPropertyStyle.I._app._csManager._cs._crystalShape = new CrystalShape(crystalPropertyStyle.I._app._csManager._cs._groupEtcMesh);
        crystalPropertyStyle.I._app._csManager._cs.generateCrystalShape();
        crystalPropertyStyle.I._app._csManager._cs._crystalShape.setColor(crystalPropertyStyle.I._app._dlgEditData._selectedShapeColor);
        crystalPropertyStyle.I._app._csManager._cs._crystalShape.setVisible(visible);
        crystalPropertyStyle.I._app._csManager._cs._crystalShape._visible = visible;
      }
    });
    $(this._chkCrystalShapes[1]).change(function () {
      if (this.checked) {
        if (crystalPropertyStyle.I._app._csManager._cs._crystalShape._mesh) {
          crystalPropertyStyle.I._app._csManager._cs._crystalShape._mesh.material.wireframe = true;
        }
      }
    });
    $(this._chkStructShowModels).click(function () {
      if (this.checked) {
        crystalPropertyStyle.I._app._csManager._cs.getMesh().visible = true;
        crystalPropertyStyle.I._app._csManager._cs.ClipBoundary();
      } else {
        crystalPropertyStyle.I._app._csManager._cs.getMesh().visible = false;
      }
    });
    $(this._chkAtomVisibility).click(function () {
      crystalPropertyStyle.I._app._csManager._cs._groupAtomMesh.visible = this.checked;
    });
    $(this._chkBondVisibility).click(function () {
      crystalPropertyStyle.I._app._csManager._cs._groupBondMesh.visible = this.checked;
    });
    $(this._chkStructShowDotSurface).click(function () {
      crystalPropertyStyle.I._app._csManager._cs.showDotSurface(this.checked);
      cryst.Style.ShowDotSurface = this.checked;
    });
    $(this._chkCrystalShowShapes).click(function () {
      crystalPropertyStyle.I._app._csManager._cs._crystalShape._visible = this.checked;
      crystalPropertyStyle.I._app._csManager._cs._crystalShape.setVisible(this.checked);
    });
    this.UpdateUI();
  }

  /**
   * PropertyStyle에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Structural models</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_structural_modes_1'>Show models</label>";
    idx++;
    ihtml[idx] = "<input type='checkbox' name='structural_modes_1' id='" + name + "_structural_modes_1'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_structural_modes_2'>Show dot surface</label>";
    idx++;
    ihtml[idx] = "<input type='checkbox' name='structural_modes_2' id='" + name + "_structural_modes_2'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Style</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_style_1'>Ball-and-stick</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='style' id='" + name + "_style_1'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_style_2'>Space-filling</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='style' id='" + name + "_style_2'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_style_3'>Polyhedral</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='style' id='" + name + "_style_3'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_style_4'>Wireframe</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='style' id='" + name + "_style_4'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_style_5'>Stick</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='style' id='" + name + "_style_5'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "</fieldset></fieldset>";
    idx++;
    ihtml[idx] = "<br><br><fieldset>";
    idx++;
    ihtml[idx] = "<legend>Visibility</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_visibility_1'>Show atoms</label>";
    idx++;
    ihtml[idx] = "<input type='checkbox' name='visibility' id='" + name + "_visibility_1'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_visibility_2'>Show bonds</label>";
    idx++;
    ihtml[idx] = "<input type='checkbox' name='visibility' id='" + name + "_visibility_2'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "</fieldset>";
    idx++;
    ihtml[idx] = "<br><br><fieldset>";
    idx++;
    ihtml[idx] = "<legend>Crystal shapes</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_crystal_shapes_1'>Show shapes</label>";
    idx++;
    ihtml[idx] = "<input type='checkbox' name='crystal_shapes' id='" + name + "_crystal_shapes_1'>";
    idx++;
    ihtml[idx] = "<fieldset>";
    idx++;
    ihtml[idx] = "<legend>Style</legend>";
    idx++;
    ihtml[idx] = "<label for='" + name + "_crystal_shapes_style_1'>Unicolor</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='crystal_shapes_style' id='" + name + "_crystal_shapes_style_1'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    /*
    ihtml[idx] = "<label for='" + name + "_crystal_shapes_style_2'>Custom color</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='crystal_shapes_style' id='" + name + "_crystal_shapes_style_2'>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    */
    ihtml[idx] = "<label for='" + name + "_crystal_shapes_style_3'>Wireframe</label>";
    idx++;
    ihtml[idx] = "<input type='radio' name='crystal_shapes_style' id='" + name + "_crystal_shapes_style_3'>";
    idx++;
    ihtml[idx] = "</fieldset></fieldset>";
    idx++;
    ihtml[idx] = "<br><br>";
    idx++;
    ihtml[idx] = "<button title='Properties' id='" + name + "_style_properties' class='ui-button ui-widget ui-corner-all cryUI_propertyBar_Btn_X2_Tool'>Properties</button>";
    idx++;
    ihtml[idx] = "<br>";
    idx++;
    ihtml[idx] = "<button title='Boundary' id='" + name + "_style_boundary' class='ui-button ui-widget ui-corner-all cryUI_propertyBar_Btn_X2_Tool'>Boundary...</button>";
    idx++;
    /*
    ihtml[idx] = "<button title='Orientation' id='" + name + "_style_orientation' class='ui-button ui-widget ui-corner-all cryUI_propertyBar_Btn_Tool'>Orientation...</button>";
    idx++;
    */
    return ihtml.join("");
  }

  /**
   * UI 업데이트
   * */
  UpdateUI() {
    // cryst에서 값 가져오기
    this._showModels = cryst.Style.ShowModel;
    this._showDotSurface = cryst.Style.ShowDotSurface;
    this._styleStructMode = cryst.Style.StructuralMode;
    this._showSections = cryst.Style.VolumetricSection;
    this._showIsoSurface = cryst.Style.VolumetricIsoSurface;
    this._surfaceColoring = cryst.Style.VolumetricSurfaceColor;
    this._styleVolumeMode = cryst.Style.VolumetricMode;
    this._showShapes = cryst.Style.ShowCrystalShape;
    this._styleCrystalMode = cryst.Style.CrystalMode;

    // 상황에 맞게 ui 설정
    $(this._chkStructShowModels).prop("checked", cryst.Style.ShowModel);
    $(this._chkStructShowModels).checkboxradio("refresh");
    $(this._chkStructShowDotSurface).prop("checked", cryst.Style.ShowDotSurface);
    $(this._chkStructShowDotSurface).checkboxradio("refresh");
    for (let i = 0; i < this._chkStructuralStyle.length; ++i) {
      $(this._chkStructuralStyle[i]).prop("checked", false);
    }
    $(this._chkStructuralStyle[cryst.Style.StructuralMode]).prop("checked", true);
    for (let i = 0; i < this._chkStructuralStyle.length; ++i) {
      $(this._chkStructuralStyle[i]).checkboxradio("refresh");
    }
    $(this._chkVolumeShowSections).prop("checked", cryst.Style.VolumetricSection);
    $(this._chkVolumeShowSections).checkboxradio("refresh");
    $(this._chkVolumeShowIsoSurface).prop("checked", cryst.Style.VolumetricIsoSurface);
    $(this._chkVolumeShowIsoSurface).checkboxradio("refresh");
    $(this._chkVolumeSurfaceColoring).prop("checked", cryst.Style.VolumetricSurfaceColor);
    $(this._chkVolumeSurfaceColoring).checkboxradio("refresh");
    for (let i = 0; i < this._chkVolumetricStyle.length; ++i) {
      $(this._chkVolumetricStyle[i]).prop("checked", false);
    }
    $(this._chkVolumetricStyle[cryst.Style.VolumetricMode]).prop("checked", true);
    for (let i = 0; i < this._chkVolumetricStyle.length; ++i) {
      $(this._chkVolumetricStyle[i]).checkboxradio("refresh");
    }
    $(this._chkCrystalShowShapes).prop("checked", cryst.Style.ShowCrystalShape);
    $(this._chkCrystalShowShapes).checkboxradio("refresh");
    for (let i = 0; i < this._chkCrystalShapes.length; ++i) {
      $(this._chkCrystalShapes[i]).prop("checked", false);
    }
    $(this._chkCrystalShapes[cryst.Style.CrystalMode]).prop("checked", true);
    for (let i = 0; i < this._chkCrystalShapes.length; ++i) {
      $(this._chkCrystalShapes[i]).checkboxradio("refresh");
    }
  }

  /**
   * 기본값 복원
   * */
  RestoreDefaults() {
    cryst.RestoreDefaults();
    this.UpdateUI();
    this.OnApply();
  }
  OnApply() {
    this._app._csManager._cs.setRenderStyle(cryst.Style.StructuralMode);
    if (cryst.Style.StructuralMode === 2) {
      this._app._csManager._cs.setVisiblePolyhedron(true);
    } else {
      this._app._csManager._cs.setVisiblePolyhedron(false);
    }
    if ($(this._chkCrystalShapes[0]).prop('checked') === true) {
      if (this._app._csManager._cs._crystalShape._mesh) {
        this._app._csManager._cs._crystalShape._mesh.material.wireframe = false;
      }
      // color는 crystal shape에 color picker를 다시 넣어서 거기서 가져오도록하자
      if (this._app._csManager._cs._crystalShape) {
        this._app._csManager._cs._crystalShape.dispose();
        this._app._csManager._cs._crystalShape = null;
      }
      this._app._csManager._cs._crystalShape = new CrystalShape(this._app._csManager._cs._groupEtcMesh);
      this._app._csManager._cs.generateCrystalShape();
      this._app._csManager._cs._crystalShape.setColor(this._app._dlgEditData._selectedShapeColor);
    } else {
      if (this._app._csManager._cs._crystalShape._mesh) {
        this._app._csManager._cs._crystalShape._mesh.material.wireframe = true;
      }
    }
    if ($(this._chkCrystalShapes[1]).prop('checked') === true) {
      if (this._app._csManager._cs._crystalShape._mesh) {
        this._app._csManager._cs._crystalShape._mesh.material.wireframe = true;
      }
    }
    ;
    if ($(this._chkStructShowModels).prop('checked') === true) {
      this._app._csManager._cs.getMesh().visible = true;
      this._app._csManager._cs.ClipBoundary();
    } else {
      this._app._csManager._cs.getMesh().visible = false;
    }
    this._app._csManager._cs._groupAtomMesh.visible = $(this._chkAtomVisibility).prop('checked');
    this._app._csManager._cs._groupBondMesh.visible = $(this._chkBondVisibility).prop('checked');
    this._app._csManager._cs.showDotSurface($(this._chkStructShowDotSurface).prop('checked'));
    this._app._csManager._cs._crystalShape._visible = $(this._chkCrystalShowShapes).prop('checked');
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalPropertyObject.js





/**
 * Property Object 클래스
 * */
class crystalPropertyObject {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalPropertyObject가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    crystalPropertyObject.I = this;
    this._div_object_data_table = document.getElementById(name + "_object_data_table_area");
    this.CreateObjectTable();
  }

  /**
   * PropertyObject에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름 
   * @returns {String} html element string
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    // atom 정보 테이블
    ihtml[idx] = "<div class='cryUI_Edit_Structure_Table_Area' id='" + name + "_object_data_table_area'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * Object Tab에 테이블을 추가한다.
   * */
  CreateObjectTable() {
    this._objectDataTable = new crystalTable(this._name, this._app, this._div_object_data_table, "objects_table");
    this._objectDataTable.createHeader("\
            <tr>\
                <th class='cryUI_Big_Td_With_Margin'>Site</th>\
                <th class='cryUI_Big_Td_With_Margin'>r(A)</th>\
                <th class='cryUI_Small_Td'>C</th>\
                <th class='cryUI_Small_Td'>V</th>\
            </tr>", false);
  }

  /**
   * UI 업데이트
   * */
  UpdateUI() {
    let csManager = crystalPropertyObject.I._app._csManager;
    this._objectDataTable.clearAll();
    this._objectDataTable.updateTable();

    /**
     * atoms의 정보를 모두 수집한다 => main tr에 child tr을 추가하는 방식으로 구성한다.
     * main tr에 이벤트 리스너를 달아 child tr이 expand / shrink 되도록 만든다.
     *
     * 1. atom symbol이 같은 element들을 따로 모은다.
     * 2. table 추가 시 main tr은 그대로, child tr은 display:none 속성을 추가하여 집어넣는다.
     *
     */
    let atomDict = {};
    for (let atom of csManager._cs._atoms) {
      let atomDef = AtomDef_AtomDef.GetDefWithNumber(atom._id);
      if (!atomDict[atomDef._atom_number]) atomDict[atomDef._atom_number] = [];
      atomDict[atomDef._atom_number].push(atom);
    }
    for (let key in atomDict) {
      let atomDef = AtomDef_AtomDef.GetDefWithNumber(key);
      let visibleChk = true;
      for (let atom of atomDict[key]) {
        if (atom._visible === false) {
          visibleChk = false;
          break;
        }
      }
      let headHTML = "\
                <tr class='sortable' id='" + this._name + "_" + atomDef._id + "_object_data_parent'>\
            	<td class='position cryUI_Normal_Td' style='display:none'></td>\
                <td class='cryUI_Big_Td_With_Margin'><button class='cryUI_Float_Left' id='" + this._name + "_" + atomDef._id + "_object_button_parent'>ᐳ</button>" + atomDef._id + "</td>\
                <td class='cryUI_Big_Td_With_Margin'>" + atomDef._radius + "</td>\
                <td class='cryUI_Small_Td' id='" + this._name + "_" + atomDef._id + "_object_data_color_parent'></td>\
                <td class='cryUI_Small_Td'><input type='checkbox' id='" + this._name + "_" + atomDef._id + "_object_data_visible_parent'></td>\
                </tr>";
      this._objectDataTable.appInnerHTML(headHTML, false);
      // $("#" + this._name + "_" + atomDef._id + "_object_data_color_parent").css("background-color", '#' + crystalVariable.ColorRGBtoHexNum(atomDef._color));
      $("#" + this._name + "_" + atomDef._id + "_object_data_visible_parent").prop("checked", visibleChk);
      for (let atom of atomDict[key]) {
        // 특정 atom임을 구분할 수 있는 정보가 필요하다.
        let atomDef = AtomDef_AtomDef.GetDefWithNumber(atom._id);
        let childHTML = "\
                	<tr class='sortable' id='" + this._name + "_" + atomDef._id + "_object_data_child" + "_" + atom._idx + "' style='display:none'>\
                	<td class='position cryUI_Normal_Td' style='display:none'></td>\
                    <td class='cryUI_Big_Td_With_Margin'>" + atom._label + "</td>\
                    <td class='cryUI_Big_Td_With_Margin'>" + atomDef._radius + "</td>\
                    <td class='cryUI_Small_Td' id='" + this._name + "_" + atomDef._id + "_object_data_color_child" + "_" + atom._idx + "'></td>\
                    <td class='cryUI_Small_Td'><input type='checkbox' id='" + this._name + "_" + atomDef._id + "_object_data_visible_child" + "_" + atom._idx + "'></td>\
                    </tr>";
        this._objectDataTable.appInnerHTML(childHTML, false);
        $("#" + this._name + "_" + atomDef._id + "_object_data_color_child" + "_" + atom._idx).css("background-color", '#' + crystalVariable.HTMLColorRGB([atom._color[0], atom._color[1], atom._color[2]]));
        $("#" + this._name + "_" + atomDef._id + "_object_data_visible_child" + "_" + atom._idx).prop("checked", atom._visible);
        $("#" + this._name + "_" + atomDef._id + "_object_data_visible_child" + "_" + atom._idx).on("click", function () {
          let idx = atom._idx;
          let csAtom = csManager._cs.getAtomByIdx(idx);
          if ($(this).is(':checked')) {
            csAtom._visible = true;
            for (let i = 0; i < csManager._cs._iatomList.length; ++i) {
              if (csManager._cs._iatomList[i]._def === csAtom) {
                csManager._cs._iatomList[i].setVisible(true);
              }
            }
          } else {
            if ($("#" + crystalPropertyObject.I._name + "_" + atomDef._id + "_object_data_visible_parent").prop("checked")) {
              $("#" + crystalPropertyObject.I._name + "_" + atomDef._id + "_object_data_visible_parent").prop("checked", false);
            }
            csAtom._visible = false;
            for (let i = 0; i < csManager._cs._iatomList.length; ++i) {
              if (csManager._cs._iatomList[i]._def === csAtom) {
                csManager._cs._iatomList[i].setVisible(false);
              }
            }
          }

          // crystalPropertyObject.I.generateStructure();
        });
      }

      let name = this._name;
      let id = atomDef._id;
      $("#" + name + "_" + id + "_object_button_parent").on("click", function () {
        if ($(this).text() === "ᐳ") $(this).text("ᐯ");else $(this).text("ᐳ");
        $("tr[id^='" + name + "_" + id + "_object_data_child']").each(function () {
          if ($(this).css("display") == "none") {
            $(this).show();
          } else {
            $(this).hide();
          }
        });
      });
      $("#" + name + "_" + id + "_object_data_visible_parent").change(function () {
        if ($(this).is(':checked')) {
          // 모두 체크
          $("input[id^='" + name + "_" + id + "_object_data_visible_child']").each(function () {
            $(this).prop("checked", true);
            let tokens = $(this).attr('id').split('_');
            let idx = parseInt(tokens[tokens.length - 1]);
            let csAtom = csManager._cs.getAtomByIdx(idx);
            csAtom._visible = true;
            for (let i = 0; i < csManager._cs._iatomList.length; ++i) {
              if (csManager._cs._iatomList[i]._def === csAtom) {
                csManager._cs._iatomList[i].setVisible(true);
              }
            }
          });
        } else {
          // 모두 체크 해제
          $("input[id^='" + name + "_" + id + "_object_data_visible_child']").each(function () {
            $(this).prop("checked", false);
            let tokens = $(this).attr('id').split('_');
            let idx = parseInt(tokens[tokens.length - 1]);
            let csAtom = csManager._cs.getAtomByIdx(idx);
            csAtom._visible = false;
            for (let i = 0; i < csManager._cs._iatomList.length; ++i) {
              if (csManager._cs._iatomList[i]._def === csAtom) {
                csManager._cs._iatomList[i].setVisible(false);
              }
            }
          });
        }
        // crystalPropertyObject.I.generateStructure();
      });
    }
  }

  /**
   * 원자 중 가시화 옵션이 활성화된 인덱스리스트를 반환한다.
   * 
   * @returns {Array} 가시화 옵션이 활성화된 원자 인덱스 리스트
   * */
  GetVisibleIdxList() {
    let idxList = [];

    // get all rows
    let rows = this._objectDataTable.getAllRow();

    // get idx from each row
    for (let row of rows) {
      // visible input이 체크 안 된 경우
      if (!$(row).find("input")[0].checked) continue;
      let tokens = row.id.split('_');
      let idx = parseInt(tokens[tokens.length - 1]);
      if (isNaN(idx)) continue;
      idxList.push(idx);
    }
    return idxList;
  }
  generateStructure() {
    let renderer = this._app._3dRender;
    let csManager = this._app._csManager;
    renderer.Clear();
    csManager._cs.generate(this._app.GetSymmetryIdxList());
    csManager._cs.ClipBoundary(cryst.Mode.Boundary);
    this._app.UpdateStructureProperty();
    this._app.UpdateRenderOptions();
    renderer._renderer._scene.children.pop();
    renderer._renderer._scene.add(csManager._cs._groupMesh);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalPropertyBar.js





/**
 * Property 모음 클래스
 * */
class crystalPropertyBar {
  /**
   * UI 초기화를 진행한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {cryUIApp} app 상위 앱 객체
   * @param {HTMLElement} div_elem cryUILeftBar가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    // 앱 이름
    this._name = name;

    // 앱
    this._app = app;

    // 앱 루트 HTML DIV
    this._div = div_elem;
    this._show = true;
    this._div.innerHTML = this._appElementHTML(name);
    crystalPropertyBar.I = this;
    this._tabsPref = document.getElementById(name + "_pref_Tabs");
    $(this._tabsPref).tabs({
      active: 0
    });
    $(this._btnResize).resizable({
      maxHeight: 250,
      maxWidth: 350,
      minHeight: 150,
      minWidth: 200
    });
    this._div_tab1 = document.getElementById(name + "_pref_Tab1");
    this._div_tab2 = document.getElementById(name + "_pref_Tab2");
    this._div_tab3 = document.getElementById(name + "_pref_Tab3");
    this._propertyTool = new crystalPropertyTool(name, app, this._div_tab1);
    this._propertyStyle = new crystalPropertyStyle(name, app, this._div_tab2);
    this._propertyObject = new crystalPropertyObject(name, app, this._div_tab3);
  }

  /**
   * LeftBar에 대한 html element를 작성한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div id='" + name + "_pref_Tabs' style='height:100%'>";
    idx++;
    ihtml[idx] = "<ul>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_pref_Tab1' class='cryUI_TabBtn'>Tools</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_pref_Tab2' class='cryUI_TabBtn'>Style</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_pref_Tab3' class='cryUI_TabBtn'>Objects</a></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    // Property - Tab1 - Tools
    ihtml[idx] = "<div id='" + name + "_pref_Tab1' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // Property - Tab2 - Style
    ihtml[idx] = "<div id='" + name + "_pref_Tab2' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;

    // Property - Tab3 - Objects
    ihtml[idx] = "<div id='" + name + "_pref_Tab3' class='cryUI_Tabs' style='height:100%; overflow-y:scroll; overflow-x:hidden'>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * UI 업데이트
   * */
  UpdateUI() {
    /*
    if (this._propertyTool)
        this._propertyTool.UpdateUI();
    */

    if (this._propertyStyle) this._propertyStyle.UpdateUI();
    if (this._propertyObject) this._propertyObject.UpdateUI();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalRenderOptionDialog.js



/**
 * Render Options 설정을 위한 다이얼로그 UI 클래스
 * */
class crystalRenderOptionDialog {
  /**
   * UI 초기화를 진행한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem cadUIDlgSetting이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    // 앱 이름
    this._name = name;
    // 앱
    this._app = app;
    // 앱 루트 HTML DIV
    this._div = div_elem;

    // 다이얼로그 보이기 플래그
    this._show = false;
    this._selectedColorBackground = [0, 0, 0];
    this._div.innerHTML = this._appElementHTML(name);
    this._tabsPref = document.getElementById(name + "_render_option_Tabs");
    this._divPrefViewer = document.getElementById(name + "_render_option_Tab1");
    this._colorBackground = document.getElementById(name + "_render_option_color_background");
    this._checkShowAxis = document.getElementById(name + "_render_option_check_show_axis");
    this._dropLighting = document.getElementById(name + "_render_option_lighting");
    this._dropCameraType = document.getElementById(name + "_render_option_camera_type");
    this._dropAntialiasing = document.getElementById(name + "_render_option_antialiasing");
    this._dropAtomStyle = document.getElementById(name + "_render_option_atom_style");
    this._dropBondStyle = document.getElementById(name + "_render_option_bond_style");
    crystalRenderOptionDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      height: "auto",
      width: "auto",
      modal: false,
      closeOnEscape: true,
      resizable: false,
      title: "Render Options",
      buttons: {
        "Restore Defaults": function () {
          crystalRenderOptionDialog.I.RestoreDefaults();
        },
        "OK": function () {
          crystalRenderOptionDialog.I.OnApply();
          crystalRenderOptionDialog.I._dialog.dialog("close");
        },
        "Cancel": function () {
          crystalRenderOptionDialog.I._dialog.dialog("close");
        },
        "Apply": function () {
          crystalRenderOptionDialog.I.OnApply();
        }
      },
      close: function () {
        crystalRenderOptionDialog.I._show = false;
      }
    });
    $(this._tabsPref).tabs({
      active: 0
    });
    $(this._colorBackground).colorpicker({
      modal: true,
      buttonColorize: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
        crystalRenderOptionDialog.I.OnChangeColorBackground([formatted.rgb["r"], formatted.rgb["g"], formatted.rgb["b"]]);
      }
    });
    $(this._checkShowAxis).checkboxradio();
    $(this._dropLighting).selectmenu({
      width: '128px',
      change: function (event, ui) {
        crystalRenderOptionDialog.I.OnChangeLightingMode(crystalRenderOptionDialog.I._dropLighting.value);
      }
    });
    $(this._dropCameraType).selectmenu({
      width: '128px',
      change: function (event, ui) {
        crystalRenderOptionDialog.I.OnChangeCameraType(crystalRenderOptionDialog.I._dropCameraType.value);
      }
    });
    $(this._dropAntialiasing).selectmenu({
      width: '128px',
      change: function (event, ui) {
        crystalRenderOptionDialog.I.OnChangeAntialiasingMode(crystalRenderOptionDialog.I._dropAntialiasing.value);
      }
    });
    $(this._dropAtomStyle).selectmenu({
      width: '128px',
      change: function (event, ui) {
        crystalRenderOptionDialog.I.OnChangeAtomStyle(crystalRenderOptionDialog.I._dropAtomStyle.value);
      }
    });
    $(this._dropBondStyle).selectmenu({
      width: '128px',
      change: function (event, ui) {
        crystalRenderOptionDialog.I.OnChangeBondStyle(crystalRenderOptionDialog.I._dropBondStyle.value);
      }
    });
  }
  /**
   * Setting Dialog에 대한 html element를 작성한다
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @return {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<div id='" + name + "_render_option_Tabs'>";
    idx++;
    ihtml[idx] = "<ul>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_render_option_Tab1' class='cryUI_TabBtn'>Environment</a></li>";
    idx++;
    ihtml[idx] = "<li><a href='#" + name + "_render_option_Tab2' class='cryUI_TabBtn'>Options</a></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_render_option_Tab1' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "<fieldset><table width='320px' height='200px'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Background Color</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_render_option_color_background' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Show Axis</td>";
    idx++;
    ihtml[idx] = "<td><label for='" + name + "_render_option_check_show_axis'></label><input type='checkbox' id='" + name + "_render_option_check_show_axis'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Lighting Option</td>";
    idx++;
    ihtml[idx] = "<td><select id='" + name + "_render_option_lighting' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='1'>Light Option 1</option><option value='2'>Light Option 2</option><option value='3'>Light Option 3</select></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'></td><td>&nbsp;</td></tr>";
    idx++;
    ihtml[idx] = "</table></fieldset></div>";
    idx++;
    ihtml[idx] = "<div id='" + name + "_render_option_Tab2' class='cryUI_Tabs'>";
    idx++;
    ihtml[idx] = "<fieldset><table width='320px' height='200px'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Camera Type</td>";
    idx++;
    ihtml[idx] = "<td><select id='" + name + "_render_option_camera_type' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='0'>Orthogonal</option><option value='1'>Perspective</option></select></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Anti-Aliasing</td>";
    idx++;
    ihtml[idx] = "<td><select id='" + name + "_render_option_antialiasing' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='1'>On</option><option value='0'>Off</option></select></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Atom Style</td>";
    idx++;
    ihtml[idx] = "<td><select id='" + name + "_render_option_atom_style' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='1'>Normal</option><option value='0'>Flat</option></select></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle'>Bond Style</td>";
    idx++;
    ihtml[idx] = "<td><select id='" + name + "_render_option_bond_style' class='cryUI_Widget_Spin'>";
    idx++;
    ihtml[idx] = "<option value='1'>Normal</option><option value='0'>Flat</option></select></td></tr>";
    idx++;
    ihtml[idx] = "</table></fieldset></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    return ihtml.join("");
  }
  /**
   * UI를 갱신한다
   * */
  UpdateUI() {
    if (!this._app._renderOptions) return;
    const renderOptions = this._app._renderOptions;
    this._selectedColorBackground = [renderOptions.BackgroundColor[0], renderOptions.BackgroundColor[1], renderOptions.BackgroundColor[2]];
    var c_back = crystalVariable.HTMLColorRGB(this._selectedColorBackground);
    $(this._colorBackground).prop("value", c_back);
    $(this._colorBackground).css("background-color", "#" + c_back);
    $(this._checkShowAxis).prop("checked", renderOptions.ShowAxis === 1);
    $(this._checkShowAxis).checkboxradio("refresh");
    $(this._dropLighting).val(renderOptions.LightingMode);
    $(this._dropLighting).selectmenu("refresh");
    $(this._dropCameraType).val(renderOptions.CameraType);
    $(this._dropCameraType).selectmenu("refresh");
    $(this._dropAntialiasing).val(renderOptions.Antialiasing);
    $(this._dropAntialiasing).selectmenu("refresh");
    $(this._dropAtomStyle).val(renderOptions.AtomStyle);
    $(this._dropAtomStyle).selectmenu("refresh");
    $(this._dropBondStyle).val(renderOptions.BondStyle);
    $(this._dropBondStyle).selectmenu("refresh");
  }
  /**
   * Setting 기본값을 복원한다
   * */
  RestoreDefaults() {
    this._app.InitRenderOptions();
    this.UpdateUI();
  }
  /**
   * 설정값을 적용한다
   * */
  OnApply() {
    if (!this._app._renderOptions) return;
    const renderOptions = this._app._renderOptions;
    renderOptions.BackgroundColor = [this._selectedColorBackground[0], this._selectedColorBackground[1], this._selectedColorBackground[2]];
    renderOptions.ShowAxis = $(this._checkShowAxis).prop("checked") ? 1 : 0;
    renderOptions.LightingMode = parseInt($(this._dropLighting).val());
    renderOptions.CameraType = parseInt($(this._dropCameraType).val());
    renderOptions.Antialiasing = parseInt($(this._dropAntialiasing).val());
    renderOptions.AtomStyle = parseInt($(this._dropAtomStyle).val());
    renderOptions.BondStyle = parseInt($(this._dropBondStyle).val());
    rayLog(3, "[renderoption] change applied JSON " + JSON.stringify(renderOptions));
    this._app.UpdateRenderOptions();
    this._app.UpdateUI();
  }
  /**
   * 배경색을 변경한다
   * @param {Color} col 색상값
   */
  OnChangeColorBackground(col) {
    rayLog(3, "[renderoption] change color background " + col[0] + "," + col[1] + "," + col[2]);
    this._selectedColorBackground = col;
  }
  OnChangeLightingMode(val) {
    rayLog(3, "[renderoption] change lighting mode " + val);
  }
  OnChangeCameraType(val) {
    rayLog(3, "[renderoption] change camera type " + val);
  }
  OnChangeAntialiasingMode(val) {
    rayLog(3, "[renderoption] change anti-aliasing mode " + val);
  }
  OnChangeAtomStyle(val) {
    rayLog(3, "[renderoption] change atom style " + val);
  }
  OnChangeBondStyle(val) {
    rayLog(3, "[renderoption] change bond style " + val);
  }

  /**
   * setting dialog를 보여준다
   * */
  ShowDialog() {
    if (this._show) return;
    this.UpdateUI();
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * dialog를 닫는다
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._app.UpdateUI();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalLabelManager.js


/**
 * 라벨 관리 클래스
 * */
class crystalLabelManager {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   */
  constructor(app) {
    this._app = app;
    this._canvas = this._app._canvas;
    this._xLabel = null;
    this._yLabel = null;
    this._zLabel = null;
    this.clearAll();
  }

  /**
   * axis label 생성
   * */
  createLabelForAxis() {
    let x = this._app._3dRender._renderer._axisGeom.getXPoint();
    let y = this._app._3dRender._renderer._axisGeom.getYPoint();
    let z = this._app._3dRender._renderer._axisGeom.getZPoint();

    // worldToScreen
    let px = this._app._3dRender.WorldToScreen(x);
    let py = this._app._3dRender.WorldToScreen(y);
    let pz = this._app._3dRender.WorldToScreen(z);
    let xLabel = document.createElement("div");
    let yLabel = document.createElement("div");
    let zLabel = document.createElement("div");
    xLabel.classList.add("cryUI_LabelText");
    yLabel.classList.add("cryUI_LabelText");
    zLabel.classList.add("cryUI_LabelText");
    xLabel.innerHTML = cryst.Name.Axis.X;
    yLabel.innerHTML = cryst.Name.Axis.Y;
    zLabel.innerHTML = cryst.Name.Axis.Z;
    this._app._3dRender._div.appendChild(xLabel);
    this._app._3dRender._div.appendChild(yLabel);
    this._app._3dRender._div.appendChild(zLabel);
    xLabel.style.left = px.x.toFixed(0) + "px";
    xLabel.style.top = px.y.toFixed(0) + "px";
    xLabel.style.zIndex = 3;
    xLabel.style.backgroundColor = "";
    this._xLabel = xLabel;
    yLabel.style.left = py.x.toFixed(0) + "px";
    yLabel.style.top = py.y.toFixed(0) + "px";
    yLabel.style.zIndex = 3;
    yLabel.style.backgroundColor = "";
    this._yLabel = yLabel;
    zLabel.style.left = pz.x.toFixed(0) + "px";
    zLabel.style.top = pz.y.toFixed(0) + "px";
    zLabel.style.zIndex = 3;
    zLabel.style.backgroundColor = "";
    this._zLabel = zLabel;
  }

  /**
   * axis label 제거
   * */
  clearAll() {
    if (this._xLabel) this._xLabel.remove();
    if (this._yLabel) this._yLabel.remove();
    if (this._zLabel) this._zLabel.remove();
  }

  /**
   * 후처리 작업
   * */
  _postRender() {
    let x = this._app._3dRender._renderer._axisGeom._apx.clone(); //GetXPoint();
    let px = this._app._3dRender.WorldToScreen(x);
    this._xLabel.style.left = px.x.toFixed(0) + "px";
    this._xLabel.style.top = px.y.toFixed(0) + "px";
    let y = this._app._3dRender._renderer._axisGeom._apy.clone(); //GetYPoint();
    let py = this._app._3dRender.WorldToScreen(y);
    this._yLabel.style.left = py.x.toFixed(0) + "px";
    this._yLabel.style.top = py.y.toFixed(0) + "px";
    let z = this._app._3dRender._renderer._axisGeom._apz.clone(); //GetZPoint();
    let pz = this._app._3dRender.WorldToScreen(z);
    this._zLabel.style.left = pz.x.toFixed(0) + "px";
    this._zLabel.style.top = pz.y.toFixed(0) + "px";
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUndoStack.js



/**
 * 언두 스택 관리 클래스
 */
class crystalUndoStack {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   */
  constructor(app) {
    this._app = app;
    this._maxUndo = 10;
    this._undo = [];
    this._redo = [];
    this.Clear();
  }

  /**
   * Undo / Redo Stack을 클리어한다
   *
   * @memberof cadUIUndoStack
   */
  Clear() {
    this._undo = [];
    this._redo = [];
  }

  /**
   * undo / redo를 위한 데이터 생성
   * @param {CStructure} data
   * @return {Object} key value pair
   */
  BuildData(data) {
    const cl = data.clone();
    const hdata = {
      "struct": cl
    };
    return hdata;
  }

  /**
   * undo stack에 현재 상태를 기록한다
   *
   * @param {Object} data Undo 저장 데이터
   */
  AddUndo(data_undo) {
    const hdata = this.BuildData(data_undo);
    this._undo.push(hdata);
    this._redo = [];
    if (this._undo.length > this._maxUndo) {
      this._undo.splice(0, 1);
    }
  }

  /**
   * undo를 수행한다
   *
   * @param {Object} data Undo 저장 데이터
   * @return {Object} Undo 결과물 
   */
  Undo(data) {
    if (!this.CanUndo()) return null;
    this._app._uiHandler.ClearAllMeasures();
    const udata = this.BuildData(data);
    this._redo.push(udata);
    const hdata = this._undo[this._undo.length - 1];
    this._undo.splice(this._undo.length - 1, 1);
    rayLog(3, this._undo);
    rayLog(3, this._redo);
    rayLog(3, "Undo " + this._undo.length + " / " + "Redo " + this._redo.length);
    return hdata;
  }

  /**
   * redo를 수행한다
   *
   * @param {Array} data Redo 저장 데이터
   * @return {Object} Redo 결과물 
   */
  Redo(data, addData) {
    if (!this.CanRedo()) return null;
    this._app._uiHandler.ClearAllMeasures();

    // const rdata = this.BuildData(data.struct);
    this._undo.push(this.BuildData(addData));
    const hdata = this._redo[this._redo.length - 1];
    this._redo.splice(this._redo.length - 1, 1);
    rayLog(3, this._undo);
    rayLog(3, this._redo);
    rayLog(3, "Undo " + this._undo.length + " / " + "Redo " + this._redo.length);
    return hdata;
  }

  /**
   * Undo 가능 여부를 반환한다
   *
   * @return {Boolean} undo 가능 여부 
   */
  CanUndo() {
    return this._undo.length > 0;
  }

  /**
   * Redo 가능 여부를 반환한다
   *
   * @return {Boolean} redo 가능 여부 
   */
  CanRedo() {
    return this._redo.length > 0;
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalStructureManager.js




/**
 * Structure 관리 클래스
 * */
class crystalStructureManager {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   * @param {CStructure} cs 관리할 CStructure
   */
  constructor(app, cs) {
    this._app = app;
    if (cs) this._cs = cs;else this._cs = new CStructure();
    this._undoStack = new crystalUndoStack(app);
    crystalStructureManager.I = this;
  }

  /**
   * CStructure를 반환한다.
   * 
   * @returns {CStrucure} cstructure
   * */
  static GetCS() {
    return this._cs;
  }

  /**
    * UI와 Renderer 모두 현재 주어진 cstructure로 대체한다.
    * 
    * @param {CStructure} cstructure 대체할 CStructure 클래스 변수
    */
  ReplaceCS(cstructure) {
    this._cs = cstructure.clone();

    // CStructure와 관련된 UI를 모두 업데이트한다.

    // unitcell
    $(this._app._dlgEditData._input_a_length).val(this._cs._unitcell._axis._la);
    $(this._app._dlgEditData._input_b_length).val(this._cs._unitcell._axis._lb);
    $(this._app._dlgEditData._input_c_length).val(this._cs._unitcell._axis._lc);
    $(this._app._dlgEditData._input_alpha).val(this._cs._unitcell._axis._a);
    $(this._app._dlgEditData._input_beta).val(this._cs._unitcell._axis._b);
    $(this._app._dlgEditData._input_gamma).val(this._cs._unitcell._axis._c);

    // boundary
    $(this._app._dlgBoundarySetting._input_min_x).val(this._cs._boundary._min._x);
    $(this._app._dlgBoundarySetting._input_min_y).val(this._cs._boundary._min._y);
    $(this._app._dlgBoundarySetting._input_min_z).val(this._cs._boundary._min._z);
    $(this._app._dlgBoundarySetting._input_max_x).val(this._cs._boundary._max._x);
    $(this._app._dlgBoundarySetting._input_max_y).val(this._cs._boundary._max._y);
    $(this._app._dlgBoundarySetting._input_max_z).val(this._cs._boundary._max._z);

    // atom table
    this._app._dlgEditData._atomTable.clearAll();
    for (let i = 0; i < this._cs._atoms.length; ++i) {
      let atom = this._cs._atoms[i];
      this._app._dlgEditData.AddAtomToTable(atom._idx, atom._id, AtomDef_AtomDef.GetDefWithNumber(atom._id)._atom_id, atom._label, atom._position._x, atom._position._y, atom._position._z, 0, 0);
    }

    // bond table
    this._app._dlgEditBond._bondTable.clearAll();
    for (let i = 0; i < this._cs._bonds.length; ++i) {
      let bond = this._cs._bonds[i];
      this._app._dlgEditBond.AddBondToTable(bond._idx, bond._A1Idx, bond._A2Idx, bond._minLength, bond._maxLength, bond._boundaryMode, bond._showPolyhederal);
    }

    // object table
    this._app._property._propertyObject._objectDataTable.updateTable();

    // CStructure 렌더링 업데이트
    this._cs.generate();
    this._app.UpdateStructureProperty();
  }

  /**
   * undo 스택을 모두 제거한다.
   * */
  ClearUndo() {
    this._undoStack.Clear();
  }

  /**
   * undo를 추가한다.
   * */
  AddUndo() {
    this._undoStack.AddUndo(this._prev.clone());
    this.UpdateUI();
  }

  /**
   * 데이터 임시 저장
   * @param {CStructure} prev 변경 사항 발생 시 저장할 데이터
   */
  SetPrev(prev) {
    this._prev = prev.clone();
  }

  /**
   * undo를 수행한다.
   * */
  DoUndo() {
    if (!this._undoStack.CanUndo()) return;

    // get undo data
    const hdata = this._undoStack.Undo(this._cs.clone());

    // restore CStruct data with undo data

    this._cs = hdata.struct;
    this.ReplaceCS(this._cs);
    this._app._property._propertyStyle.OnApply();
    this._app._3dRender._renderer._scene.children.pop();
    this._app._3dRender._renderer._scene.add(this._cs._groupMesh);
    this.UpdateUI();
  }

  /**
   * redo를 수행한다.
   * @param {CStructure} addData 추가할 데이터
   */
  DoRedo(addData) {
    if (!this._undoStack.CanRedo()) return;

    // get undo data
    const hdata = this._undoStack.Redo(this._undoStack._redo[this._undoStack._redo.length - 1], addData);

    // restore CStruct data with undo data

    this._cs = hdata.struct;
    this.ReplaceCS(this._cs);
    this._app._property._propertyStyle.OnApply();
    this._app._3dRender._renderer._scene.children.pop();
    this._app._3dRender._renderer._scene.add(this._cs._groupMesh);
    this.UpdateUI();
  }

  /**
   * UI 업데이트
   * */
  UpdateUI() {
    if (this._cs._atoms.length === 0) {
      this._app._dlgEditData.DisableInput(true);
    }
    if (this._cs._bonds.length === 0) {
      this._app._dlgEditBond.DisableInput(true);
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalRenderer.js











/**
 * crystal renderer 클래스
 * */
class crystalRenderer {
  /**
   * 생성자
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalRenderer가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    crystalRenderer.I = this;
    kVisLib.Init(function () {
      crystalRenderer.I._renderer = new Renderer(crystalEditor.I._div_3dRender, false, true);
      crystalRenderer.I._renderer.setBackgroundColor(1, 1, 1);
      crystalRenderer.I._renderer.createPerspecriveCamera(100, 100, 100, 50, 1.5, 0.01, 500);
      crystalRenderer.I._renderer.create3DOrthographicCamera(-100, 100, 100, -100, 0.1, 500);
      crystalRenderer.I._renderer.createOrbitControl();
      crystalRenderer.I._renderer.createCameraLight();
      crystalRenderer.I._renderer.setOrthoCamera();
      crystalRenderer.I._renderer.setOrthoCameraDistance(100);
      crystalRenderer.I._geomRenderer = new GeomRenderer(kVisLib.api, crystalRenderer.I._renderer);
      crystalRenderer.I._app._csManager = new crystalStructureManager(crystalRenderer.I._app, new CStructure());
      crystalRenderer.I._app._csManager._cs._unitcell.set(cryst.Unitcell.alpha, cryst.Unitcell.beta, cryst.Unitcell.gamma, cryst.Unitcell.a, cryst.Unitcell.b, cryst.Unitcell.c);
      crystalRenderer.I._app._csManager._cs._boundary.set(new Vector3(cryst.Boundary['minX'], cryst.Boundary['minY'], cryst.Boundary['minZ']), new Vector3(cryst.Boundary['maxX'], cryst.Boundary['maxY'], cryst.Boundary['maxZ']));
      GeomMole.init();
      GeomMole.setAtomRenderType(0);
      crystalRenderer.I._app._labelManager = new crystalLabelManager(crystalRenderer.I._app);
      crystalRenderer.I._app._labelManager.createLabelForAxis();
      let unitcell = crystalRenderer.I._app._csManager._cs._unitcell;
      crystalRenderer.I.RebuildAxisGeom(unitcell._axis._va, unitcell._axis._vb, unitcell._axis._vc);
      // crystalRenderer.I._autoRotateCamera = false;

      crystalRenderer.I.Render();
      crystalRenderer.I._app.OnResize();
      crystalRenderer.I._app._csManager._cs.generate();
      crystalRenderer.I._renderer.autofitCameraObjList([crystalRenderer.I._app._csManager._cs.getMesh()], 100);
      for (let elem of crystalRenderer.I._renderer._scene.children) {
        if (elem.name === "CStructure") crystalRenderer.I._3dRender._renderer._scene.remove(elem);
      }
      crystalRenderer.I._app._3dRender._renderer._scene.add(crystalRenderer.I._app._csManager._cs._groupMesh);
    });
  }

  /**
   * 한 프레임을 렌더링한다.
   * */
  Render() {
    requestAnimationFrame(crystalRenderer.I.Render);
    switch (crystalRenderer.I._app._property._propertyTool._orientationMode) {
      case 0:
        crystalRenderer.I._renderer.doCameraRotate(0.001, 1);
        break;
      case 1:
        crystalRenderer.I._renderer.doCameraRotate(0.001, 0);
        break;
      case 2:
        crystalRenderer.I._renderer.doCameraRotate(0.001, 2);
    }
    Renderer.I.tick();
    Renderer.I.render();
    if (crystalRenderer.I._postRender) {
      crystalRenderer.I._postRender();
    }
  }

  /**
   * 샘플 생성
   * */
  CreateSample() {
    let sphereGeom = new SphereGeometry(3, 32, 32);
    let material = new MeshBasicMaterial({
      color: 0xff0000
    });
    let sphere = new three_module_Mesh(sphereGeom, material);
    crystalRenderer.I._renderer._scene.add(sphere);
  }

  /**
   * 모든 객체 제거
   * */
  Clear() {
    this._geomRenderer.clear();
  }

  /**
   * 월드 좌표계를 스크린 좌표계로 변환한다.
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  WorldToScreen(wpt) {
    let lcv = wpt.clone().project(this._app._3dRender._renderer._camera);
    let px = (lcv.x + 1.0) * 0.5 * this._app._div_3dRender.clientWidth;
    let py = (1.0 - (lcv.y + 1.0) * 0.5) * this._app._div_3dRender.clientHeight;
    return new three_module_Vector3(px, py, 0);
  }

  /**
   * 후처리 작업
   * */
  _postRender() {
    if (this._app._labelManager) {
      // labelmanager를 가져와서 label 위치 갱신하기
      this._app._labelManager._postRender();
    }
    if (this._app._uiHandler) {
      this._app._uiHandler._postRender();
    }
  }

  /**
   * 좌표축을 재생성한다.
   * @param {THREE.Vector3} a a축 벡터
   * @param {THREE.Vector3} b b축 벡터
   * @param {THREE.Vector3} c c축 벡터
   */
  RebuildAxisGeom(a, b, c) {
    if (this._renderer) {
      if (this._renderer._axisMesh) this._renderer._scene2.remove(this._renderer._axisMesh);
      this._renderer._axisMesh = this._renderer._axisGeom.createAxisMeshWithVectors(a, b, c);
      this._renderer.setAxisViewportPosition(-0.84, -0.8, -0.8, 1);
      this._renderer._scene2.add(this._renderer._axisMesh);
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalStructurePropertyDialog.js



/**
 * Structure Property 설정을 위한 다이얼로그 UI 클래스
 * */
class crystalStructurePropertyDialog {
  /**
   * UI 초기화를 진행한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem cadUIDlgSetting이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    // 앱 이름
    this._name = name;
    // 앱
    this._app = app;
    // 앱 루트 HTML DIV
    this._div = div_elem;

    // 다이얼로그 보이기 플래그
    this._show = false;
    this._div.innerHTML = this._appElementHTML(name);
    this._selectedColorUnitCell = [0, 0, 0];
    this._checkUnitCellShowLine = document.getElementById(name + "_property_unitcell_show_line");
    this._colorUnitCell = document.getElementById(name + "_property_unitcell_color");
    this._checkCrystalShowColor = document.getElementById(name + "_property_crystal_show_color");
    this._checkCrystalShowLine = document.getElementById(name + "_property_crystal_show_line");
    this._spinAtomShininess = document.getElementById(name + "_property_atom_shininess");
    this._checkAtomShowLabel = document.getElementById(name + "_property_atom_show_label");
    this._spinBondShininess = document.getElementById(name + "_property_bond_shininess");
    // this._spinBondMeshDetail = document.getElementById(name + "_property_bond_detail");

    this._spinPolyhedronShininess = document.getElementById(name + "_property_polyhedron_shininess");
    this._checkPolyhedronShowLine = document.getElementById(name + "_property_polyhedron_show_line");
    crystalStructurePropertyDialog.I = this;
    this._dialog = $(this._div).dialog({
      autoOpen: false,
      height: "auto",
      width: "auto",
      modal: false,
      closeOnEscape: true,
      resizable: false,
      title: "Structure Properties",
      buttons: {
        "Restore Defaults": function () {
          crystalStructurePropertyDialog.I.RestoreDefaults();
        },
        "OK": function () {
          crystalStructurePropertyDialog.I.OnApply();
          crystalStructurePropertyDialog.I._dialog.dialog("close");
        },
        "Cancel": function () {
          crystalStructurePropertyDialog.I._dialog.dialog("close");
        },
        "Apply": function () {
          crystalStructurePropertyDialog.I.OnApply();
        }
      },
      close: function () {
        crystalStructurePropertyDialog.I._show = false;
      }
    });
    $(this._checkUnitCellShowLine).checkboxradio();
    $(this._colorUnitCell).colorpicker({
      modal: true,
      buttonColorize: true,
      buttonImageOnly: true,
      ok: function (event, formatted) {
        event.target.style.backgroundColor = formatted.css;
        crystalStructurePropertyDialog.I.OnChangeColorUnitCell([formatted.rgb["r"], formatted.rgb["g"], formatted.rgb["b"]]);
      }
    });
    $(this._checkCrystalShowColor).checkboxradio();
    $(this._checkCrystalShowLine).checkboxradio();
    $(this._spinAtomShininess).spinner({
      numberFormat: 'n',
      min: 0,
      max: 100,
      step: 1,
      incremental: true
    });
    $(this._checkAtomShowLabel).checkboxradio();
    $(this._spinBondShininess).spinner({
      numberFormat: 'n',
      min: 0,
      max: 100,
      step: 1,
      incremental: true
    });
    /*
    $(this._spinBondMeshDetail).spinner({
        numberFormat: 'n', min: 0, max: 100, step: 1, incremental: true,
    });
    */

    $(this._spinPolyhedronShininess).spinner({
      numberFormat: 'n',
      min: 0,
      max: 100,
      step: 1,
      incremental: true
    });
    $(this._checkPolyhedronShowLine).checkboxradio();
  }
  /**
   * Setting Dialog에 대한 html element를 작성한다
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @return {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;

    // UnitCell

    ihtml[idx] = "<table class='cryUI_Preset_Wrapper_Table'>";
    idx++;

    // unit cell

    ihtml[idx] = "<tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Table'><caption>Unit Cell</caption><tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Detail_Table'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Show Line</td><td><label for='" + name + "_property_unitcell_show_line'></label><input type='checkbox' id='" + name + "_property_unitcell_show_line'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Color</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_property_unitcell_color' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "</table></td></tr></table></td>";
    idx++;

    // crystal structure

    ihtml[idx] = "<td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Table'><caption>Crystal Structure</caption><tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Detail_Table'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Show Color</td><td><label for='" + name + "_property_crystal_show_color'></label><input type='checkbox' id='" + name + "_property_crystal_show_color'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Show Line</td><td><label for='" + name + "_property_crystal_show_line'></label><input type='checkbox' id='" + name + "_property_crystal_show_line'></td></tr>";
    idx++;
    ihtml[idx] = "</table></td></tr></table></td></tr>";
    idx++;

    // atom

    ihtml[idx] = "<tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Table'><caption>Atom</caption><tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Detail_Table'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Shininess</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_property_atom_shininess' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Show Label</td><td><label for='" + name + "_property_atom_show_label'></label><input type='checkbox' id='" + name + "_property_atom_show_label'></td></tr>";
    idx++;
    ihtml[idx] = "</table></td></tr></table></td>";
    idx++;

    // bond

    ihtml[idx] = "<td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Table'><caption>Bond</caption><tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Detail_Table'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Shininess</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_property_bond_shininess' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    /*
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Mesh Detail</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_property_bond_detail' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    */
    ihtml[idx] = "</table></td></tr></table></td></tr>";
    idx++;

    // polyhedron

    ihtml[idx] = "<tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Table'><caption>Polyhedron</caption><tr><td class='cryUI_Td_TopAlign'><table class='cryUI_Preset_Detail_Table'>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Shininess</td>";
    idx++;
    ihtml[idx] = "<td><input type='text' id='" + name + "_property_polyhedron_shininess' class='cryUI_Widget_Spin'></td></tr>";
    idx++;
    ihtml[idx] = "<tr><td class='cryUI_DropTitle3'>Show Line</td><td><label for='" + name + "_property_polyhedron_show_line'></label><input type='checkbox' id='" + name + "_property_polyhedron_show_line'></td></tr>";
    idx++;
    ihtml[idx] = "</table></td></tr></table></td>";
    idx++;
    ihtml[idx] = "</table>";
    idx++;
    return ihtml.join("");
  }
  /**
   * UI를 갱신한다
   * */
  UpdateUI() {
    if (!this._app._structureProperty) return;
    const property = this._app._structureProperty;
    $(this._checkUnitCellShowLine).prop("checked", property.UnitCell.ShowLine);
    $(this._checkUnitCellShowLine).checkboxradio("refresh");
    this._selectedColorUnitCell = [property.UnitCell.Color[0], property.UnitCell.Color[1], property.UnitCell.Color[2]];
    var c_back = crystalVariable.HTMLColorRGB(this._selectedColorUnitCell);
    $(this._colorUnitCell).prop("value", c_back);
    $(this._colorUnitCell).css("background-color", "#" + c_back);
    $(this._checkCrystalShowColor).prop("checked", property.Crystal.ShowColor);
    $(this._checkCrystalShowColor).checkboxradio("refresh");
    $(this._checkCrystalShowLine).prop("checked", property.Crystal.ShowLine);
    $(this._checkCrystalShowLine).checkboxradio("refresh");
    $(this._spinAtomShininess).spinner("value", property.Atom.Shininess);
    $(this._checkAtomShowLabel).prop("checked", property.Atom.ShowLabel);
    $(this._checkAtomShowLabel).checkboxradio("refresh");
    $(this._spinBondShininess).spinner("value", property.Bond.Shininess);
    // $(this._spinBondMeshDetail).spinner("value", property.Bond.MeshDetail);

    $(this._spinPolyhedronShininess).spinner("value", property.Polyhedron.Shininess);
    $(this._checkPolyhedronShowLine).prop("checked", property.Polyhedron.ShowLine);
    $(this._checkPolyhedronShowLine).checkboxradio("refresh");
  }
  /**
   * 기본값 복원
   * */
  RestoreDefaults() {
    this._app.InitStructureProperty();
    this.UpdateUI();
  }
  /**
   * 설정값을 적용한다
   * */
  OnApply() {
    if (!this._app._structureProperty) return;
    const property = this._app._structureProperty;
    property.UnitCell.ShowLine = $(this._checkUnitCellShowLine).prop("checked");
    property.UnitCell.Color = [this._selectedColorUnitCell[0], this._selectedColorUnitCell[1], this._selectedColorUnitCell[2]];
    property.Crystal.ShowColor = $(this._checkCrystalShowColor).prop("checked");
    property.Crystal.ShowLine = $(this._checkCrystalShowLine).prop("checked");
    property.Atom.Shininess = Number($(this._spinAtomShininess).spinner("value"));
    property.Atom.ShowLabel = $(this._checkAtomShowLabel).prop("checked");
    property.Bond.Shininess = Number($(this._spinBondShininess).spinner("value"));
    // property.Bond.MeshDetail = Number($(this._spinBondMeshDetail).spinner("value"));

    property.Polyhedron.Shininess = Number($(this._spinPolyhedronShininess).spinner("value"));
    property.Polyhedron.ShowLine = $(this._checkPolyhedronShowLine).prop("checked");
    rayLog(3, "[structureProperty] change applied JSON " + JSON.stringify(property));
    this._app.UpdateStructureProperty();
    this._app.UpdateUI();
  }
  /**
   * 배경색을 변경한다
   * @param {Color} col 색상값
   */
  OnChangeColorUnitCell(col) {
    rayLog(3, "[structureProperty] change color unitcell " + col[0] + "," + col[1] + "," + col[2]);
    this._selectedColorUnitCell = col;
  }
  /**
   * setting dialog를 보여준다
   * */
  ShowDialog() {
    if (this._show) return;
    this.UpdateUI();
    this._dialog.dialog("open");
    this._show = true;
  }

  /**
   * dialog를 닫는다
   * */
  CloseDialog() {
    this._dialog.dialog("close");
    this._app.UpdateUI();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopMenu.js
/**
 * 상단 메뉴 클래스
 * */
class crystalTopMenu {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTopMenu가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._onMode = false;
    this._onClick = false;
    crystalTopMenu.I = this;

    // File 최상위 메뉴 버튼
    // this._topFile = document.getElementById(name + "_topMenu_file");

    // File 서브 메뉴 아이템
    this._menuFile = document.getElementById(name + "_subMenu_file");

    // Edit 최상위 메뉴 버튼
    this._topEdit = document.getElementById(name + "_topMenu_edit");

    // Edit 서브 메뉴 버튼
    this._menuEdit = document.getElementById(name + "_subMenu_edit");

    // Data 최상위 메뉴 버튼
    this._topData = document.getElementById(name + "_topMenu_data");

    // Data 서브 메뉴 버튼
    this._menuData = document.getElementById(name + "_subMenu_data");

    // View 최상위 메뉴 버튼
    this._topView = document.getElementById(name + "_topMenu_view");

    // View 서브 메뉴 버튼
    this._menuView = document.getElementById(name + "_subMenu_view");
    $(this._menuFile).menu({
      select: function (event, ui) {
        let item = $(ui.item[0]).attr("value");
        crystalTopMenu.I.HandleMenuItem(item);
      }
    });
    $(this._menuEdit).menu({
      select: function (event, ui) {
        let item = $(ui.item[0]).attr("value");
        crystalTopMenu.I.HandleMenuItem(item);
      }
    });
    $(this._menuData).menu({
      select: function (event, ui) {
        let item = $(ui.item[0]).attr("value");
        crystalTopMenu.I.HandleMenuItem(item);
      }
    });
    $(this._menuView).menu({
      select: function (event, ui) {
        let item = $(ui.item[0]).attr("value");
        crystalTopMenu.I.HandleMenuItem(item);
      }
    });

    // $(this._topFile).on("mouseenter", function (event) {
    //   crystalTopMenu.I.HandleMouseEnterTopMenu(0);
    // });

    $(this._topEdit).on("mouseenter", function (event) {
      crystalTopMenu.I.HandleMouseEnterTopMenu(0);
    });
    $(this._topData).on("mouseenter", function (event) {
      crystalTopMenu.I.HandleMouseEnterTopMenu(1);
    });
    $(this._topView).on("mouseenter", function (event) {
      crystalTopMenu.I.HandleMouseEnterTopMenu(2);
    });

    // $(this._topFile).on("click", function (event) {
    //   event.preventDefault();
    //   crystalTopMenu.I.HandleClickTopMenu(0);
    // });

    $(this._topEdit).on("click", function (event) {
      event.preventDefault();
      crystalTopMenu.I.HandleClickTopMenu(0);
    });
    $(this._topData).on("click", function (event) {
      event.preventDefault();
      crystalTopMenu.I.HandleClickTopMenu(1);
    });
    $(this._topView).on("click", function (event) {
      event.preventDefault();
      crystalTopMenu.I.HandleClickTopMenu(2);
    });
    window.addEventListener("click", function (event) {
      if (!crystalTopMenu.I._onClick) crystalTopMenu.I.UpdateSubMenus(-1);
      crystalTopMenu.I._onClick = false;
    });
    this.CalcSubMenuPos();
  }

  /**
   * TopMenu에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;

    // ihtml[idx] =
    //   "<div class='cryUI_TopMenuItem' id='" +
    //   name +
    //   "_topMenu_file'>File</div>";
    // idx++;

    // File 서브 메뉴
    // ihtml[idx] =
    //   "<ul class='cryUI_TopMenuSubMenu' id='" +
    //   name +
    //   "_subMenu_file' style='display:none'>";
    // idx++;
    // ihtml[idx] =
    //   "<li id='" +
    //   name +
    //   "_menu_file_new' value='file_new'><div>New</div></li>";
    // idx++;
    /*        
        ihtml[idx] = "<li id='" + name + "_menu_file_open_cif' value='file_open_cif'><div>Open CIF</div></li>";
        idx++;
        */
    // ihtml[idx] =
    //   "<li id='" +
    //   name +
    //   "_menu_file_open' value='file_open'><div>Open KCS</div></li>"
    // idx++
    // ihtml[idx] =
    //   "<li id='" +
    //   name +
    //   "_menu_file_save' value='file_save'><div>Save KCS</div></li>"
    // idx++

    // ihtml[idx] = "<li id='" + name + "_menu_file_import'><div>Import</div>";
    // idx++;
    // ihtml[idx] =
    //   "<ul><li value='file_import_cif'><div><span id='" +
    //   name +
    //   "_menu_file_import_cif'></span>Import CIF</div></li>";
    // idx++;
    // ihtml[idx] =
    //   "<li value='file_import_mol'><div><span id='" +
    //   name +
    //   "_menu_file_import_mol'></span>Import MOL</div></li>";
    // idx++;
    // ihtml[idx] = "</ul></li>";
    // idx++;
    // ihtml[idx] = "<li id='" + name + "_menu_file_export'><div>Export</div>";
    // idx++;
    // ihtml[idx] =
    //   "<ul><li value='file_export_cif'><div><span id='" +
    //   name +
    //   "_menu_file_export_cif'></span>Export CIF</div></li>";
    // idx++;
    // ihtml[idx] =
    //   "<li value='file_export_mol'><div><span id='" +
    //   name +
    //   "_menu_file_export_mol'></span>Export MOL</div></li>";
    // idx++;
    // ihtml[idx] =
    //   "<li value='file_export_obj'><div><span id='" +
    //   name +
    //   "_menu_file_export_obj'></span>Export OBJ</div></li>";
    // idx++;
    // ihtml[idx] = "</ul></li>";
    // idx++;
    // ihtml[idx] =
    //   "<li id='" +
    //   name +
    //   "_menu_file_save_render_image' value='file_save_render_image'><div>Save Render Image</div></li>";
    // idx++;
    // ihtml[idx] = "</ul>";
    // idx++;

    // Edit 서브 메뉴
    ihtml[idx] = "<div class='cryUI_TopMenuItem' id='" + name + "_topMenu_edit'>Edit</div>";
    idx++;
    ihtml[idx] = "<ul class='cryUI_TopMenuSubMenu' id='" + name + "_subMenu_edit' style='display:none'>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_edit_undo' value='edit_undo'><div>Undo</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_edit_redo' value='edit_redo'><div>Redo</div></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    // Data 서브 메뉴
    ihtml[idx] = "<div class='cryUI_TopMenuItem' id='" + name + "_topMenu_data'>Data</div>";
    idx++;
    ihtml[idx] = "<ul class='cryUI_TopMenuSubMenu' id='" + name + "_subMenu_data' style='display:none'>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_info' value='data_info'><div>Edit Info</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_unitcell' value='data_unitcell'><div>Edit Unitcell</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_cstructre' value='data_cstructure'><div>Edit CStructure</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_crystal_shape' value='data_crystal_shape'><div>Edit CrystalShape</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_bond' value='data_bond'><div>Edit Bond</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_vector' value='data_vector'><div>Edit Vectors</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_lattice_plane' value='data_lattice_plane'><div>Edit Lattice Plane</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_data_boundary' value='data_boundary'><div>Edit Boundary</div></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;

    // View 서브 메뉴
    ihtml[idx] = "<div class='cryUI_TopMenuItem' id='" + name + "_topMenu_view'>View</div>";
    idx++;
    ihtml[idx] = "<ul class='cryUI_TopMenuSubMenu' id='" + name + "_subMenu_view' style='display:none'>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_render_options' value='view_render_options'><div>Render Options</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_clear_measures' value='view_clear_measures'><div>Clear Measures</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_camera_auto_fit' value='view_camera_auto_fit'><div>Auto Fit Camera</div></li>";
    idx++;
    ihtml[idx] = "<hr/>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_along_axis_a' value='view_along_axis_a'><div>Along axis a</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_along_axis_b' value='view_along_axis_b'><div>Along axis b</div></li>";
    idx++;
    ihtml[idx] = "<li id='" + name + "_menu_view_along_axis_c' value='view_along_axis_c'><div>Along axis c</div></li>";
    idx++;
    ihtml[idx] = "</ul>";
    idx++;
    return ihtml.join("");
  }

  /**
   * Menu 위치를 계산한다.
   * */
  CalcSubMenuPos() {
    // this._menuFile.style.left = $(this._topFile).offset().left + "px";
    this._menuEdit.style.left = $(this._topEdit).offset().left + "px";
    this._menuData.style.left = $(this._topData).offset().left + "px";
    this._menuView.style.left = $(this._topView).offset().left + "px";
  }

  /**
   * 메뉴 아이템을 처리한다.
   * @param {String} item 처리할 메뉴 항목 값
   */
  HandleMenuItem(item) {
    if (item === "file_new") {
      this._app.MenuNew();
    }

    // else if (item === "file_save") {
    //     this._app.MenuSave();
    // }
    // else if (item === "file_open") {
    //     this._app.MenuOpen();
    // }
    /*
        else if (item === "file_open_cif") {
            this._app.MenuOpenCIF();
        }
        */else if (item === "file_export_cif") {
      this._app.MenuExportCIF();
    } else if (item === "file_export_mol") {
      this._app.MenuExportMOL();
    } else if (item === "file_export_obj") {
      this._app.MenuExportOBJ();
    } else if (item === "file_import_cif") {
      this._app.MenuImportCIF();
    } else if (item === "file_import_mol") {
      this._app.MenuImportMOL();
    } else if (item === "file_save_render_image") {
      this._app.MenuSaveRenderImage();
    } else if (item === "edit_undo") {
      this._app.MenuEditUndo();
    } else if (item === "edit_redo") {
      this._app.MenuEditRedo();
    } else if (item === "data_info") {
      this._app.MenuDataInfo();
    } else if (item === "data_unitcell") {
      this._app.MenuDataUnitcell();
    } else if (item === "data_cstructure") {
      this._app.MenuDataCStructure();
    } else if (item === "data_crystal_shape") {
      this._app.MenuDataCrystalShape();
    } else if (item === "data_bond") {
      this._app.MenuDataBond();
    } else if (item === "data_lattice_plane") {
      this._app.MenuDataLatticePlane();
    } else if (item === "data_vector") {
      this._app.MenuDataVector();
    } else if (item === "data_boundary") {
      this._app.MenuDataBoundary();
    } else if (item === "view_render_options") {
      this._app.MenuViewRenderOptions();
    } else if (item === "view_clear_measures") {
      this._app.MenuToolClearMeasure();
    } else if (item === "view_camera_auto_fit") {
      this._app.MenuAutoFit();
    } else if (item === "view_along_axis_a") {
      this._app.MenuViewAlignA();
    } else if (item === "view_along_axis_b") {
      this._app.MenuViewAlignB();
    } else if (item === "view_along_axis_c") {
      this._app.MenuViewAlignC();
    }
    this.UpdateSubMenus(-1);
  }

  /**
   * 서브 메뉴 펼쳐보기
   * @param {Number} idx 메뉴 인덱스
   */
  UpdateSubMenus(idx) {
    // this._menuFile.style.display = idx === 0 ? "" : "none";
    this._menuEdit.style.display = idx === 0 ? "" : "none";
    this._menuData.style.display = idx === 1 ? "" : "none";
    this._menuView.style.display = idx === 2 ? "" : "none";
    this._onMode = idx >= 0;
  }

  /**
   * UI 상태 업데이트
   * */
  UpdateUIState() {
    $(this._checkViewTopBar).css("visibility", this._app._topSeqBar && this._app._topSeqBar._show ? "visible" : "hidden");
    // $(this._checkViewCameraAutoRotate).css("visibility", this._app._autoRotateCamera ? "visible" : "hidden");
  }

  /**
   * 마우스로 top menu 진입 시 업데이트
   *
   * @param {Number} idx 메뉴 인덱스
   */
  HandleMouseEnterTopMenu(idx) {
    if (this._onMode) this.UpdateSubMenus(idx);
  }

  /**
   * top menu 클릭 처리
   * @param {Number} idx top menu 인덱스
   */
  HandleClickTopMenu(idx) {
    this._onClick = true;
    if (this._onMode) this.UpdateSubMenus(-1);else this.UpdateSubMenus(idx);
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopViewAlign.js
/**
 * align 메뉴 클래스
 * */
class crystalTopViewAlign {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTopViewAlign이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnAAlign = document.getElementById(name + "_top_align_a");
    this._btnBAlign = document.getElementById(name + "_top_align_b");
    this._btnCAlign = document.getElementById(name + "_top_align_c");
    crystalTopViewAlign.I = this;

    // 버튼 생성
    $(this._btnAAlign).button();
    $(this._btnBAlign).button();
    $(this._btnCAlign).button();
    $(this._btnAAlign).css("background-image", "url(images/Icon_A_Axis.png");
    $(this._btnBAlign).css("background-image", "url(images/Icon_B_Axis.png");
    $(this._btnCAlign).css("background-image", "url(images/Icon_C_Axis.png");

    // click 이벤트 처리
    $(this._btnAAlign).click(function (event) {
      crystalTopViewAlign.I._app.MenuViewAlignA();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnBAlign).click(function (event) {
      crystalTopViewAlign.I._app.MenuViewAlignB();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnCAlign).click(function (event) {
      crystalTopViewAlign.I._app.MenuViewAlignC();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
  }

  /**
   * TopViewAlign에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<table class='cryUI_topToolbarTab'><tr>";
    idx++;
    ihtml[idx] = "<td><button title='View along the a axis' id='" + name + "_top_align_a' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='View along the b axis' id='" + name + "_top_align_b' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='View along the c axis' id='" + name + "_top_align_c' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "</tr></table>";
    idx++;
    return ihtml.join("");
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopViewUndo.js
/**
 * undo �޴� Ŭ����
 * */
class crystalTopViewUndo {
  /**
   * ������
   * @param {String} name �ٸ� �۰� �����ϱ� ���� �̸�
   * @param {crystalEditor} app ���� �� ��ü
   * @param {HTMLElement} div_elem crystalTopViewUndo�� ������ HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnUndo = document.getElementById(name + "_top_undo");
    this._btnRedo = document.getElementById(name + "_top_redo");
    crystalTopViewUndo.I = this;
    $(this._btnUndo).button();
    $(this._btnRedo).button();
    $(this._btnUndo).css("background-image", "url(images/Icon_Undo.png");
    $(this._btnRedo).css("background-image", "url(images/Icon_Redo.png");
    $(this._btnUndo).click(function (event) {
      crystalTopViewUndo.I._app.MenuEditUndo();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnRedo).click(function (event) {
      crystalTopViewUndo.I._app.MenuEditRedo();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
  }

  /**
   * TopViewUndo�� ���� html element�� �ۼ��Ѵ�.
   * 
   * @param {String} name �ٸ� �۰� �����ϱ� ���� �̸�
   * @returns {String} HTML ���ڿ�
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<table class='cryUI_topToolbarTab'><tr>";
    idx++;
    ihtml[idx] = "<td><button title='Undo' id='" + name + "_top_undo' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='Redo' id='" + name + "_top_redo' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "</tr></table>";
    idx++;
    return ihtml.join("");
  }

  /**
   * UI ���� ������Ʈ
   * */
  UpdateUIState() {
    $('.cryUI_topBar_Btn_Tool').blur();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopViewEdit.js
/**
 * edit 메뉴 클래스
 * */
class crystalTopViewEdit {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTopViewEdit이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnEditData = document.getElementById(name + "_top_edit_data");
    this._btnEditBond = document.getElementById(name + "_top_edit_bond");
    this._btnEditVector = document.getElementById(name + "_top_edit_vector");
    this._btnEditCrystal = document.getElementById(name + "_top_edit_crystal");
    crystalTopViewEdit.I = this;

    // 버튼 생성
    $(this._btnEditData).button();
    $(this._btnEditBond).button();
    $(this._btnEditVector).button();
    $(this._btnEditCrystal).button();
    $(this._btnEditData).css("background-image", "url(images/Icon_Edit_Atom.png");
    $(this._btnEditBond).css("background-image", "url(images/Icon_Edit_Bond.png");
    $(this._btnEditVector).css("background-image", "url(images/Icon_Edit_Vector.png");
    $(this._btnEditCrystal).css("background-image", "url(images/Icon_Edit_Crystal.png");

    // show edit data dialog
    $(this._btnEditData).click(function (event) {
      crystalTopViewEdit.I._app.MenuDataCStructure();
      $(".cryUI_topBar_Btn_Tool").blur();
    });

    // show edit bond dialog
    $(this._btnEditBond).click(function (event) {
      crystalTopViewEdit.I._app.MenuDataBond();
      $(".cryUI_topBar_Btn_Tool").blur();
    });

    // show edit vector dialog
    $(this._btnEditVector).click(function (event) {
      crystalTopViewEdit.I._app.MenuDataVector();
      $(".cryUI_topBar_Btn_Tool").blur();
    });
    $(this._btnEditCrystal).click(function (event) {
      crystalTopViewEdit.I._app.MenuDataCrystalShape();
      $(".cryUI_topBar_Btn_Tool").blur();
    });
  }

  /**
   * TopViewEdit에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<table class='cryUI_topToolbarTab'><tr>";
    idx++;
    ihtml[idx] = "<td><button title='EditAtom' id='" + name + "_top_edit_data' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='EditBond' id='" + name + "_top_edit_bond' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='EditVector' id='" + name + "_top_edit_vector' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='EditCrystal' id='" + name + "_top_edit_crystal' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "</tr></table>";
    idx++;
    return ihtml.join("");
  }

  /**
   * UI 상태 업데이트
   * */
  UpdateUIState() {
    $(".cryUI_topBar_Btn_Tool").blur();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopViewFit.js
/**
 * 카메라 fit 메뉴 클래스
 * */
class crystalTopViewFit {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTopViewFit이 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnZoomIn = document.getElementById(name + "_top_zoom_in");
    this._btnZoomOut = document.getElementById(name + "_top_zoom_out");
    this._btnFitToScreen = document.getElementById(name + "_top_fit_to_screen");
    crystalTopViewFit.I = this;
    $(this._btnZoomIn).button();
    $(this._btnZoomOut).button();
    $(this._btnFitToScreen).button();
    $(this._btnZoomIn).css("background-image", "url(images/Icon_Zoom_In.png)");
    $(this._btnZoomOut).css("background-image", "url(images/Icon_Zoom_Out.png)");
    $(this._btnFitToScreen).css("background-image", "url(images/Icon_Fit_To_Screen.png)");
    $(this._btnZoomIn).click(function (event) {
      crystalTopViewFit.I._app.MenuViewZoomIn();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnZoomOut).click(function (event) {
      crystalTopViewFit.I._app.MenuViewZoomOut();
      $('.cryUI_topBar_Btn_Tool').blur();
    });
    $(this._btnFitToScreen).click(function (event) {
      $('.cryUI_topBar_Btn_Tool').blur();
      crystalTopViewFit.I._app._3dRender._renderer.autofitCameraObjList([crystalTopViewFit.I._app._csManager._cs.getMesh()], 10);
    });
  }

  /**
   * TopViewFit에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<table class='cryUI_topToolbarTab'><tr>";
    idx++;
    ihtml[idx] = "<td><button title='Zoom-in' id='" + name + "_top_zoom_in' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='Zoom-out' id='" + name + "_top_zoom_out' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "<td><button title='Fit-to-screen' id='" + name + "_top_fit_to_screen' class='ui-button ui-widget ui-corner-all ui-button-icon-only cryUI_topBar_Btn_Tool'></button></td>";
    idx++;
    ihtml[idx] = "</tr></table>";
    idx++;
    return ihtml.join("");
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalTopToolBar.js





/**
 * 상단 툴바 클래스
 * */
class crystalTopToolBar {
  /**
   * 생성자
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalTopToolBar가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    this._name = name;
    this._app = app;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    $(this._div).tooltip({
      items: ":hover"
    });
    this._div_topViewEdit = document.getElementById(name + "_topViewEdit");
    this._div_topViewUndo = document.getElementById(name + "_topViewUndo");
    this._div_topViewAlign = document.getElementById(name + "_topViewAlign");
    this._div_topViewFit = document.getElementById(name + "_topViewFit");
    this._viewEdit = true;
    this._viewUndo = true;
    this._viewAlign = true;
    this._viewFit = true;
    this._topViewEdit = new crystalTopViewEdit(this._name, this._app, this._div_topViewEdit);
    this._topViewUndo = new crystalTopViewUndo(this._name, this._app, this._div_topViewUndo);
    this._topViewAlign = new crystalTopViewAlign(this._name, this._app, this._div_topViewAlign);
    this._topViewFit = new crystalTopViewFit(this._name, this._app, this._div_topViewFit);
  }

  /**
   * TopToolBar에 대한 html element를 작성한다.
   * 
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div class='cryUI_topToolbarPanel' id='" + name + "_topViewEdit'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarSplitter'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarPanel' id='" + name + "_topViewUndo'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarSplitter'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarPanel' id='" + name + "_topViewAlign'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarSplitter'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topToolbarPanel' id='" + name + "_topViewFit'></div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * tool bar 상태 업데이트
   * */
  UpdateToolbarState() {
    this._div_topViewEdit.style.display = this._viewEdit ? "" : "none";
    this._div_topViewUndo.style.display = this._viewUndo ? "" : "none";
    this._div_topViewAlign.style.display = this._viewAlign ? "" : "none";
    this._div_topViewFit.style.display = this._viewFit ? "" : "none";
    this._viewTopBar = this._viewEdit || this._viewAlign || this._viewFit;
    this._div.style.display = this._viewTopBar ? "" : "none";
    this._topViewEdit.UpdateUIState();
    // this._topViewAlign.UpdateUIState();
    // this._topViewFit.UpdateUIState();

    $(this._div).tooltip("close");
  }

  /**
   * edit menu 가시화 여부
   * @param {Boolean} show edit menu show / hide
   */
  UpdateShowViewEdit(show) {
    this._viewEdit = show;
    this._app.UpdateUIState();
    this._app.OnResize();
  }

  /**
   * undo menu 가시화 여부
   * @param {Boolean} show undo menu show / hide
   */
  UpdateShowViewUndo(show) {
    this._viewUndo = show;
    this._app.UpdateUIState();
    this._app.OnResize();
  }

  /**
   * align menu 가시화 여부
   * @param {Boolean} show align menu show / hide
   */
  UpdateShowViewAlign(show) {
    this._viewAlign = show;
    this._app.UpdateUIState();
    this._app.OnResize();
  }

  /**
   * fit menu 가시화 여부
   * @param {Boolean} show fit menu show / hide
   */
  UpdateShowViewFit(show) {
    this._viewFit = show;
    this._app.UpdateUIState();
    this._app.OnResize();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIFloatingToolMeasure.js
/**
 * 측정 모드 도구 버튼
 */
class crystalUIFloatingToolMeasure {
  /**
   * UI를 초기화한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {proUIApp} app 상위 앱 객체
   * @param {HTMLElement} div_elem crystalUIFloatingToolMeasure가 부착될 HTML Element
   */
  constructor(name, app, div_elem) {
    // 앱 이름
    this._name = name;

    // 앱
    this._app = app;

    // 앱 루트 HTML DIV
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._btnToolMeasureFinish = document.getElementById(name + "_tool_measure_finish");
    $(this._btnToolMeasureFinish).button();
    crystalUIFloatingToolMeasure.I = this;
    $(this._btnToolMeasureFinish).mousemove(function (event) {
      event.stopPropagation();
      event.preventDefault();
    });
    $(this._btnToolMeasureFinish).click(function (event) {
      crystalUIFloatingToolMeasure.I._app._uiHandler.FinishAllMeasures();
      $('.cryUI_BtnToolMeasure').blur();
    });
    this.Hide();
  }

  /**
   * FloatingToolMeasure에 대한 html element를 작성한다
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    var ihtml = [];
    var idx = 0;
    ihtml[idx] = "<button title='Finish Measure' id='" + name + "_tool_measure_finish' class='ui-button ui-widget ui-corner-all proUI_BtnToolMeasure'>Finish<br/>Measure</button>";
    idx++;
    return ihtml.join("");
  }

  /**
   * FloatingToolMeasure를 보여준다
   */
  Show() {
    this._div.style.display = "block";
  }

  /**
   * FloatingToolMeasure를 숨긴다
   */
  Hide() {
    this._div.style.display = "none";
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUISelect.js

class crystalUISelect {
  constructor(app, div_base, ui) {
    this._app = app;
    this._div_base = div_base;
    this._ui = ui;
    this._step = 0;
    this._startX = null;
    this._startY = null;
    this._scrDragStartX = null;
    this._scrDragStartY = null;
    this._scrDragEndX = null;
    this._scrDragEndY = null;
    this._previewDragSelect = null;
    this._bClicked = false;
    this._labelList = [];
  }

  /**
   * ui select �ʱ�ȭ
   * */
  Init() {
    this._step = 0;
    this._bClicked = false;
    this._scrDragStartX = null;
    this._scrDragStartY = null;
    this._scrDragEndX = null;
    this._scrDragEndY = null;
    this.RemovePreviewDragSelect();
  }

  /**
   * ������� ���õ� atom, bond ��� ��������
   * */
  ClearAll() {
    this._app._csManager._cs.unselectAll();
    this._app._logBar.ClearMsgText();
    this.Init();
    this.ClearLabel();
  }

  /**
   * ���콺 �̵� ó���ϱ�
   * @param {Number} px ���콺 x ��ǥ
   * @param {Number} py ���콺 y ��ǥ
   */
  HandleMouseMove(px, py) {
    if (this._step === 0) {
      this.ClearAll();
      this._scrDragStartX = px;
      this._scrDragStartY = py;
      this._step++;
    } else {
      this._drag = true;
      this._scrDragEndX = px;
      this._scrDragEndY = py;
      this._scrDragStartX = this._startX;
      this._scrDragStartY = this._startY;
      if (this._scrDragEndX < this._scrDragStartX) {
        let tmp = this._scrDragEndX;
        this._scrDragEndX = this._scrDragStartX;
        this._scrDragStartX = tmp;
      }
      if (this._scrDragStartY < this._scrDragEndY) {
        let tmp = this._scrDragStartY;
        this._scrDragStartY = this._scrDragEndY;
        this._scrDragEndY = tmp;
      }
      this.UpdatePreview();
    }
  }
  SetClick(px, py) {
    this._startX = px;
    this._startY = py;
  }

  /**
   * ���콺 Ŭ�� ó���ϱ�
   * 
   * @param {Number} px ���콺 x ��ǥ
   * @param {Number} py ���콺 y ��ǥ
   */
  HandleClick(px, py) {
    let selectediAtom;
    if (this._bClicked) {
      this.ClearAll();
    }
    this._scrDragEndX = px;
    this._scrDragEndY = py;
    this._scrDragStartX = this._startX;
    this._scrDragStartY = this._startY;
    let ncoord = this._ui.ScreenToNormalized(px, py);
    selectediAtom = this._app._csManager._cs.pickiAtom(this._app._3dRender._renderer, ncoord);
    if (this._scrDragEndX < this._scrDragStartX) {
      let tmp = this._scrDragEndX;
      this._scrDragEndX = this._scrDragStartX;
      this._scrDragStartX = tmp;
    }
    if (this._scrDragStartY < this._scrDragEndY) {
      let tmp = this._scrDragStartY;
      this._scrDragStartY = this._scrDragEndY;
      this._scrDragEndY = tmp;
    }
    if (this._drag) {
      this.UpdatePreview();

      // select ����
      let selectediAtomList = this._app._csManager._cs.selectiAtomRect(this._app._3dRender._renderer, [this._scrDragStartX, this._scrDragStartY, this._scrDragEndX, this._scrDragEndY]);
      let selectediBondList = this._app._csManager._cs.selectiBondRect(this._app._3dRender._renderer, [this._scrDragStartX, this._scrDragStartY, this._scrDragEndX, this._scrDragEndY]);
      this.UpdateSelectedInfo(selectediAtomList, selectediBondList);
      this.CreateLabel(selectediAtomList);
      this.Init();
      this._drag = false;
    } else if (selectediAtom) {
      if (selectediAtom) {
        this.ClearAll();
        selectediAtom.select(true);
        this.UpdateSelectedInfo([selectediAtom]);
        this._bClicked = true;

        // label �����ֱ�
        this.CreateLabel([selectediAtom]);
      }
    } else {
      this.ClearAll();
    }
  }
  UpdatePreview() {
    this.RemovePreviewDragSelect();
    let l = this._scrDragStartX < this._scrDragEndX ? this._scrDragStartX : this._scrDragEndX;
    let r = this._scrDragStartX > this._scrDragEndX ? this._scrDragStartX : this._scrDragEndX;
    let t = this._scrDragStartY < this._scrDragEndY ? this._scrDragStartY : this._scrDragEndY;
    let b = this._scrDragStartY > this._scrDragEndY ? this._scrDragStartY : this._scrDragEndY;
    let w = r - l;
    let h = b - t;
    this._previewDragSelect = document.createElement("div");
    this._previewDragSelect.classList.add("cryUI_SelectionBox");
    this._app._div_3dRender.appendChild(this._previewDragSelect);
    this._previewDragSelect.style.zIndex = 4;
    this._previewDragSelect.style.left = l + "px";
    this._previewDragSelect.style.top = t + "px";
    this._previewDragSelect.style.width = w + "px";
    this._previewDragSelect.style.height = h + "px";
  }
  RemovePreviewDragSelect() {
    if (this._previewDragSelect != null) {
      this._previewDragSelect.remove();
      this._previewDragSelect = null;
    }
  }
  UpdateSelectedInfo(selectediAtomList, selectediBondList) {
    let txt = "";
    rayLog(3, selectediBondList);
    for (let i = 0; i < selectediAtomList.length; ++i) {
      txt += "Selected Atom " + (i + 1) + " \t / ";

      // �̸�
      txt += "Symbol : " + selectediAtomList[i]._def._def._atom_id + " \t / ";

      // ��ġ
      txt += "Position : (" + selectediAtomList[i]._position2.x + "," + selectediAtomList[i]._position2.y + "," + selectediAtomList[i]._position2.z + ")\t / ";

      // ������ Ÿ��
      txt += "Type : " + selectediAtomList[i]._def._type + "\n\n";
    }
    this._app._logBar.AddMsgText(txt);
  }
  CreateLabel(selectediAtomList) {
    if (!this._app._structureProperty.Atom.ShowLabel) return;
    for (let i = 0; i < selectediAtomList.length; ++i) {
      let iAtom = selectediAtomList[i];
      if (iAtom._def._label) {
        let label = document.createElement("div");
        label.classList.add("cryUI_MeasureTextDist");
        this._div_base.appendChild(label);
        label.style.left = "4px";
        label.style.top = "4px";
        const pt = iAtom._position2;
        const scrpt = this._ui.WorldToScreen(pt);
        label.innerText = iAtom._def._label;
        label.style.left = scrpt.x.toFixed(0) + "px";
        label.style.top = scrpt.y.toFixed(0) + "px";
        label.style.backgroundColor = "rgba(255,255,0,0.9)";
        iAtom._label = label;
        label._pt = pt;
        this._labelList.push(label);
      }
    }
  }
  ClearLabel() {
    for (let i = 0; i < this._app._csManager._cs._iatomList.length; ++i) {
      if (this._app._csManager._cs._iatomList[i]._label) {
        this._app._csManager._cs._iatomList[i]._label.remove();
        delete this._app._csManager._cs._iatomList[i]._label;
      }
    }
  }
  RemoveLabel(iAtom) {
    iAtom._label.remove();
    iAtom._label = null;
  }
  AutoAlignText() {
    for (let label of this._labelList) {
      let pt = label._pt;
      let scrpt = this._ui.WorldToScreen(pt);
      label.style.left = scrpt.x.toFixed(0) + "px";
      label.style.top = scrpt.y.toFixed(0) + "px";
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUtil.js


var crystalUtil_cylinder;

/**
 * dotted line을 생성하기 위한 util 클래스
 * */
class crystalUtil {
  /**
   * 생성자
   * */
  constructor() {
    crystalUtil._cylinder = null;
  }

  /**
   * 3D 점선 객체를 생성한다.
   * @param {THREE.Vector3} p1 시작점 좌표
   * @param {THREE.Vector3} p2 끝점 좌표
   * @returns {THREE.Geometry} 생성된 geometry
   */
  static generateDottedLineGeom(p1, p2) {
    if (!crystalUtil._cylinder) {
      crystalUtil._cylinder = new CylinderGeometry(0.1, 0.1, 0.15, 4).lookAt(new three_module_Vector3(0, 10, 0));
    }
    var v1 = p2.clone();
    v1.sub(p1);
    const vlen = v1.length();
    const dt = 1 / vlen * 0.2;
    var step = dt;
    var st = 0;
    var ed = 1;
    var up = new three_module_Vector3(0, 1, 0);

    //var mergedGeo = new THREE.BufferGeometry();
    var listGeom = [];
    var matTr = new Matrix4();
    var matSc = new Matrix4();
    var matLk = new Matrix4();
    var pos = new three_module_Vector3();
    for (var i = st; i <= ed; i += step) {
      pos.set(p1.x, p1.y, p1.z);
      pos.lerp(p2, i);
      matTr.makeTranslation(pos.x, pos.y, pos.z);
      matSc.makeScale(0.2, 0.2, 0.6);
      matLk.lookAt(pos, p2, up);
      matTr.multiply(matLk);
      matTr.multiply(matSc);

      //mergedGeo.merge(_cylinder, matTr);
      var dgeom = crystalUtil._cylinder.clone().applyMatrix4(matTr);
      listGeom.push(dgeom);
    }
    var mergedGeo = BufferGeometryUtils.mergeBufferGeometries(listGeom);
    return mergedGeo;
  }

  /**
   * 2D 사각형 객체를 생성한다.
   * @param {THREE.Vector3} p1 시작점 좌표
   * @param {THREE.Vector3} p2 끝점 좌표
   * @returns {THREE.Geometry} 생성된 geometry
   */
  static generateRectangleGeom(p1, p2) {
    let rect = new PlaneGeometry(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y));
    return rect;
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIMeasureDistance.js





/**
 * 거리 측정 클래스
 * */
class crystalUIMeasureDistance {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_base crystalUIMeasureDistance가 부착될 HTML Element
   * @param {crystalUIHandler} ui UI Handler
   */
  constructor(app, div_base, ui) {
    this._app = app;
    this._div_base = div_base;
    this._ui = ui;
    this._mdists = [];
    this._preview = null;
    this._previewLine = null;
    this._color = 0xff00ff;
    this._prevPickPoint = null;
    this._sceneRoot = null;
  }

  /**
   * 초기화
   * */
  CheckInitRoot() {
    if (this._sceneRoot) return;
    this._sceneRoot = new Group();
    this._sceneRoot.name = "M_DIST";
    this._app._3dRender._renderer._scene2.add(this._sceneRoot);
  }

  /**
   * Measure Distance Clear
   * */
  ClearAll() {
    for (var md of this._mdists) {
      this._sceneRoot.remove(md._mesh);
      md._mesh.geometry.dispose();
      md._mesh.material.dispose();
      md.remove();
    }
    this._mdists = [];
  }

  /**
   * 마우스 이동 처리
   * 
   * @param {Number} px 포인터 x
   * @param {Number} py 포인터 y
   */
  HandleMouseMove(px, py) {
    if (!this._preview) return;
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      let wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (wpt.distanceTo(this._prevPickPoint) > 0.001) this.UpdatePreview(wpt, true);else this.UpdatePreview(wpt, false);
      return true;
    }
    let wpt = this._ui.ScreenToWorldOnPlane(px, py, this._app._3dRender._renderer._camera, this._prevPickPoint);
    this.UpdatePreview(wpt, false);
  }

  /**
   * 마우스 클릭 처리
   * 
   * @param {Number} px 마우스 x
   * @param {Number} py 마우스 y
   */
  HandleClick(px, py) {
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      var wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (this._preview) {
        if (wpt.distanceTo(this._prevPickPoint) > 0.001) this.PreviewToMeasure(wpt);
      } else {
        this.CreatePreview(wpt);
      }
      return true;
    }
    return false;
  }

  /**
   * 미리보기 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  CreatePreview(wpt) {
    this.ResetPreview();
    this._prevPickPoint = wpt.clone();

    // make line geometry for preview
    var pts = new Float32Array(6);
    pts[0] = wpt.x;
    pts[1] = wpt.y;
    pts[2] = wpt.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    var lgeom = new BufferGeometry();
    lgeom.setAttribute("position", new BufferAttribute(pts, 3));
    lgeom.setDrawRange(0, 2);
    var lmat = new LineBasicMaterial({
      color: this._color
    });
    this._previewLine = new Line(lgeom, lmat);
    this._sceneRoot.add(this._previewLine);

    // preview distancetext.
    this._preview = document.createElement("div");
    this._preview.classList.add("cryUI_MeasureTextDist");
    this._div_base.appendChild(this._preview);
    this._preview.style.left = "4px";
    this._preview.style.top = "4px";
    this._preview.innerText = "";
    this._preview._startPt = wpt.clone();
    this._preview._midPt = wpt.clone();
    this._preview._endPt = wpt.clone();
    const spt = this._preview._startPt;
    const dist = spt.distanceTo(wpt);
    const mpt = spt.clone().add(wpt).multiplyScalar(0.5);
    const scrpt = this._ui.WorldToScreen(mpt);
    this._preview._distance = dist;
    this._preview.innerText = dist.toFixed(2) + "Å";
    this._preview.style.left = scrpt.x.toFixed(0) + "px";
    this._preview.style.top = scrpt.y.toFixed(0) + "px";
    this._preview.style.backgroundColor = "rgba(255,255,0,0.9)";
  }

  /**
   * 미리보기 업데이트
   * @param {THREE.Vector3} wpt 월드 좌표
   * @param {Boolean} can_finish 완료 가능 여부
   */
  UpdatePreview(wpt, can_finish = false) {
    if (!this._preview || !this._previewLine) return;
    const pts = this._previewLine.geometry.attributes.position.array;
    pts[0] = this._prevPickPoint.x;
    pts[1] = this._prevPickPoint.y;
    pts[2] = this._prevPickPoint.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    this._previewLine.geometry.attributes.position.needsUpdate = true;
    this._previewLine.geometry.computeBoundingBox();
    this._previewLine.geometry.computeBoundingSphere();
    const spt = this._prevPickPoint.clone();
    const dist = spt.distanceTo(wpt);
    const mpt = spt.clone().add(wpt).multiplyScalar(0.5);
    const scrpt = this._ui.WorldToScreen(mpt);
    this._preview._startPt = spt.clone();
    this._preview._midPt = mpt.clone();
    this._preview._endPt = wpt.clone();
    this._preview._distance = dist;
    this._preview.innerText = dist.toFixed(2) + "Å";
    this._preview.style.left = scrpt.x.toFixed(0) + "px";
    this._preview.style.top = scrpt.y.toFixed(0) + "px";
    if (can_finish) {
      this._preview.style.backgroundColor = "";
    } else {
      this._preview.style.backgroundColor = "rgba(255,255,0,0.9)";
    }
  }

  /**
   * 측정 완료된 measure preview 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  PreviewToMeasure(wpt) {
    if (!this._preview) return;
    this.UpdatePreview(wpt, true);
    this._preview.style.backgroundColor = "";

    // add new segment on measure preview
    var mat = new MeshBasicMaterial({
      color: this._color
    });
    var geom = crystalUtil.generateDottedLineGeom(this._prevPickPoint, wpt);
    var mesh = new three_module_Mesh(geom, mat);
    this._sceneRoot.add(mesh);
    this._preview._mesh = mesh;
    this._mdists.push(this._preview);

    // clear line geom for preview
    if (this._previewLine) {
      this._sceneRoot.remove(this._previewLine);
      this._previewLine.geometry.dispose();
      this._previewLine.material.dispose();
      this._previewLine = null;
    }
    this._preview = null;
  }

  /**
   * 미리보기 제거
   * */
  ResetPreview() {
    if (!this._preview) return;
    if (this._previewLine) {
      this._sceneRoot.remove(this._previewLine);
      this._previewLine.geometry.dispose();
      this._previewLine.material.dispose();
      this._previewLine = null;
    }
    if (this._preview._mesh) this._sceneRoot.remove(this._preview._mesh);
    this._preview.remove();
    this._preview = null;
  }

  /**
   * measure text 정렬
   * */
  AutoAlignText() {
    for (var md of this._mdists) {
      let mpt = md._midPt;
      let scrpt = this._ui.WorldToScreen(mpt);
      md.style.left = scrpt.x.toFixed(0) + "px";
      md.style.top = scrpt.y.toFixed(0) + "px";
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIMeasureAngle.js




/**
 * 각도 측정 클래스
 * */
class crystalUIMeasureAngle {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_base crystalUIMeasureAngle이 부착될 HTML Element
   * @param {crystalUIHandler} ui UI Handler
   */
  constructor(app, div_base, ui) {
    this._app = app;
    this._div_base = div_base;
    this._ui = ui;
    this._mdists = [];
    this._preview = null;
    this._previewLine = null;
    this._color = 0x0000ff;
    this._prevPickPoint = null;
    this._sceneRoot = null;
    this._step = 0;
  }

  /**
   * 초기화
   * */
  CheckInitRoot() {
    if (this._sceneRoot) return;
    this._sceneRoot = new Group();
    this._sceneRoot.name = "M_ANGLE";
    this._app._3dRender._renderer._scene2.add(this._sceneRoot);
    this._step = 0;
  }

  /**
   * Measure Distance Clear
   * */
  ClearAll() {
    for (var md of this._mdists) {
      this._sceneRoot.remove(md._mesh1);
      md._mesh1.geometry.dispose();
      md._mesh1.material.dispose();
      this._sceneRoot.remove(md._mesh2);
      md._mesh2.geometry.dispose();
      md._mesh2.material.dispose();
      md.remove();
    }
    this._mdists = [];
  }

  /**
   * 마우스 이동 처리
   * 
   * @param {Number} px 포인터 x
   * @param {Number} py 포인터 y
   */
  HandleMouseMove(px, py) {
    if (!this._preview) return;
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      let wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (wpt.distanceTo(this._preview._startPt) < 0.001) this.UpdatePreview(wpt, false);else if (this._step === 2 && wpt.distanceTo(this._preview._midPt) < 0.001) this.UpdatePreview(wpt, false);else this.UpdatePreview(wpt, true);
      return true;
    }
    let wpt = this._ui.ScreenToWorldOnPlane(px, py, this._app._3dRender._renderer._camera, this._prevPickPoint);
    this.UpdatePreview(wpt, false);
  }

  /**
   * 마우스 클릭 처리
   * 
   * @param {Number} px 마우스 x
   * @param {Number} py 마우스 y
   */
  HandleClick(px, py) {
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      var wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (this._preview) {
        if (wpt.distanceTo(this._preview._startPt) < 0.001) return true;
        if (this._step === 2 && wpt.distanceTo(this._preview._midPt) < 0.001) return true;
        this.PreviewToMeasure(wpt);
      } else {
        this.CreatePreview(wpt);
      }
      return true;
    }
    return false;
  }

  /**
   * 미리보기 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  CreatePreview(wpt) {
    this.ResetPreview();
    this._prevPickPoint = wpt.clone();

    // make line geometry for preview
    var pts = new Float32Array(6);
    pts[0] = wpt.x;
    pts[1] = wpt.y;
    pts[2] = wpt.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    var lgeom = new BufferGeometry();
    lgeom.setAttribute("position", new BufferAttribute(pts, 3));
    lgeom.setDrawRange(0, 2);
    var lmat = new LineBasicMaterial({
      color: this._color
    });
    this._previewLine = new Line(lgeom, lmat);
    this._sceneRoot.add(this._previewLine);

    // preview distancetext.
    this._preview = document.createElement("div");
    this._preview.classList.add("cryUI_MeasureTextAngle");
    this._div_base.appendChild(this._preview);
    this._preview.style.left = "4px";
    this._preview.style.top = "4px";
    this._preview.innerText = "";
    this._preview.style.visibility = "hidden";
    this._preview._startPt = wpt.clone();
    this._preview._midPt = wpt.clone();
    this._preview._endPt = wpt.clone();
    this._step = 1;
  }

  /**
   * 미리보기 업데이트
   * @param {THREE.Vector3} wpt 월드 좌표
   * @param {Boolean} can_finish 완료 가능 여부
   */
  UpdatePreview(wpt, can_finish = false) {
    if (!this._preview || !this._previewLine) return;
    const pts = this._previewLine.geometry.attributes.position.array;
    pts[0] = this._prevPickPoint.x;
    pts[1] = this._prevPickPoint.y;
    pts[2] = this._prevPickPoint.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    this._previewLine.geometry.attributes.position.needsUpdate = true;
    this._previewLine.geometry.computeBoundingBox();
    this._previewLine.geometry.computeBoundingSphere();
    if (this._step === 1) {
      // when first line
      this._preview._startPt = this._prevPickPoint.clone();
      this._preview._midPt = wpt.clone();
      this._preview.style.visibility = "hidden";
    } else if (this._step === 2) {
      // when second line (can make angle)
      this._preview._endPt = wpt.clone();
      this._preview.style.visibility = "visible";
      const scrpt = this._ui.WorldToScreen(this._preview._midPt);
      const va = this._preview._startPt.clone().sub(this._preview._midPt);
      const vb = wpt.clone().sub(this._preview._midPt);
      const ang = va.angleTo(vb) / Math.PI * 180.0;
      this._preview._angle = ang;
      this._preview.innerText = ang.toFixed(2) + "°";
      this._preview.style.left = scrpt.x.toFixed(0) + "px";
      this._preview.style.top = scrpt.y.toFixed(0) + "px";
      if (can_finish) {
        this._preview.style.backgroundColor = "";
      } else {
        this._preview.style.backgroundColor = "rgba(255,255,0,0.9)";
      }
    }
  }

  /**
   * 단계별 measure preview 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  PreviewToMeasure(wpt) {
    if (!this._preview) return;
    this.UpdatePreview(wpt, true);
    this._preview.style.backgroundColor = "";
    if (this._step === 1) {
      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._startPt, this._preview._midPt);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh1 = mesh;

      // set second preview line
      if (this._previewLine) {
        const pts = this._previewLine.geometry.attributes.position.array;
        pts[0] = this._preview._midPt.x;
        pts[1] = this._preview._midPt.y;
        pts[2] = this._preview._midPt.z;
        pts[3] = wpt.x;
        pts[4] = wpt.y;
        pts[5] = wpt.z;
        this._previewLine.geometry.attributes.position.needsUpdate = true;
        this._previewLine.geometry.computeBoundingBox();
        this._previewLine.geometry.computeBoundingSphere();
      }
      this._step++;
      this._prevPickPoint = wpt.clone();
    } else if (this._step === 2) {
      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._midPt, this._preview._endPt);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh2 = mesh;
      this._mdists.push(this._preview);

      // clear line geom for preview
      if (this._previewLine) {
        this._sceneRoot.remove(this._previewLine);
        this._previewLine.geometry.dispose();
        this._previewLine.material.dispose();
        this._previewLine = null;
      }
      this._preview = null;
      this._step = 0;
    }
  }

  /**
   * 미리보기 제거
   * */
  ResetPreview() {
    if (!this._preview) return;
    if (this._previewLine) {
      this._sceneRoot.remove(this._previewLine);
      this._previewLine.geometry.dispose();
      this._previewLine.material.dispose();
      this._previewLine = null;
    }
    if (this._preview._mesh2) {
      this._sceneRoot.remove(this._preview._mesh2);
      this._preview._mesh2.geometry.dispose();
      this._preview._mesh2.material.dispose();
    }
    if (this._preview._mesh1) {
      this._sceneRoot.remove(this._preview._mesh1);
      this._preview._mesh1.geometry.dispose();
      this._preview._mesh1.material.dispose();
    }
    this._preview.remove();
    this._preview = null;
    this._step = 0;
  }

  /**
   * measure text 정렬
   * */
  AutoAlignText() {
    for (var md of this._mdists) {
      let mpt = md._midPt;
      let scrpt = this._ui.WorldToScreen(mpt);
      md.style.left = scrpt.x.toFixed(0) + "px";
      md.style.top = scrpt.y.toFixed(0) + "px";
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIMeasureAngleDihedral.js




/**
 * dihedral 측정 클래스
 * */
class crystalUIMeasureAngleDihedral {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_base crystalUIMeasureAngleDihedral이 부착될 HTML Element
   * @param {crystalUIHandler} ui UI Handler
   */
  constructor(app, div_base, ui) {
    this._app = app;
    this._div_base = div_base;
    this._ui = ui;
    this._mdists = [];
    this._preview = null;
    this._previewLine = null;
    this._color = 0xffa000;
    this._prevPickPoint = null;
    this._sceneRoot = null;
    this._step = 0;
    this._pickObjs = [];
  }

  /**
   * 초기화
   * */
  CheckInitRoot() {
    if (this._sceneRoot) return;
    this._sceneRoot = new Group();
    this._sceneRoot.name = "M_ANGLE_DH";
    this._app._3dRender._renderer._scene2.add(this._sceneRoot);
    this._step = 0;
    this._pickObjs = [];
  }

  /**
   * Measure Angle Dihedral Clear
   * */
  ClearAll() {
    for (var md of this._mdists) {
      this._sceneRoot.remove(md._mesh1);
      md._mesh1.geometry.dispose();
      md._mesh1.material.dispose();
      this._sceneRoot.remove(md._mesh2);
      md._mesh2.geometry.dispose();
      md._mesh2.material.dispose();
      this._sceneRoot.remove(md._mesh3);
      md._mesh3.geometry.dispose();
      md._mesh3.material.dispose();
      md.remove();
    }
    this._mdists = [];
  }

  /**
   * 마우스 이동 처리
   * 
   * @param {Number} px 포인터 x
   * @param {Number} py 포인터 y
   */
  HandleMouseMove(px, py) {
    if (!this._preview) return;
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      let wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (this._pickObjs.includes(paobj._obj)) {
        this.UpdatePreview(wpt, false);
      } else if (this._step < 3) this.UpdatePreview(wpt, false);else this.UpdatePreview(wpt, true);
      return true;
    }
    let wpt = this._ui.ScreenToWorldOnPlane(px, py, this._app._3dRender._renderer._camera, this._prevPickPoint);
    this.UpdatePreview(wpt, false);
  }

  /**
   * 마우스 클릭 처리
   * 
   * @param {Number} px 마우스 x
   * @param {Number} py 마우스 y
   */
  HandleClick(px, py) {
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var paobj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
    if (paobj) {
      if (this._pickObjs.includes(paobj._obj)) {
        return false;
      }
      var wpt = new three_module_Vector3();
      paobj._obj.getWorldPosition(wpt);
      if (this._preview) {
        this.PreviewToMeasure(wpt);
      } else {
        this.CreatePreview(wpt);
      }
      return true;
    }
    return false;
  }

  /**
   * 미리보기 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  CreatePreview(wpt) {
    this.ResetPreview();
    this._prevPickPoint = wpt.clone();

    // make line geometry for preview
    var pts = new Float32Array(6);
    pts[0] = wpt.x;
    pts[1] = wpt.y;
    pts[2] = wpt.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    var lgeom = new BufferGeometry();
    lgeom.setAttribute("position", new BufferAttribute(pts, 3));
    lgeom.setDrawRange(0, 2);
    var lmat = new LineBasicMaterial({
      color: this._color
    });
    this._previewLine = new Line(lgeom, lmat);
    this._sceneRoot.add(this._previewLine);

    // preview text.
    this._preview = document.createElement("div");
    this._preview.classList.add("cryUI_MeasureTextAngleDihedral");
    this._div_base.appendChild(this._preview);
    this._preview.style.left = "4px";
    this._preview.style.top = "4px";
    this._preview.innerText = "";
    this._preview.style.visibility = "hidden";
    this._preview._pt1 = wpt.clone();
    this._preview._pt2 = wpt.clone();
    this._preview._pt3 = wpt.clone();
    this._preview._pt4 = wpt.clone();
    this._step = 1;
  }

  /**
   * 미리보기 업데이트
   * @param {THREE.Vector3} wpt 월드 좌표
   * @param {Boolean} can_finish 완료 가능 여부
   */
  UpdatePreview(wpt, can_finish = false) {
    if (!this._preview || !this._previewLine) return;
    const pts = this._previewLine.geometry.attributes.position.array;
    pts[0] = this._prevPickPoint.x;
    pts[1] = this._prevPickPoint.y;
    pts[2] = this._prevPickPoint.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    this._previewLine.geometry.attributes.position.needsUpdate = true;
    this._previewLine.geometry.computeBoundingBox();
    this._previewLine.geometry.computeBoundingSphere();
    if (this._step === 1) {
      // when first line (A-B)
      this._preview._pt1 = this._prevPickPoint.clone();
      this._preview._pt2 = wpt.clone();
      this._preview.style.visibility = "hidden";
    } else if (this._step === 2) {
      // when second line (B-C)
      this._preview._pt3 = wpt.clone();
      this._preview._midPt = this._preview._pt2.clone().add(this._preview._pt3).multiplyScalar(0.5);
      this._preview.style.visibility = "hidden";
    } else if (this._step === 3) {
      // when third line (C-D) (can make angle)
      this._preview._pt4 = wpt.clone();
      this._preview.style.visibility = "visible";
      let scrpt = this._ui.WorldToScreen(this._preview._midPt);
      let plane1 = new Plane().setFromCoplanarPoints(this._preview._pt1, this._preview._pt2, this._preview._pt3);
      let plane2 = new Plane().setFromCoplanarPoints(this._preview._pt2, this._preview._pt3, this._preview._pt4);
      let va = plane1.normal;
      let vb = plane2.normal;
      let ang = va.angleTo(vb) / Math.PI * 180.0;
      this._preview._angle = ang;
      this._preview.innerText = ang.toFixed(2) + "°";
      this._preview.style.left = scrpt.x.toFixed(0) + "px";
      this._preview.style.top = scrpt.y.toFixed(0) + "px";
      if (can_finish) {
        this._preview.style.backgroundColor = "";
      } else {
        this._preview.style.backgroundColor = "rgba(255,255,0,0.9)";
      }
    }
  }

  /**
   * 단계별 measure preview 생성
   * @param {THREE.Vector3} wpt 월드 좌표
   */
  PreviewToMeasure(wpt) {
    if (!this._preview) return;
    this.UpdatePreview(wpt, true);
    this._preview.style.backgroundColor = "";
    if (this._step === 1) {
      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._pt1, this._preview._pt2);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh1 = mesh;

      // set second preview line
      if (this._previewLine) {
        const pts = this._previewLine.geometry.attributes.position.array;
        pts[0] = this._preview._pt2.x;
        pts[1] = this._preview._pt2.y;
        pts[2] = this._preview._pt2.z;
        pts[3] = wpt.x;
        pts[4] = wpt.y;
        pts[5] = wpt.z;
        this._previewLine.geometry.attributes.position.needsUpdate = true;
        this._previewLine.geometry.computeBoundingBox();
        this._previewLine.geometry.computeBoundingSphere();
      }
      this._step++;
      this._prevPickPoint = wpt.clone();
    } else if (this._step === 2) {
      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._pt2, this._preview._pt3);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh2 = mesh;

      // set second preview line
      if (this._previewLine) {
        const pts = this._previewLine.geometry.attributes.position.array;
        pts[0] = this._preview._pt3.x;
        pts[1] = this._preview._pt3.y;
        pts[2] = this._preview._pt3.z;
        pts[3] = wpt.x;
        pts[4] = wpt.y;
        pts[5] = wpt.z;
        this._previewLine.geometry.attributes.position.needsUpdate = true;
        this._previewLine.geometry.computeBoundingBox();
        this._previewLine.geometry.computeBoundingSphere();
      }
      this._step++;
      this._prevPickPoint = wpt.clone();
    } else if (this._step === 3) {
      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._pt3, this._preview._pt4);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh3 = mesh;
      this._mdists.push(this._preview);

      // clear line geom for preview
      if (this._previewLine) {
        this._sceneRoot.remove(this._previewLine);
        this._previewLine.geometry.dispose();
        this._previewLine.material.dispose();
        this._previewLine = null;
      }
      this._preview = null;
      this._step = 0;
      this._pickObjs = [];
    }
  }

  /**
   * 미리보기 제거
   * */
  ResetPreview() {
    if (!this._preview) return;
    if (this._previewLine) {
      this._sceneRoot.remove(this._previewLine);
      this._previewLine.geometry.dispose();
      this._previewLine.material.dispose();
      this._previewLine = null;
    }
    if (this._preview._mesh3) {
      this._sceneRoot.remove(this._preview._mesh3);
      this._preview._mesh3.geometry.dispose();
      this._preview._mesh3.material.dispose();
    }
    if (this._preview._mesh2) {
      this._sceneRoot.remove(this._preview._mesh2);
      this._preview._mesh2.geometry.dispose();
      this._preview._mesh2.material.dispose();
    }
    if (this._preview._mesh1) {
      this._sceneRoot.remove(this._preview._mesh1);
      this._preview._mesh1.geometry.dispose();
      this._preview._mesh1.material.dispose();
    }
    this._preview.remove();
    this._preview = null;
    this._step = 0;
    this._pickObjs = [];
  }

  /**
   * measure text 정렬
   * */
  AutoAlignText() {
    for (var md of this._mdists) {
      let mpt = md._midPt;
      let scrpt = this._ui.WorldToScreen(mpt);
      md.style.left = scrpt.x.toFixed(0) + "px";
      md.style.top = scrpt.y.toFixed(0) + "px";
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIMeasureAngleInterfacial.js




/**
 * interfacial 측정 클래스
 * */
class crystalUIMeasureAngleInterfacial {
  /**
   * 생성자
   * @param {crystalEditor} app 상위 앱 객체
   * @param {HTMLElement} div_base crystalUIMeasureAngleInterfacial이 부착될 HTML Element
   * @param {crystalUIHandler} ui UI Handler
   */
  constructor(app, div_base, ui) {
    this._app = app;
    this._div_base = div_base;
    this._ui = ui;
    this._mdists = [];
    this._preview = null;
    this._previewLine = null;
    this._color = 0xff7000;
    this._nmLen = 1.0;
    this._prevPickPoint = null;
    this._sceneRoot = null;
    this._step = 0;
    this._pickFaces = [];
  }

  /**
   * 초기화
   * */
  CheckInitRoot() {
    if (this._sceneRoot) return;
    this._sceneRoot = new Group();
    this._sceneRoot.name = "M_ANGLE_IF";
    this._app._3dRender._renderer._scene2.add(this._sceneRoot);
    this._step = 0;
    this._pickObjs = [];
    this._previewPickFace = null;
  }

  /**
   * Measure Angle Dihedral Clear
   * */
  ClearAll() {
    for (var md of this._mdists) {
      this._sceneRoot.remove(md._mesh1);
      md._mesh1.geometry.dispose();
      md._mesh1.material.dispose();
      this._sceneRoot.remove(md._mesh2);
      md._mesh2.geometry.dispose();
      md._mesh2.material.dispose();
      this._sceneRoot.remove(md._mesh3);
      md._mesh3.geometry.dispose();
      md._mesh3.material.dispose();
      md.remove();
    }
    this._mdists = [];
  }
  RemovePreviewPickFace() {
    if (this._previewPickFace) {
      this._sceneRoot.remove(this._previewPickFace);
      this._previewPickFace.geometry.dispose();
      this._previewPickFace.material.dispose();
      this._previewPickFace = null;
    }
  }
  UpdatePreviewPickFace(face) {
    this.RemovePreviewPickFace();
    let geom = new BufferGeometry();
    const vertices = [face.v1.x, face.v1.y, face.v1.z, face.v2.x, face.v2.y, face.v2.z, face.v3.x, face.v3.y, face.v3.z];
    const indices = [0, 1, 2];
    const normals = [face.normal.x, face.normal.y, face.normal.z, face.normal.x, face.normal.y, face.normal.z, face.normal.x, face.normal.y, face.normal.z];
    geom.setIndex(indices);
    geom.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geom.setAttribute("normal", new Float32BufferAttribute(vertices, 3));
    let lmat = new MeshPhongMaterial({
      color: this._color,
      opacity: 0.5,
      transparent: true
    });
    this._previewPickFace = new three_module_Mesh(geom, lmat);
    this._sceneRoot.add(this._previewPickFace);
  }

  /**
   * 마우스 이동 처리
   * 
   * @param {Number} px 포인터 x
   * @param {Number} py 포인터 y
   */
  HandleMouseMove(px, py) {
    //this.RemovePreviewPickFace();

    if (this._step === 1) {
      var ncoord = this._ui.ScreenToNormalized(px, py);
      var pickFace = this._app._3dRender._renderer.pickObjectCrystalFace(ncoord);
      if (pickFace) {
        let mp = pickFace.midpoint;
        let nv = pickFace.normal;
        //rayLog(3, "pick Face Normal " + nv.x + "," + nv.y + "," + nv.z);
        //rayLog(3, "pick Face Midpoint " + mp.x + "," + mp.y + "," + mp.z);

        //this.UpdatePreviewPickFace(pickFace);

        this.UpdatePreview(mp.clone(), pickFace);
        return true;
      } else {
        let wpt = this._ui.ScreenToWorldOnPlane(px, py, this._app._3dRender._renderer._camera, this._preview._pt1);
        this.UpdatePreview(wpt, null);
      }
    }
  }

  /**
   * 마우스 클릭 처리
   * 
   * @param {Number} px 마우스 x
   * @param {Number} py 마우스 y
   */
  HandleClick(px, py) {
    var ncoord = this._ui.ScreenToNormalized(px, py);
    var pickFace = this._app._3dRender._renderer.pickObjectCrystalFace(ncoord);
    if (pickFace) {
      let mp = pickFace.midpoint;
      let nv = pickFace.normal;
      //rayLog(3, "pick Face Normal " + nv.x + "," + nv.y + "," + nv.z);
      //rayLog(3, "pick Face Midpoint " + mp.x + "," + mp.y + "," + mp.z);

      if (this._step === 0) {
        this.CreatePreview(pickFace);
      } else if (this._step === 1) {
        this.PreviewToMeasure(pickFace);
      }
      return true;
    }
    return false;
  }

  /**
   * 미리보기 생성
   * @param {Object} face crystal face
   */
  CreatePreview(face) {
    this.ResetPreview();

    // make line geometry for preview
    let wpt = face.midpoint;
    var pts = new Float32Array(6);
    pts[0] = wpt.x;
    pts[1] = wpt.y;
    pts[2] = wpt.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    var lgeom = new BufferGeometry();
    lgeom.setAttribute("position", new BufferAttribute(pts, 3));
    lgeom.setDrawRange(0, 2);
    var lmat = new LineBasicMaterial({
      color: this._color
    });
    this._previewLine = new Line(lgeom, lmat);
    this._sceneRoot.add(this._previewLine);

    // preview text.
    this._preview = document.createElement("div");
    this._preview.classList.add("cryUI_MeasureTextAngleInterfacial");
    this._div_base.appendChild(this._preview);
    this._preview.style.left = "4px";
    this._preview.style.top = "4px";
    this._preview.innerText = "";
    this._preview.style.visibility = "hidden";
    this._preview._pt1 = wpt.clone();
    this._preview._pt2 = wpt.clone();

    // face 1 normal 
    var mat = new MeshBasicMaterial({
      color: this._color
    });
    var geom = crystalUtil.generateDottedLineGeom(this._preview._pt1, this._preview._pt1.clone().add(face.normal.clone().normalize().multiplyScalar(this._nmLen)));
    var mesh = new three_module_Mesh(geom, mat);
    this._sceneRoot.add(mesh);
    this._preview._mesh1 = mesh;
    this._preview._face1 = face;
    this._step = 1;
  }

  /**
   * 미리보기 업데이트
   * @param {THREE.Vector3} wpt 월드 좌표
   * @param {Object} face crystal face
   */
  UpdatePreview(wpt, face) {
    if (!this._preview || !this._previewLine) return;
    const pts = this._previewLine.geometry.attributes.position.array;
    pts[0] = this._preview._pt1.x;
    pts[1] = this._preview._pt1.y;
    pts[2] = this._preview._pt1.z;
    pts[3] = wpt.x;
    pts[4] = wpt.y;
    pts[5] = wpt.z;
    this._previewLine.geometry.attributes.position.needsUpdate = true;
    this._previewLine.geometry.computeBoundingBox();
    this._previewLine.geometry.computeBoundingSphere();
    if (this._step === 1) {
      this._preview._pt2 = wpt.clone();
      if (!face) {
        this._preview.style.visibility = "hidden";
        this._preview.innerText = "???";
      } else {
        let va = this._preview._face1.normal;
        let vb = face.normal;
        let ang = va.angleTo(vb) / Math.PI * 180.0;
        this._preview._angle = ang;
        this._preview.innerText = ang.toFixed(2) + "°";
        this._preview._midPt = this._preview._pt1.clone().add(this._preview._pt2).multiplyScalar(0.5);
        let scrpt = this._ui.WorldToScreen(this._preview._midPt);
        this._preview.style.left = scrpt.x.toFixed(0) + "px";
        this._preview.style.top = scrpt.y.toFixed(0) + "px";
        this._preview.style.visibility = "visible";
      }
    }
  }

  /**
   * 단계별 measure preview 생성
   * @param {Object} face crystal face
   */
  PreviewToMeasure(face) {
    if (!this._preview) return;
    this.UpdatePreview(face.midpoint.clone(), face);
    this._preview.style.backgroundColor = "";
    if (this._step === 1) {
      this._preview._pt2 = face.midpoint.clone();

      // face 2 normal 
      var mat2 = new MeshBasicMaterial({
        color: this._color
      });
      var geom2 = crystalUtil.generateDottedLineGeom(this._preview._pt2, this._preview._pt2.clone().add(face.normal.clone().normalize().multiplyScalar(this._nmLen)));
      var mesh2 = new three_module_Mesh(geom2, mat2);
      this._sceneRoot.add(mesh2);
      this._preview._mesh2 = mesh2;

      // add new segment on measure preview
      var mat = new MeshBasicMaterial({
        color: this._color
      });
      var geom = crystalUtil.generateDottedLineGeom(this._preview._pt1, this._preview._pt2);
      var mesh = new three_module_Mesh(geom, mat);
      this._sceneRoot.add(mesh);
      this._preview._mesh3 = mesh;
      this._preview._face2 = face;
      this._mdists.push(this._preview);

      // clear line geom for preview
      if (this._previewLine) {
        this._sceneRoot.remove(this._previewLine);
        this._previewLine.geometry.dispose();
        this._previewLine.material.dispose();
        this._previewLine = null;
      }
      this._preview = null;
      this._step = 0;
      this._pickFaces = [];
    }
  }

  /**
   * 미리보기 제거
   * */
  ResetPreview() {
    if (!this._preview) return;
    if (this._previewLine) {
      this._sceneRoot.remove(this._previewLine);
      this._previewLine.geometry.dispose();
      this._previewLine.material.dispose();
      this._previewLine = null;
    }
    if (this._preview._mesh3) {
      this._sceneRoot.remove(this._preview._mesh3);
      this._preview._mesh3.geometry.dispose();
      this._preview._mesh3.material.dispose();
    }
    if (this._preview._mesh2) {
      this._sceneRoot.remove(this._preview._mesh2);
      this._preview._mesh2.geometry.dispose();
      this._preview._mesh2.material.dispose();
    }
    if (this._preview._mesh1) {
      this._sceneRoot.remove(this._preview._mesh1);
      this._preview._mesh1.geometry.dispose();
      this._preview._mesh1.material.dispose();
    }
    this._preview.remove();
    this._preview = null;
    this._step = 0;
    this._pickFaces = [];
  }

  /**
   * measure text 정렬
   * */
  AutoAlignText() {
    for (var md of this._mdists) {
      let mpt = md._midPt;
      let scrpt = this._ui.WorldToScreen(mpt);
      md.style.left = scrpt.x.toFixed(0) + "px";
      md.style.top = scrpt.y.toFixed(0) + "px";
    }
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalUIHandler.js








/**
 * ui handler 클래스
 * */
class crystalUIHandler {
  /**
   * 생성자 
   * @param {crystalEditor} app 상위 앱 객체
   */
  constructor(app) {
    this._app = app;

    // button flags

    this._mode = 0;
    this._bStartClick = false;
    this._bDragStart = false;
    this._clickPosX = -1;
    this._clickPosY = -1;
    this._bStartSelect = false;
    this._bStartMeasureDistance = false;
    this._bStartMeasureAngle = false;
    this._bStartMeasureAngleDihedral = false;
    this._bStartMeasureAngleInterfacial = false;
    this._select = new crystalUISelect(this._app, this._app._div_3dRender, this);
    this._measureDistance = new crystalUIMeasureDistance(this._app, this._app._div_3dRender, this);
    this._measureAngle = new crystalUIMeasureAngle(this._app, this._app._div_3dRender, this);
    this._measureAngleDihedral = new crystalUIMeasureAngleDihedral(this._app, this._app._div_3dRender, this);
    this._measureAngleInterfacial = new crystalUIMeasureAngleInterfacial(this._app, this._app._div_3dRender, this);
  }

  /**
   * 월드 좌표계를 스크린 좌표계로 변환한다
   * @param {THREE.Vector3} wpt 월드좌표계
   * @returns 변환된 점
   */
  WorldToScreen(wpt) {
    //rayLog(3, "mouse px : " + px + "," + py);

    var lcv = wpt.clone().project(this._app._3dRender._renderer._camera);
    var px = (lcv.x + 1.0) * 0.5 * this._app._div_3dRender.clientWidth;
    var py = (1.0 - (lcv.y + 1.0) * 0.5) * this._app._div_3dRender.clientHeight;

    //var cx = (px / this._app._div_rbase.clientWidth) * 2.0 - 1.0;
    //var cy = (1.0 - py / this._app._div_rbase.clientHeight) * 2.0 - 1.0;
    //rayLog(3, "mouse coord : " + cx + "," + cy);

    return new three_module_Vector3(px, py, 0);
  }

  /**
   * 스크린 좌표계에서 월드 좌표계로 변환한다
   * @param {Number} px x 좌표
   * @param {Number} py y 좌표
   * @returns wcv
   */
  ScreenToWorld(px, py) {
    //rayLog(3, "mouse px : " + px + "," + py);

    var cx = px / this._app._div_3dRender.clientWidth * 2.0 - 1.0;
    var cy = (1.0 - py / this._app._div_3dRender.clientHeight) * 2.0 - 1.0;
    //rayLog(3, "mouse coord : " + cx + "," + cy);

    var wcv = new three_module_Vector3(cx, cy, -1).unproject(this._app._3dRender._renderer._camera);
    return wcv;
  }

  /**
   * 스크린 상의 좌표를 월드 좌표계 평면으로 옮긴다
   * @param {Number} px x 좌표
   * @param {Number} py y 좌표
   * @param {THREE.Camera} camera 카메라
   * @param {THREE.Vector3} plane_point 평면 좌표
   * @returns 교차점
   */
  ScreenToWorldOnPlane(px, py, camera, plane_point) {
    var np = this.ScreenToNormalized(px, py);
    var cam_dir = new three_module_Vector3();
    camera.getWorldDirection(cam_dir);
    var plane = new Plane();
    plane.setFromNormalAndCoplanarPoint(cam_dir, plane_point);
    var raycaster = new Raycaster();
    raycaster.setFromCamera(np, camera);
    var intersects = new three_module_Vector3(0, 0, 0);
    raycaster.ray.intersectPlane(plane, intersects);
    rayLog(3, "worlds on plane : " + plane_point.x + "," + plane_point.y + "," + plane_point.z + " / " + cam_dir.x + "," + cam_dir.y + "," + cam_dir.z);
    rayLog(3, "np : " + px + "," + py + " / int : " + intersects.x + "," + intersects.y + "," + intersects.z);
    if (intersects) {
      return intersects;
    }
    return null;
  }

  /**
   * 스크린 좌표를 normalize하여 반환한다.
   * @param {Number} px 
   * @param {Number} py 
   * @returns 
   */
  ScreenToNormalized(px, py) {
    //rayLog(3, "mouse px : " + px + "," + py);

    var cx = px / this._app._div_3dRender.clientWidth * 2.0 - 1.0;
    var cy = (1.0 - py / this._app._div_3dRender.clientHeight) * 2.0 - 1.0;
    //rayLog(3, "normalized (-1,1) coord : " + cx + "," + cy);

    var nc = new Vector2(cx, cy);
    return nc;
  }

  /**
   * 클릭 플래그 활성화
   * @param {Event} event 이벤트
   */
  OnMouseDown(event) {
    let crect = this._app._div_3dRender.getBoundingClientRect();
    let ex = event.x - crect.x;
    let ey = event.y - crect.y;
    if (event.button === 0) {
      this._bStartClick = true;
      this._clickPosX = ex;
      this._clickPosY = ey;
      this._bDragStart = false;
    }
    this._select.SetClick(ex, ey);
    return false;
  }

  /**
   * 드래그 설정 혹은 거리 측정
   * @param {Event} event 
   * @returns 
   */
  OnMouseMove(event) {
    let crect = this._app._div_3dRender.getBoundingClientRect();
    let ex = event.x - crect.x;
    let ey = event.y - crect.y;
    if (this._bStartClick) {
      if (!this._bDragStart) {
        if (Math.abs(ex - this._clickPosX) > 3 && Math.abs(ey - this._clickPosY) > 3) {
          this._bDragStart = true;
        }
      } else {
        if (this._mode === 1) {
          this._select.HandleMouseMove(ex, ey);
        }
      }
    } else {
      if (this._bStartMeasureDistance) {
        this._measureDistance.HandleMouseMove(ex, ey);
      }
      if (this._bStartMeasureAngle) {
        this._measureAngle.HandleMouseMove(ex, ey);
      }
      if (this._bStartMeasureAngleDihedral) {
        this._measureAngleDihedral.HandleMouseMove(ex, ey);
      }
      if (this._bStartMeasureAngleInterfacial) {
        this._measureAngleInterfacial.HandleMouseMove(ex, ey);
      }
    }
    return false;
  }

  /**
   * mouse up 이벤트를 처리한다.
   * 
   * @param {Event} event
   */
  OnMouseUp(event) {
    let crect = this._app._div_3dRender.getBoundingClientRect();
    let ex = event.x - crect.x;
    let ey = event.y - crect.y;
    if (this._mode === 1) {
      this._select.HandleClick(ex, ey);
    }
    if (event.button === 0) {
      if (this._bStartClick && !this._bDragStart) {
        if (this._bStartMeasureDistance) {
          this._measureDistance.HandleClick(ex, ey);
        }
        if (this._bStartMeasureAngle) {
          this._measureAngle.HandleClick(ex, ey);
        }
        if (this._bStartMeasureAngleDihedral) {
          this._measureAngleDihedral.HandleClick(ex, ey);
        }
        if (this._bStartMeasureAngleInterfacial) {
          this._measureAngleInterfacial.HandleClick(ex, ey);
        }

        /*
        var ncoord = this.ScreenToNormalized(event.offsetX, event.offsetY);
        var obj = null;
        var obj = this._app._3dRender._renderer.pickObjectAtom(ncoord);
          if (obj) {
            let pos = new THREE.Vector3();
            obj._obj.getWorldPosition(pos);
            rayLog(3, "picked mesh for Atom " + obj._obj.id + " at " + pos.x + "," + pos.y + "," + pos.z);
        }
        */
      }

      /*
        if (!this._bDragStart) {
          if (this._bStartMeasure) {
              this.HandleClickMeasure(event.offsetX, event.offsetY);
          } else {
              var ncoord = this.ScreenToNormalized(event.offsetX, event.offsetY);
              var obj = null;
              obj = this._app._renderer.pickObject(ncoord);
              if (obj && obj.visible) {
                  if (obj._isPVBB) {
                      if (obj._PVID >= 0) {
                          rayLog(3, "picked mesh BBOX PVID = " + obj._PVID);
                          this._app._topSeqBar.ForceSelectProteinByPVID(obj._PVID);
                      }
                  } else {
                      if (obj._PVID !== undefined && obj._PVID >= 0) {
                          if (obj._PVID === this._app._curProtein._PVID) {
                              rayLog(3, " picked mesh ID = " + obj._id);
                                if (obj._cartoon) {
                                  rayLog(3, "picked CartoonSeg meta-property : " + obj._cartoon._meta._property);
                              }
                                this.AddSelectedObjsIDList([obj._id], !window.event.ctrlKey);
                          } else {
                              rayLog(3, " picked mesh is for another protein. change protein select (PVID " + obj._PVID + ")");
                              this._app._topSeqBar.ForceSelectProteinByPVID(obj._PVID);
                          }
                      } else {
                          rayLog(3, " picked mesh has no PVID.");
                      }
                  }
              } else {
                  if (!this._app.PickProteinBBOX(ncoord)) {
                      if (!window.event.ctrlKey)
                          this.ResetSelectedObj();
                  }
              }
            }
      }
      */

      this._bStartClick = false;
      this._bDragStart = false;
    }
    return true;
  }

  /**
   * 키 이벤트 처리
   * @param {Event} event
   */
  OnKeyPress(event) {
    if (event.key === "Escape") {
      if (this.FinishAllMeasures()) return true;
    } else if (event.key === "Delete") {
      // ui select 선택한 atom, bond 선택해제하기
    }
    return false;
  }

  /**
   * 후처리 과정 measure text align
   * */
  _postRender() {
    this._measureDistance.AutoAlignText();
    this._measureAngle.AutoAlignText();
    this._measureAngleDihedral.AutoAlignText();
    this._measureAngleInterfacial.AutoAlignText();
    this._select.AutoAlignText();
  }

  /**
   * 거리 측정 시작
   * */
  StartMeasureDistance() {
    this.FinishAllMeasures();
    this._mode = -1;
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = three_module_MOUSE.ROTATE;
    this._measureDistance.CheckInitRoot();
    this._bStartMeasureDistance = true;
    this._app._floatingToolMeasure.Show();
    this._app.UpdateUI();
  }

  /**
   * 각도 측정 시작
   * */
  StartMeasureAngle() {
    this.FinishAllMeasures();
    this._mode = -1;
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = three_module_MOUSE.ROTATE;
    this._measureAngle.CheckInitRoot();
    this._bStartMeasureAngle = true;
    this._app._floatingToolMeasure.Show();
    this._app.UpdateUI();
  }

  /**
   * 이면각 측정 시작
   * */
  StartMeasureAngleDihedral() {
    this.FinishAllMeasures();
    this._mode = -1;
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = three_module_MOUSE.ROTATE;
    this._measureAngleDihedral.CheckInitRoot();
    this._bStartMeasureAngleDihedral = true;
    this._app._floatingToolMeasure.Show();
    this._app.UpdateUI();
  }

  /**
   * 평면 간 각도 측정 시작
   * */
  StartMeasureAngleInterfacial() {
    this.FinishAllMeasures();
    this._mode = -1;
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = three_module_MOUSE.ROTATE;
    this._measureAngleInterfacial.CheckInitRoot();
    this._bStartMeasureAngleInterfacial = true;
    this._app._floatingToolMeasure.Show();
    this._app.UpdateUI();
  }

  /**
   * 회전 모드
   * */
  StartRotate() {
    this.FinishAllMeasures();
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = three_module_MOUSE.ROTATE;
    this._mode = 0;
    this._app.UpdateUI();
  }

  /**
   * 선택 모드
   * */
  StartSelect() {
    this.FinishAllMeasures();
    this._mode = 1;
    if (this._app._3dRender._renderer) this._app._3dRender._renderer._controls.mouseButtons.LEFT = -1;
    this._app.UpdateUI();
  }

  /**
   * 측정 값 모두 제거
   * */
  ClearAllMeasures() {
    this.FinishAllMeasures();
    this._measureDistance.ClearAll();
    this._measureAngle.ClearAll();
    this._measureAngleDihedral.ClearAll();
    this._measureAngleInterfacial.ClearAll();
    this._select.ClearAll();
  }

  /**
   * 측정 종료
   * */
  FinishAllMeasures() {
    let bRet = false;
    if (this._bStartMeasureDistance) {
      this.FinishMeasureDistance();
      bRet = true;
    }
    if (this._bStartMeasureAngle) {
      this.FinishMeasureAngle();
      bRet = true;
    }
    if (this._bStartMeasureAngleDihedral) {
      this.FinishMeasureAngleDihedral();
      bRet = true;
    }
    if (this._bStartMeasureAngleInterfacial) {
      this.FinishMeasureAngleInterfacial();
      bRet = true;
    }
    if (this._mode === 1) {
      this.FinishSelect();
      bRet = true;
    }
    return bRet;
  }

  /**
   * 거리 측정 종료
   * */
  FinishMeasureDistance() {
    this._measureDistance.ResetPreview();
    this._bStartMeasureDistance = false;
    this._mode = 0;
    this._app._floatingToolMeasure.Hide();
    this._app.UpdateUI();
  }

  /**
   * 각도 측정 종료
   * */
  FinishMeasureAngle() {
    this._measureAngle.ResetPreview();
    this._bStartMeasureAngle = false;
    this._mode = 0;
    this._app._floatingToolMeasure.Hide();
    this._app.UpdateUI();
  }

  /**
   * 이면각 측정 종료
   * */
  FinishMeasureAngleDihedral() {
    this._measureAngleDihedral.ResetPreview();
    this._bStartMeasureAngleDihedral = false;
    this._mode = 0;
    this._app._floatingToolMeasure.Hide();
    this._app.UpdateUI();
  }

  /**
   * 평면 간 각 측정 종료
   * */
  FinishMeasureAngleInterfacial() {
    this._measureAngleInterfacial.ResetPreview();
    this._bStartMeasureAngleInterfacial = false;
    this._mode = 0;
    this._app._floatingToolMeasure.Hide();
    this._app.UpdateUI();
  }

  /**
   * drag 선택 종료
   * */
  FinishSelect() {
    this._select.Init();
  }
}
;// CONCATENATED MODULE: ./CrystalEditor/crystalEditor.js

































/**
 * Crystal Editor App 클래스
 * */
class crystalEditor {
  /**
   * 생성자
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @param {HTMLElement} div_elem crystalEditor가 부착될 html element
   * @param {Boolean} is_portlet portlet 여부
   */
  constructor(name, div_elem, is_portlet) {
    new crystalVariable();
    this._name = name;
    this._div = div_elem;
    this._div.innerHTML = this._appElementHTML(name);
    this._div_topMenu = document.getElementById(name + "_topMenu");
    this._div_topToolBar = document.getElementById(name + "_topToolBar");
    this._div_leftToolBar = document.getElementById(name + "_leftToolBar");
    this._div_property = document.getElementById(name + "_propertyWindow");
    this._div_3dRender = document.getElementById(name + "_3DRender");
    this._div_logBar = document.getElementById(name + "_logBar");
    this._div_subarea = document.getElementsByClassName("subarea1")[0];
    this._div_edit_data = document.getElementById(name + "_dlgEditData");
    this._div_edit_data_confirm = document.getElementById(name + "_dlgEditDataConfirm");
    this._div_edit_bond = document.getElementById(name + "_dlgEditBond");
    this._div_edit_bond_confirm = document.getElementById(name + "_dlgEditBondConfirm");
    this._div_periodic = document.getElementById(name + "_dlgPeriodic");
    this._div_property_general = document.getElementById(name + "_dlgPropertyGeneral");
    this._div_boundary_setting = document.getElementById(name + "_dlgBoundarySetting");
    this._div_floatingToolMeasure = document.getElementById(name + "_floatingToolMeasure");
    this._div_edit_vectors = document.getElementById(name + "_dlgEditVectors");
    this._div_edit_lattice_plane = document.getElementById(name + "_dlgEditLatticePlane");
    this._div_create_vector = document.getElementById(name + "_dlgCreateVector");
    this._div_input_text = document.getElementById(name + "_dlgInputText");
    this._div_render_options = document.getElementById(name + "_dlgRenderOptions");
    this._div_structure_property = document.getElementById(name + "_dlgStructureProperty");
    this._div_export_image = document.getElementById(name + "_dlgExportImage");
    this._div_progress = document.getElementById(name + "_dlgProgress");
    this._div_waiter = document.getElementById(name + "_waiter");
    this._div_new_confirm = document.getElementById(name + "_dlgNewConfirm");
    this._load_file = document.getElementById(name + "_load_file");
    this._load_cif = document.getElementById(name + "_load_cif");
    this._import_cif = document.getElementById(name + "_import_cif");
    this._import_mol = document.getElementById(name + "_import_mol");
    this._topMenu = new crystalTopMenu(name, this, this._div_topMenu);
    this._topToolBar = new crystalTopToolBar(name, this, this._div_topToolBar);
    this._leftToolBar = new crystalLeftToolBar(name, this, this._div_leftToolBar);
    this._property = new crystalPropertyBar(name, this, this._div_property);
    crystalEditor.I = this;
    this._logBar = new crystalLogBar(name, this, this._div_logBar);
    this._3dRender = new crystalRenderer(name, this, this._div_3dRender);
    this._dlgEditData = new crystalEditDataDialog(name, this, this._div_edit_data);
    this._dlgEditDataConfirm = new crystalEditDataConfirmDialog(name, this, this._div_edit_data_confirm);
    this._dlgEditBond = new crystalEditBondDialog(name, this, this._div_edit_bond);
    this._dlgEditBondConfirm = new crystalEditBondConfirmDialog(name, this, this._div_edit_bond_confirm);
    this._dlgPeriodic = new crystalPeriodicDialog(name, this, this._div_periodic);
    this._dlgBoundarySetting = new crystalBoundarySettingDialog(name, this, this._div_boundary_setting);
    this._dlgEditVectors = new crystalEditVectorsDialog(name, this, this._div_edit_vectors);
    this._dlgEditLatticePlane = new crystalEditLatticePlaneDialog(name, this, this._div_edit_lattice_plane);
    this._dlgCreateVector = new crystalCreateVectorDialog(name, this, this._div_create_vector);
    this._dlgInputText = new crystalInputTextDialog(name, this, this._div_input_text);
    this._dlgRenderOptions = new crystalRenderOptionDialog(name, this, this._div_render_options);
    this._dlgStructureProperty = new crystalStructurePropertyDialog(name, this, this._div_structure_property);
    this._dlgExportImage = new crystalExportImageDialog(name, this, this._div_export_image);
    this._dlgProgress = new crystalProgressDialog(name, this, this._div_progress, this._div_waiter);
    this._dlgNewConfirm = new crystalNewConfirmDialog(name, this, this._div_new_confirm);
    this._uiHandler = new crystalUIHandler(this);
    this._floatingToolMeasure = new crystalUIFloatingToolMeasure(name, this, this._div_floatingToolMeasure);
    this._bModified = false;
    window.onbeforeunload = function () {
      if (crystalEditor.I._isPortlet) return;
      if (crystalEditor.I._bModified) return "Are you sure?";
    };
    window.addEventListener("resize", function () {
      crystalEditor.I.OnResize();
    });
    this._div_3dRender.addEventListener("pointerdown", function (event) {
      if (crystalEditor.I.OnMouseDown(event)) {
        event.stopPropagation();
        event.preventDefault();
      }
    });
    this._div_3dRender.addEventListener("pointermove", function (event) {
      if (crystalEditor.I.OnMouseMove(event)) {
        event.stopPropagation();
        event.preventDefault();
      }
    });
    this._div_3dRender.addEventListener("pointerup", function (event) {
      if (crystalEditor.I.OnMouseUp(event)) {
        event.stopPropagation();
        event.preventDefault();
      }
    });
    window.addEventListener("keyup", function (event) {
      if (crystalEditor.I.OnKeyPress(event)) {
        event.stopPropagation();
        event.preventDefault();
      }
    });
    this._load_file.onchange = function (event) {
      crystalEditor.I.LoadCSFromKCS(event.target.files[0]);
      crystalEditor.I._load_file.value = null;
    };
    this._load_cif.onchange = function (event) {
      crystalEditor.I.LoadFromCIF(event.target.files[0]);
      crystalEditor.I._load_cif.value = null;
    };
    this._import_cif.onchange = function (event) {
      // import function
      crystalEditor.I.ImportCIF(event.target.files[0]);
      crystalEditor.I._import_cif.value = null;
    };
    this._import_mol.onchange = function (event) {
      // import function
      crystalEditor.I.ImportMOL(event.target.files[0]);
      crystalEditor.I._import_mol.value = null;
    };
    this.InitRenderOptions();
    this.InitStructureProperty();
    this.InitMeasureOption();
  }

  /**
   * resize 수행 메소드
   * */
  OnResize() {
    this._divw = window.innerWidth;
    this._divh = window.innerHeight;
    this._div.style.width = this._divw + "px";
    this._div.style.height = this._divh + "px";
    if (this._div_topMenu && this._div_leftToolBar && this._div_topToolBar) {
      this._leftToolBar_height = this._divh - $(this._div_topMenu).height() - $(this._div_topToolBar).height();
      this._div_leftToolBar.style.height = this._leftToolBar_height + "px";
    }
    if (this._div_topMenu && this._div_property && this._div_topToolBar) {
      this._property_height = this._divh - $(this._div_topMenu).height() - $(this._div_topToolBar).height();
      this._div_property.style.height = this._property_height + "px";
    }
    this._topToolBar_height = $(this._div_topToolBar).height();
    this._leftToolBar_width = $(this._div_leftToolBar).width();
    this._property_width = $(this._div_property).width();

    // 상단 메뉴바에 걸친 영역도 모두 포함한다.
    var viewHeight = this._divh - this._topToolBar_height;
    var viewWidth = this._divw - this._leftToolBar_width - this._property_width;

    // 맨 아래 빈 공간
    this._canvas_width = viewWidth;
    this._canvas_height = viewHeight - $(this._div_logBar).height();
    this._canvas_aspect = this._canvas_width / this._canvas_height;
    this._div_3dRender.style.width = this._canvas_width + "px";
    this._div_3dRender.style.height = this._canvas_height + "px";
    this._div_logBar.style.width = this._div_3dRender.style.width;
    if (crystalRenderer.I && crystalRenderer.I._renderer) {
      crystalRenderer.I._renderer.onWindowResize(this._canvas_width, this._canvas_height);
    }
  }

  /**
   * mouse down 이벤트 처리
   * @param {Event} event mouse down
   */
  OnMouseDown(event) {
    return this._uiHandler.OnMouseDown(event);
  }

  /**
   * mouse move 이벤트 처리
   * @param {Event} event mouse move
   */
  OnMouseMove(event) {
    return this._uiHandler.OnMouseMove(event);
  }

  /**
   * mouse up 이벤트 처리
   * @param {Event} event mouse up
   */
  OnMouseUp(event) {
    return this._uiHandler.OnMouseUp(event);
  }

  /**
   * key press 이벤트 처리
   * @param {Event} event key press
   */
  OnKeyPress(event) {
    return this._uiHandler.OnKeyPress(event);
  }

  /**
   * camera auto fit
   * */
  MenuAutoFit() {
    this._3dRender._renderer.autofitCameraObjList([this._csManager._cs.getMesh()], 100);
  }

  /**
   * camera auto rotate
   * */
  MenuAutoRotate() {
    this._3dRender._autoRotateCamera = !this._3dRender._autoRotateCamera;
  }

  /**
   * export mol
   * */
  MenuExportMOL() {
    this.ExportMOL("crystal", this._csManager._cs);
  }

  /**
   * export obj
   * */
  MenuExportCIF() {
    this.ExportCIF("crystal", this._csManager._cs);
  }
  MenuExportOBJ() {
    this.ExportOBJ("crystal", this._csManager._cs);
  }

  /**
   * import cif
   * */
  MenuImportCIF() {
    rayLog(3, "import cif");
    this._import_cif.click();
  }

  /**
   * import mol
   * */
  MenuImportMOL() {
    rayLog(3, "import mol");
    this._import_mol.click();
  }

  /**
   * open edit data dialog - info tab
   * */
  MenuDataInfo() {
    this._dlgEditData.ShowDialog();
    $(this._dlgEditData._tabsEdit).tabs({
      active: 0
    });
  }

  /**
   * open edit data dialog - unitcell tab
   * */
  MenuDataUnitcell() {
    this._dlgEditData.ShowDialog();
    $(this._dlgEditData._tabsEdit).tabs({
      active: 1
    });
  }

  /**
   * open edit data dialog - csturcture tab
   * */
  MenuDataCStructure() {
    this._dlgEditData.ShowDialog();
    $(this._dlgEditData._tabsEdit).tabs({
      active: 2
    });
  }

  /**
   * open edit data dialog - crystal shape tab
   * */
  MenuDataCrystalShape() {
    this._dlgEditData.ShowDialog();
    $(this._dlgEditData._tabsEdit).tabs({
      active: 3
    });
  }

  /**
   * open edit bond dialog
   * */
  MenuDataBond() {
    this._dlgEditBond.ShowDialog();
  }

  /**
   * open edit vector dialog
   * */
  MenuDataVector() {
    this._dlgEditVectors.ShowDialog();
  }

  /**
   * open edit lattice plane dialog
   * */
  MenuDataLatticePlane() {
    this._dlgEditLatticePlane.ShowDialog();
  }

  /**
   * open edit boundary dialog
   * */
  MenuDataBoundary() {
    this._dlgBoundarySetting.ShowDialog();
  }

  /**
   * cstructure 변경 사항에 대해 undo 수행
   * */
  MenuEditUndo() {
    rayLog(3, "menu edit undo");
    this._csManager.DoUndo();
    this.UpdateRenderOptions();
  }

  /**
   * cstructure 변경 사항에 대해 redo 수행
   * */
  MenuEditRedo() {
    rayLog(3, "menu edit redo");
    this._csManager.DoRedo(this._csManager._cs.clone());
    this.UpdateRenderOptions();
  }

  /**
   * open periodic dialog
   * */
  MenuPeriodic() {
    this._dlgPeriodic.ShowDialog();
  }

  /**
   * clear cstructure
   * */
  MenuNew() {
    if (this._bModified) this._dlgNewConfirm.ShowDialog();else this._dlgNewConfirm.OnApply();
  }

  /**
   * unitcell 기본값 복원
   * */
  RestoreDefault() {
    this._csManager._cs._unitcell.set(cryst.Unitcell.alpha, cryst.Unitcell.beta, cryst.Unitcell.gamma, cryst.Unitcell.a, cryst.Unitcell.b, cryst.Unitcell.c);
  }

  /**
   * file dialog open
   * */
  MenuOpen() {
    rayLog(3, "menu open");
    this._load_file.click();
  }

  /**
   * cif file dialog open
   * */
  MenuOpenCIF() {
    rayLog(3, "menu open cif");
    this._load_cif.click();
  }

  /**
   * cstructure file save
   * */
  MenuSave() {
    rayLog(3, "menu save");
    this.SaveCSToKCS("CStructure");
    this._bModified = false;
  }

  /**
   * save render image
   * */
  MenuSaveRenderImage() {
    rayLog(3, "menu save render image");
    this._dlgExportImage.ShowDialog();
  }

  /**
   * rotate mode
   * */
  MenuToolRotate() {
    this._uiHandler.StartRotate();
  }

  /**
   * select mode
   * */
  MenuToolSelect() {
    this._uiHandler.StartSelect();
  }

  /**
   * measure distance mode
   * */
  MenuToolMeasureDistance() {
    this._uiHandler.StartMeasureDistance();
  }

  /**
   * measure angle mode
   * */
  MenuToolMeasureAngle() {
    this._uiHandler.StartMeasureAngle();
  }

  /**
   * measure dihedral angle mode
   * */
  MenuToolMeasureAngleDihedral() {
    this._uiHandler.StartMeasureAngleDihedral();
  }

  /**
   * measure interfacial angle mode
   * */
  MenuToolMeasureAngleInterfacial() {
    this._uiHandler.StartMeasureAngleInterfacial();
  }

  /**
   * clear all measure
   * */
  MenuToolClearMeasure() {
    this._uiHandler.ClearAllMeasures();
  }

  /**
   * render option dialog open
   * */
  MenuViewRenderOptions() {
    this._dlgRenderOptions.ShowDialog();
  }

  /**
   * zoom in
   * */
  MenuViewZoomIn() {
    this._3dRender._renderer.adjustOrthoZoom(cryst.ZoomIn);
  }

  /**
   * zoom out
   * */
  MenuViewZoomOut() {
    this._3dRender._renderer.adjustOrthoZoom(cryst.ZoomOut);
  }

  /**
   * view align axis A
   * */
  MenuViewAlignA() {
    this._3dRender._renderer.setOrthoCameraDirection(this._csManager._cs._unitcell._axis._va);
    this._3dRender._renderer.autofitCameraObjList([this._csManager._cs.getMesh()], 100);
  }

  /**
   * view align axis B
   * */
  MenuViewAlignB() {
    this._3dRender._renderer.setOrthoCameraDirection(this._csManager._cs._unitcell._axis._vb);
    this._3dRender._renderer.autofitCameraObjList([this._csManager._cs.getMesh()], 100);
  }

  /**
   * view align axis C
   * */
  MenuViewAlignC() {
    this._3dRender._renderer.setOrthoCameraDirection(this._csManager._cs._unitcell._axis._vc);
    this._3dRender._renderer.autofitCameraObjList([this._csManager._cs.getMesh()], 100);
  }

  /**
   * ui 업데이트
   * */
  UpdateUI() {
    if (this._topToolBar) {
      this._topToolBar.UpdateToolbarState();
    }
    if (this._leftToolBar) {
      this._leftToolBar.UpdateToolbarState();
    }
  }

  /**
   * crystalEditor에 대한 html element를 작성한다.
   *
   * @param {String} name 다른 앱과 구분하기 위한 이름
   * @returns {String} HTML 문자열
   */
  _appElementHTML(name) {
    let ihtml = [];
    let idx = 0;
    ihtml[idx] = "<div class='MainMenu' id='" + name + "_topMenu'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_topBar' id='" + name + "_topToolBar'></div>";
    idx++;
    ihtml[idx] = "<div class='subarea1'>";
    idx++;
    ihtml[idx] = "<div class='ToolBar2' id='" + name + "_leftToolBar'></div>";
    idx++;
    ihtml[idx] = "<div class='PropertyWindow' id='" + name + "_propertyWindow'></div>";
    idx++;
    ihtml[idx] = "<div class='subarea2'>";
    idx++;
    ihtml[idx] = "<div class='Render' id='" + name + "_3DRender'>";
    idx++;
    ihtml[idx] = "<div class='cryUI_FloatingToolMeasure' id='" + name + "_floatingToolMeasure'></div>";
    idx++;
    ihtml[idx] = "</div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_LogBar' id='" + name + "_logBar'></div>";
    idx++;
    ihtml[idx] = "</div></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditData'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditDataConfirm'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditBond'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditBondConfirm'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgPeriodic'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgPropertyGeneral'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgBoundarySetting'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditVectors'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgEditLatticePlane'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgCreateVector'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgInputText'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgRenderOptions'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgStructureProperty'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgExportImage'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgProgress'></div>";
    idx++;
    ihtml[idx] = "<div class='cryUI_Waiter' id='" + name + "_waiter'><div class='cryUI_Waiter_Msg' id='" + name + "_waiter_msg'></div></div>";
    idx++;
    ihtml[idx] = "<input id='" + name + "_load_file' type='file' accept='.kcs' value='' hidden />";
    idx++;
    ihtml[idx] = "<input id='" + name + "_load_cif' type='file' value='' hidden />";
    idx++;
    ihtml[idx] = "<input id='" + name + "_import_cif' type='file' accept='.cif' value='' hidden/>";
    idx++;
    ihtml[idx] = "<input id='" + name + "_import_mol' type='file' accept='.mol' value='' hidden/>";
    idx++;
    ihtml[idx] = "<div class='cryUI_MsgBox' id='" + name + "_dlgNewConfirm'></div>";
    idx++;
    return ihtml.join("");
  }

  /**
   * 현재 이미지를 export한다
   * @param {Number} pw 렌더링 너비
   * @param {Number} ph 렌더링 높이
   */
  ExportRenderImage(pw, ph) {
    var new_div = document.createElement("div");
    new_div.id = "_render_export";
    this._div.appendChild(new_div);
    new_div.style.position = "absolute";
    new_div.style.display = "block";
    new_div.style.visibility = "visible";
    new_div.style.zIndex = "-9999";
    new_div.style.width = pw + "px";
    new_div.style.height = ph + "px";
    var app = this;
    setTimeout(function () {
      rayLog(3, "div style " + new_div.style.width + "," + new_div.style.height);
      var new_rdr = new Renderer(new_div, true);
      new_rdr.renderFrameFromOtherRenderer(app._3dRender._renderer);
      new_rdr.saveScreenshot("export");
      new_rdr = null;
      new_div.remove();
    }, 100);
  }

  /**
   * KCS 파일로부터 CStructure를 불러온다.
   *
   * @param {File} file KCS 파일
   */
  LoadCSFromKCS(file) {
    let fileReader = new FileReader();
    fileReader.onload = async function () {
      await crystalEditor.I._dlgProgress.ShowDialog();
      await crystalEditor.I._dlgProgress.SetMsg("Loading CS from KCS File...");
      let data = fileReader.result;
      await crystalEditor.I._dlgProgress.SetProgress(0);

      // json 데이터로부터 cs를 복원한다.
      crystalEditor.I._csManager._cs = new CStructure();
      crystalEditor.I._dlgNewConfirm.OnApply();
      await crystalEditor.I._dlgProgress.SetProgress(0.1);
      crystalEditor.I._csManager._cs.LoadCStructure(JSON.parse(data));
      await crystalEditor.I._dlgProgress.SetProgress(0.2);
      crystalEditor.I._csManager._cs.generate();
      await crystalEditor.I._dlgProgress.SetProgress(0.3);
      crystalEditor.I.UpdateStructureProperty();
      crystalEditor.I.UpdateRenderOptions();
      await crystalEditor.I._dlgProgress.SetProgress(0.4);
      crystalEditor.I._3dRender._renderer._scene.add(crystalEditor.I._csManager._cs._groupMesh);
      crystalEditor.I._dlgEditData.UpdateTableByCS(crystalEditor.I._csManager._cs);
      await crystalEditor.I._dlgProgress.SetProgress(0.5);
      crystalEditor.I._dlgEditData.UpdateUnitcellByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditData.UpdateCrystalColor();
      await crystalEditor.I._dlgProgress.SetProgress(0.6);
      crystalEditor.I._dlgEditBond.UpdateTableByCS(crystalEditor.I._csManager._cs);
      await crystalEditor.I._dlgProgress.SetProgress(0.7);
      crystalEditor.I._dlgEditBond.UpdateTable();
      await crystalEditor.I._dlgProgress.SetProgress(0.8);
      crystalEditor.I._dlgEditLatticePlane.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._property.UpdateUI(); // object table update

      await crystalEditor.I._dlgProgress.SetProgress(0.9);
      crystalEditor.I._dlgBoundarySetting.UpdateBoundary();
      // vector table update
      crystalEditor.I._dlgEditVectors.UpdateTable();
      crystalEditor.I._dlgEditVectors.RestoreAddedVectorFromCS();
      crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
      await crystalEditor.I._dlgProgress.SetProgress(1);
      crystalEditor.I._dlgProgress.CloseDialog();
      crystalEditor.I._bModified = true;
      crystalEditor.I._csManager.ClearUndo();
    };
    fileReader.readAsText(file);
  }
  ImportCIF(file) {
    let fileReader = new FileReader();
    fileReader.onload = async function () {
      await crystalEditor.I._dlgProgress.ShowDialog();
      await crystalEditor.I._dlgProgress.SetMsg("Import CS from CIF File...");
      await crystalEditor.I._dlgProgress.SetProgress(0);
      let data = fileReader.result;
      crystalEditor.I._dlgNewConfirm.OnApply();
      Loader_Loader.loadFile("cif", data, crystalEditor.I._csManager._cs);
      await crystalEditor.I._dlgProgress.SetProgress(0.1);
      crystalEditor.I._3dRender.Clear();
      await crystalEditor.I._dlgProgress.SetProgress(0.2);
      crystalEditor.I._csManager._cs.generate();
      await crystalEditor.I._dlgProgress.SetProgress(0.6);
      crystalEditor.I.UpdateStructureProperty();
      crystalEditor.I.UpdateRenderOptions();
      await crystalEditor.I._dlgProgress.SetProgress(0.7);
      crystalEditor.I._dlgEditData.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditData.UpdateUnitcellByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditBond.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditData.UpdateCrystalColor();
      crystalEditor.I._dlgEditLatticePlane.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditBond.UpdateTable();
      crystalEditor.I._dlgBoundarySetting.UpdateBoundary();
      crystalEditor.I._property.UpdateUI();
      await crystalEditor.I._dlgProgress.SetProgress(0.8);
      crystalEditor.I._dlgEditVectors.UpdateTable();
      crystalEditor.I._dlgEditVectors.RestoreAddedVectorFromCS();
      await crystalEditor.I._dlgProgress.SetProgress(0.9);
      crystalEditor.I._3dRender._renderer._scene.children.pop();
      crystalEditor.I._3dRender._renderer._scene.add(crystalEditor.I._csManager._cs._groupMesh);
      crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
      await crystalEditor.I._dlgProgress.SetProgress(1);
      crystalEditor.I._dlgProgress.CloseDialog();
      crystalEditor.I._bModified = true;
      crystalEditor.I._csManager.ClearUndo();
    };
    fileReader.readAsText(file);
  }
  ImportMOL(file) {
    let fileReader = new FileReader();
    fileReader.onload = async function () {
      await crystalEditor.I._dlgProgress.ShowDialog();
      await crystalEditor.I._dlgProgress.SetMsg("Import CS from MOL File...");
      await crystalEditor.I._dlgProgress.SetProgress(0);
      let data = fileReader.result;
      crystalEditor.I._dlgNewConfirm.OnApply();
      Loader_Loader.loadFile("mol", data, crystalEditor.I._csManager._cs);
      await crystalEditor.I._dlgProgress.SetProgress(0.1);
      crystalEditor.I._3dRender.Clear();

      // boundary input 값 가져와서 설정하기
      let dlgBoundary = crystalEditor.I._dlgBoundarySetting;
      let minX = parseFloat($(dlgBoundary._input_min_x).val());
      let minY = parseFloat($(dlgBoundary._input_min_y).val());
      let minZ = parseFloat($(dlgBoundary._input_min_z).val());
      let maxX = parseFloat($(dlgBoundary._input_max_x).val());
      let maxY = parseFloat($(dlgBoundary._input_max_y).val());
      let maxZ = parseFloat($(dlgBoundary._input_max_z).val());
      crystalEditor.I._csManager._cs._boundary.set(new Vector3(minX, minY, minZ), new Vector3(maxX, maxY, maxZ));
      crystalEditor.I._csManager._cs.generate();
      await crystalEditor.I._dlgProgress.SetProgress(0.5);
      crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
      crystalEditor.I.UpdateStructureProperty();
      crystalEditor.I.UpdateRenderOptions();
      crystalEditor.I._dlgEditData.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditData.UpdateUnitcellByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditData.UpdateCrystalColor();
      crystalEditor.I._dlgEditBond.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditLatticePlane.UpdateTableByCS(crystalEditor.I._csManager._cs);
      crystalEditor.I._dlgEditBond.UpdateTable();
      crystalEditor.I._property.UpdateUI();
      await crystalEditor.I._dlgProgress.SetProgress(0.7);
      crystalEditor.I._dlgEditVectors.UpdateTable();
      crystalEditor.I._dlgEditVectors.RestoreAddedVectorFromCS();
      await crystalEditor.I._dlgProgress.SetProgress(0.9);
      crystalEditor.I._3dRender._renderer._scene.children.pop();
      crystalEditor.I._3dRender._renderer._scene.add(crystalEditor.I._csManager._cs._groupMesh);
      crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
      await crystalEditor.I._dlgProgress.SetProgress(1);
      crystalEditor.I._dlgProgress.CloseDialog();
      crystalEditor.I._bModified = true;
      crystalEditor.I._csManager.ClearUndo();
    };
    fileReader.readAsText(file);
  }
  GetCIFString() {
    return Loader_Loader.saveFile("cif", this._csManager._cs);
  }
  ExportCIF(filename, cs) {
    let data = Loader_Loader.saveFile("cif", cs);
    let blob = new Blob([data], {
      type: "text/plain"
    });
    let url = URL.createObjectURL(blob);
    let hiddenElem = document.createElement("a");
    hiddenElem.href = url;
    hiddenElem.target = "_blank";
    hiddenElem.download = filename + ".cif";
    hiddenElem.click();
    this._bModified = false;
  }
  SaveAsServer() {
    let cs = this._csManager._cs;
    const data = Loader_Loader.saveFile("cif", cs);
    this._bModified = false;
    return data;
  }
  async LoadCifFile(data) {
    await crystalEditor.I._dlgProgress.ShowDialog();
    await crystalEditor.I._dlgProgress.SetMsg("Import CS from CIF File...");
    await crystalEditor.I._dlgProgress.SetProgress(0);
    crystalEditor.I._dlgNewConfirm.OnApply();
    Loader_Loader.loadFile("cif", data, crystalEditor.I._csManager._cs);
    await crystalEditor.I._dlgProgress.SetProgress(0.1);
    crystalEditor.I._3dRender.Clear();
    await crystalEditor.I._dlgProgress.SetProgress(0.2);
    crystalEditor.I._csManager._cs.generate();
    await crystalEditor.I._dlgProgress.SetProgress(0.6);
    crystalEditor.I.UpdateStructureProperty();
    crystalEditor.I.UpdateRenderOptions();
    await crystalEditor.I._dlgProgress.SetProgress(0.7);
    crystalEditor.I._dlgEditData.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditData.UpdateUnitcellByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditBond.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditData.UpdateCrystalColor();
    crystalEditor.I._dlgEditLatticePlane.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditBond.UpdateTable();
    crystalEditor.I._dlgBoundarySetting.UpdateBoundary();
    crystalEditor.I._property.UpdateUI();
    await crystalEditor.I._dlgProgress.SetProgress(0.8);
    crystalEditor.I._dlgEditVectors.UpdateTable();
    crystalEditor.I._dlgEditVectors.RestoreAddedVectorFromCS();
    await crystalEditor.I._dlgProgress.SetProgress(0.9);
    crystalEditor.I._3dRender._renderer._scene.children.pop();
    crystalEditor.I._3dRender._renderer._scene.add(crystalEditor.I._csManager._cs._groupMesh);
    crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
    await crystalEditor.I._dlgProgress.SetProgress(1);
    crystalEditor.I._dlgProgress.CloseDialog();
    crystalEditor.I._bModified = true;
    crystalEditor.I._csManager.ClearUndo();
  }
  async LoadMolFile(data) {
    await crystalEditor.I._dlgProgress.ShowDialog();
    await crystalEditor.I._dlgProgress.SetMsg("Import CS from MOL File...");
    await crystalEditor.I._dlgProgress.SetProgress(0);
    crystalEditor.I._dlgNewConfirm.OnApply();
    Loader_Loader.loadFile("mol", data, crystalEditor.I._csManager._cs);
    await crystalEditor.I._dlgProgress.SetProgress(0.1);
    crystalEditor.I._3dRender.Clear();

    // boundary input 값 가져와서 설정하기
    let dlgBoundary = crystalEditor.I._dlgBoundarySetting;
    let minX = parseFloat($(dlgBoundary._input_min_x).val());
    let minY = parseFloat($(dlgBoundary._input_min_y).val());
    let minZ = parseFloat($(dlgBoundary._input_min_z).val());
    let maxX = parseFloat($(dlgBoundary._input_max_x).val());
    let maxY = parseFloat($(dlgBoundary._input_max_y).val());
    let maxZ = parseFloat($(dlgBoundary._input_max_z).val());
    crystalEditor.I._csManager._cs._boundary.set(new Vector3(minX, minY, minZ), new Vector3(maxX, maxY, maxZ));
    crystalEditor.I._csManager._cs.generate();
    await crystalEditor.I._dlgProgress.SetProgress(0.5);
    crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
    crystalEditor.I.UpdateStructureProperty();
    crystalEditor.I.UpdateRenderOptions();
    crystalEditor.I._dlgEditData.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditData.UpdateUnitcellByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditData.UpdateCrystalColor();
    crystalEditor.I._dlgEditBond.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditLatticePlane.UpdateTableByCS(crystalEditor.I._csManager._cs);
    crystalEditor.I._dlgEditBond.UpdateTable();
    crystalEditor.I._property.UpdateUI();
    await crystalEditor.I._dlgProgress.SetProgress(0.7);
    crystalEditor.I._dlgEditVectors.UpdateTable();
    crystalEditor.I._dlgEditVectors.RestoreAddedVectorFromCS();
    await crystalEditor.I._dlgProgress.SetProgress(0.9);
    crystalEditor.I._3dRender._renderer._scene.children.pop();
    crystalEditor.I._3dRender._renderer._scene.add(crystalEditor.I._csManager._cs._groupMesh);
    crystalEditor.I._3dRender._renderer.autofitCameraObjList([crystalEditor.I._csManager._cs.getMesh()], 100);
    await crystalEditor.I._dlgProgress.SetProgress(1);
    crystalEditor.I._dlgProgress.CloseDialog();
    crystalEditor.I._bModified = true;
    crystalEditor.I._csManager.ClearUndo();
    // crystalEditor.I.ImportMOL(data);
    // crystalEditor.I._import_mol.value = null;
  }

  ExportMOL(filename, cs) {
    let data = Loader_Loader.saveFile("mol", cs);
    let blob = new Blob([data], {
      type: "text/plain"
    });
    let url = URL.createObjectURL(blob);
    let hiddenElem = document.createElement("a");
    hiddenElem.href = url;
    hiddenElem.target = "_blank";
    hiddenElem.download = filename + ".mol";
    hiddenElem.click();
    this._bModified = false;
  }
  ExportOBJ(filename, cs) {
    let data = Loader_Loader.saveFile("obj", cs);
    let blob = new Blob([data], {
      type: "text/plain"
    });
    let url = URL.createObjectURL(blob);
    let hiddenElem = document.createElement("a");
    hiddenElem.href = url;
    hiddenElem.target = "_blank";
    hiddenElem.download = filename + ".obj";
    hiddenElem.click();
    this._bModified = false;
  }

  /**
   * txt로부터 atom 데이터를 로드한다.
   *
   * @param {String} txt atom 데이터가 포함된 텍스트
   */
  LoadAtomFromTxt(txt) {
    let res = crystalVariable.parse(txt);
    for (let i = 0; i < res.length; ++i) {
      let atomTxt = res[i];
      let id = AtomDef.GetDefWithID(atomTxt.atom)._atom_number;
      let atom = crystalEditor.I._dlgEditData.createAtom(crystalEditor.I._csManager._cs.assignAtomIdx(), id, "", atomTxt.a, atomTxt.b, atomTxt.c);
      crystalEditDataDialog.I._app._csManager._cs.addAtom(atom);
      crystalEditDataDialog.I.AddAtomToTable(atom._idx, id, atomTxt.atom, "", atomTxt.a, atomTxt.b, atomTxt.c, atomTxt.u, 0);
    }
  }

  /**
   * CStructure를 KCS 파일로 저장한다.
   * @param {String} filename 저장할 파일명
   */
  SaveCSToKCS(filename) {
    let jsonStr = JSON.stringify(crystalEditor.I._csManager._cs.SaveCStructure());
    let jsonData = new Blob([jsonStr], {
      type: "text/json"
    });
    let jsonUrl = URL.createObjectURL(jsonData);
    let hiddenElem = document.createElement("a");
    hiddenElem.href = jsonUrl;
    hiddenElem.target = "_blank";
    hiddenElem.download = filename + ".kcs";
    hiddenElem.click();
  }

  /**
   * Rendering Option 초기화
   * */
  InitRenderOptions() {
    this._renderOptions = JSON.parse(JSON.stringify(cryst.RenderOptionDefault));
    this.UpdateRenderOptions();
  }

  /**
   * Rendering Option 적용
   * */
  UpdateRenderOptions() {
    if (!crystalEditor.I._csManager) return;
    crystalEditor.I._csManager._cs.setRenderOption(crystalEditor.I, this._renderOptions);
    // this._renderOptions is option values (see crystalVariable.RenderOptionDefault structure);
    // update render options here
  }

  /**
   * Structure Property 초기화
   * */
  InitStructureProperty() {
    this._structureProperty = JSON.parse(JSON.stringify(cryst.StructurePropertyDefault));
    this.UpdateStructureProperty();
  }

  /**
   * Measure Option 초기화
   * */
  InitMeasureOption() {
    if (!crystalEditor.I._uiHandler) {
      return;
    }
    crystalEditor.I._uiHandler.StartRotate();
  }

  /**
   * Structure Property 업데이트
   * */
  UpdateStructureProperty() {
    // this._structureProperty is option values (see crystalVariable.StructurePropertyDefault structure);;
    // update render options here

    if (this._csManager && this._csManager._cs) {
      // Unitcell Color, Visible
      for (let i = 0; i < this._csManager._cs._groupEtcMesh.children[0].children.length; ++i) {
        this._csManager._cs._groupEtcMesh.children[0].children[i].material.color.set(crystalVariable.ColorRGBtoHexNum(this._structureProperty.UnitCell.Color));
      }
      this._csManager._cs._groupEtcMesh.children[0].visible = this._structureProperty.UnitCell.ShowLine;

      // Atom Shininess, Show Label
      this._csManager._cs.setAtomShininess(this._structureProperty.Atom.Shininess);

      // Bond Shininess
      this._csManager._cs.setBondShininess(this._structureProperty.Bond.Shininess);

      // Polyhedron Shininess, Show Line
      this._csManager._cs.setVisiblePolyhedronEdge(this._structureProperty.Polyhedron.ShowLine === 1);
      this._csManager._cs.setPolyhedronShininess(this._structureProperty.Polyhedron.Shininess);

      // Crystal Structure Show Color, Show Line
      this._csManager._cs.setVisibleCrystalShapeEdge(this._structureProperty.Crystal.ShowLine === 1);
      this._property._propertyStyle.OnApply();
    }
  }

  /**
   * 선택한 symmetry 옵션에 맞는 matrix index list를 반환한다.
   *
   * @returns {Array} symmetry matrix index list
   * */
  GetSymmetryIdxList() {
    let idxList = [];
    let settingNumIdx, spaceGroupIdx;
    if (this._dlgEditData._crystalTableData._selectedSetting) settingNumIdx = SettingDef._defOffList[$(this._dlgEditData._crystalTableData._selectedSetting[0]).find(".cryUI_Unit_Cell_Setting_Td").text()]._idx;
    if (this._dlgEditData._crystalTableData._selectedSpaceGroup) spaceGroupIdx = SpaceGroupDef._defList[$(this._dlgEditData._crystalTableData._selectedSpaceGroup[0]).find(".cryUI_Unit_Cell_Space_Group_Td").text()]._idx;
    if (!isNaN(spaceGroupIdx) && !isNaN(settingNumIdx)) idxList = getMatrixIdxList(spaceGroupIdx, settingNumIdx);
    if (idxList.length === 0) return null;
    return idxList;
  }
}

;// CONCATENATED MODULE: ./CrystalEditor/run.js


const SVR_LOG_MODE = 4;
rayLogSetMode(SVR_LOG_MODE);
const dap = document.getElementById("cryapp");
const cryApp = new crystalEditor("cryapp", dap, false);
window.crystalEditor = {
  clear: () => {
    cryApp.MenuNew();
  },
  SaveAsServer: () => {
    return cryApp.SaveAsServer();
  },
  LoadMolFile: data => {
    cryApp.LoadMolFile(data);
  },
  LoadCifFile: data => {
    cryApp.LoadCifFile(data);
  },
  GetCifString: () => {
    return cryApp.GetCIFString();
  },
  ExportCifFile: () => {
    cryApp.MenuExportCIF();
  },
  ImportCifFile: () => {
    cryApp.MenuImportCIF();
  }
};
/******/ })()
;